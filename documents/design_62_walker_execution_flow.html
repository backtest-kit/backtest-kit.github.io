<!DOCTYPE html><html class="default" lang="en" data-base=".."><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="IE=edge"/><title>design/62_walker_execution_flow | backtest-kit</title><meta name="description" content="Documentation for backtest-kit"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="../assets/style.css"/><link rel="stylesheet" href="../assets/highlight.css"/><script defer src="../assets/main.js"></script><script async src="../assets/icons.js" id="tsd-icons-script"></script><script async src="../assets/search.js" id="tsd-search-script"></script><script async src="../assets/navigation.js" id="tsd-nav-script"></script><script async src="../assets/hierarchy.js" id="tsd-hierarchy-script"></script></head><body><script>document.documentElement.dataset.theme = localStorage.getItem("tsd-theme") || "os";document.body.style.display="none";setTimeout(() => app?app.showPage():document.body.style.removeProperty("display"),500)</script><header class="tsd-page-toolbar"><div class="tsd-toolbar-contents container"><div class="table-cell" id="tsd-search"><div class="field"><label for="tsd-search-field" class="tsd-widget tsd-toolbar-icon search no-caption"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-search"></use></svg></label><input type="text" id="tsd-search-field" aria-label="Search"/></div><div class="field"><div id="tsd-toolbar-links"></div></div><ul class="results"><li class="state loading">Preparing search index...</li><li class="state failure">The search index is not available</li></ul><a href="../index.html" class="title">backtest-kit</a></div><div class="table-cell" id="tsd-widgets"><a href="#" class="tsd-widget tsd-toolbar-icon menu no-caption" data-toggle="menu" aria-label="Menu"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-menu"></use></svg></a></div></div></header><div class="container container-main"><div class="col-content"><div class="tsd-page-title"><ul class="tsd-breadcrumb"><li><a href="../modules.html">backtest-kit</a></li><li><a href="design_62_walker_execution_flow.html">design/62_walker_execution_flow</a></li></ul></div><div class="tsd-panel tsd-typography"><a id="walker-execution-flow" class="tsd-anchor"></a><h1 class="tsd-anchor-link">Walker Execution Flow<a href="#walker-execution-flow" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h1><a id="purpose-and-scope" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Purpose and Scope<a href="#purpose-and-scope" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This document describes the execution flow of Walker mode, which orchestrates sequential strategy comparison for metric-based optimization. It focuses on the <code>WalkerLogicPrivateService</code> implementation that iterates through strategies, extracts performance metrics, and tracks the best-performing strategy. For details on metric selection and comparison logic, see <a href="design_63_strategy_comparison.html">Strategy Comparison</a>. For report generation and output formats, see <a href="design_64_walker_reports.html">Walker Reports</a>. For the Walker API entry points, see <a href="design_19_walker_api.html">Walker API</a>.</p>
<a id="overview" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Overview<a href="#overview" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>Walker mode executes a complete backtest for each registered strategy in sequence, comparing their performance using a configurable metric (e.g., <code>sharpeRatio</code>, <code>winRate</code>). The execution model uses an <code>AsyncGenerator</code> pattern to stream progress updates after each strategy completes, enabling real-time monitoring of long-running optimization tasks. The system maintains cumulative tracking of the best strategy across all iterations and emits detailed progress events through the event bus.</p>
<p>The walker execution is stateless between strategy runs, relying on <code>BacktestLogicPublicService</code> for individual strategy execution and <code>BacktestMarkdownService</code> for metric extraction. This separation allows walker to focus purely on orchestration and comparison logic.</p>
<a id="execution-architecture" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Execution Architecture<a href="#execution-architecture" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p><img src="../media/62_Walker_Execution_Flow_0.svg" alt="Mermaid Diagram"></p>
<p><strong>Diagram: Walker Execution Architecture</strong> - Shows the layered architecture from API entry point through orchestration, strategy execution, statistics extraction, and callback lifecycle.</p>
<a id="sequential-strategy-iteration" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Sequential Strategy Iteration<a href="#sequential-strategy-iteration" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The walker orchestration follows a sequential iteration pattern where each strategy completes its full backtest before the next strategy begins. This approach ensures deterministic execution order and simplifies resource management compared to parallel execution.</p>
<a id="main-iteration-loop" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Main Iteration Loop<a href="#main-iteration-loop" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>The core iteration logic resides in <code>WalkerLogicPrivateService.run()</code> method, which implements an <code>AsyncGenerator</code> that yields after each strategy completes:</p>
<table>
<thead>
<tr>
<th>Step</th>
<th>Operation</th>
<th>Code Reference</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Initialize tracking variables</td>
<td><code>strategiesTested = 0</code>, <code>bestMetric = null</code>, <code>bestStrategy = null</code></td>
</tr>
<tr>
<td>2</td>
<td>Get walker schema</td>
<td><code>walkerSchemaService.get(context.walkerName)</code></td>
</tr>
<tr>
<td>3</td>
<td>Setup cancellation listener</td>
<td><code>walkerStopSubject.filter(...).map(() =&gt; CANCEL_SYMBOL)</code></td>
</tr>
<tr>
<td>4</td>
<td>Iterate strategies</td>
<td><code>for (const strategyName of strategies) { ... }</code></td>
</tr>
<tr>
<td>5</td>
<td>Execute strategy backtest</td>
<td><code>backtestLogicPublicService.run(symbol, {...})</code></td>
</tr>
<tr>
<td>6</td>
<td>Extract statistics</td>
<td><code>backtestMarkdownService.getData(symbol, strategyName)</code></td>
</tr>
<tr>
<td>7</td>
<td>Compare metric</td>
<td><code>metricValue &gt; bestMetric</code></td>
</tr>
<tr>
<td>8</td>
<td>Yield progress</td>
<td><code>yield walkerContract</code></td>
</tr>
<tr>
<td>9</td>
<td>Emit final results</td>
<td><code>walkerCompleteSubject.next(finalResults)</code></td>
</tr>
</tbody>
</table>
<p>The iteration maintains strict ordering with no overlap between strategy executions. Each strategy receives the same execution context (<code>exchangeName</code>, <code>frameName</code>) to ensure fair comparison.</p>
<a id="state-machine-for-single-strategy-execution" class="tsd-anchor"></a><h3 class="tsd-anchor-link">State Machine for Single Strategy Execution<a href="#state-machine-for-single-strategy-execution" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p><img src="../media/62_Walker_Execution_Flow_1.svg" alt="Mermaid Diagram"></p>
<p><strong>Diagram: State Machine for Single Strategy in Walker</strong> - Shows the complete lifecycle of a single strategy execution within the walker loop, from callback invocation through metric extraction to progress emission.</p>
<a id="backtest-orchestration" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Backtest Orchestration<a href="#backtest-orchestration" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>Each strategy execution delegates to <code>BacktestLogicPublicService.run()</code>, which returns an <code>AsyncGenerator&lt;IStrategyBacktestResult&gt;</code>. The walker consumes this generator completely using <code>resolveDocuments()</code> to collect all closed signals before proceeding to metric extraction.</p>
<a id="backtest-execution-context" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Backtest Execution Context<a href="#backtest-execution-context" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>The walker configures each backtest with a consistent execution context:</p>
<pre><code class="typescript"><span class="hl-1">{</span><br/><span class="hl-1">  </span><span class="hl-10">strategyName</span><span class="hl-1">: </span><span class="hl-4">string</span><span class="hl-1">,      </span><span class="hl-5">// Current strategy being tested</span><br/><span class="hl-1">  </span><span class="hl-10">exchangeName</span><span class="hl-1">: </span><span class="hl-4">string</span><span class="hl-1">,      </span><span class="hl-5">// From walker schema</span><br/><span class="hl-1">  </span><span class="hl-10">frameName</span><span class="hl-1">: </span><span class="hl-4">string</span><span class="hl-1">          </span><span class="hl-5">// From walker schema</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<p>This context is injected into <code>MethodContextService</code> and flows through the entire backtest execution pipeline via dependency injection. The symbol parameter is passed explicitly to the backtest runner.</p>
<a id="integration-with-backtestlogicpublicservice" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Integration with BacktestLogicPublicService<a href="#integration-with-backtestlogicpublicservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>The orchestration follows this sequence:</p>
<p><img src="../media/62_Walker_Execution_Flow_2.svg" alt="Mermaid Diagram"></p>
<p><strong>Diagram: Backtest Orchestration Sequence</strong> - Shows the message flow from walker through backtest execution to statistics extraction.</p>
<a id="error-handling-during-backtest" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Error Handling During Backtest<a href="#error-handling-during-backtest" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>If a strategy backtest throws an error, the walker catches it, logs the error, emits to <code>errorEmitter</code>, invokes the <code>onStrategyError</code> callback if defined, and continues to the next strategy. This fail-fast-per-strategy approach ensures that one broken strategy does not terminate the entire walker run.</p>
<pre><code class="typescript"><span class="hl-3">try</span><span class="hl-1"> {</span><br/><span class="hl-1">  </span><span class="hl-4">result</span><span class="hl-1"> = </span><span class="hl-3">await</span><span class="hl-1"> </span><span class="hl-13">Promise</span><span class="hl-1">.</span><span class="hl-0">race</span><span class="hl-1">([</span><br/><span class="hl-1">    </span><span class="hl-3">await</span><span class="hl-1"> </span><span class="hl-0">resolveDocuments</span><span class="hl-1">(</span><span class="hl-4">iterator</span><span class="hl-1">),</span><br/><span class="hl-1">    </span><span class="hl-4">listenStop</span><span class="hl-1">,</span><br/><span class="hl-1">  ]);</span><br/><span class="hl-1">} </span><span class="hl-3">catch</span><span class="hl-1"> (</span><span class="hl-4">error</span><span class="hl-1">) {</span><br/><span class="hl-1">  </span><span class="hl-4">console</span><span class="hl-1">.</span><span class="hl-0">warn</span><span class="hl-1">(</span><span class="hl-2">`walkerLogicPrivateService backtest failed symbol=</span><span class="hl-7">${</span><span class="hl-4">symbol</span><span class="hl-7">}</span><span class="hl-2"> strategyName=</span><span class="hl-7">${</span><span class="hl-4">strategyName</span><span class="hl-7">}</span><span class="hl-2">`</span><span class="hl-1">);</span><br/><span class="hl-1">  </span><span class="hl-7">this</span><span class="hl-1">.</span><span class="hl-4">loggerService</span><span class="hl-1">.</span><span class="hl-0">warn</span><span class="hl-1">(</span><span class="hl-2">&quot;walkerLogicPrivateService backtest failed for strategy, skipping&quot;</span><span class="hl-1">, {...});</span><br/><span class="hl-1">  </span><span class="hl-3">await</span><span class="hl-1"> </span><span class="hl-4">errorEmitter</span><span class="hl-1">.</span><span class="hl-0">next</span><span class="hl-1">(</span><span class="hl-4">error</span><span class="hl-1">);</span><br/><span class="hl-1">  </span><span class="hl-3">if</span><span class="hl-1"> (</span><span class="hl-4">walkerSchema</span><span class="hl-1">.</span><span class="hl-4">callbacks</span><span class="hl-1">?.</span><span class="hl-4">onStrategyError</span><span class="hl-1">) {</span><br/><span class="hl-1">    </span><span class="hl-4">walkerSchema</span><span class="hl-1">.</span><span class="hl-4">callbacks</span><span class="hl-1">.</span><span class="hl-0">onStrategyError</span><span class="hl-1">(</span><span class="hl-4">strategyName</span><span class="hl-1">, </span><span class="hl-4">symbol</span><span class="hl-1">, </span><span class="hl-4">error</span><span class="hl-1">);</span><br/><span class="hl-1">  }</span><br/><span class="hl-1">  </span><span class="hl-3">continue</span><span class="hl-1">; </span><span class="hl-5">// Skip to next strategy</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<a id="metric-extraction-and-comparison" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Metric Extraction and Comparison<a href="#metric-extraction-and-comparison" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>After each backtest completes, the walker extracts performance statistics from <code>BacktestMarkdownService</code> and compares the configured metric against the current best value.</p>
<a id="metric-validation-pipeline" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Metric Validation Pipeline<a href="#metric-validation-pipeline" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>The metric extraction implements a strict validation pipeline to handle edge cases:</p>
<table>
<thead>
<tr>
<th>Validation</th>
<th>Check</th>
<th>Action on Failure</th>
</tr>
</thead>
<tbody>
<tr>
<td>Type check</td>
<td><code>typeof value === 'number'</code></td>
<td>Set <code>metricValue = null</code></td>
</tr>
<tr>
<td>Not null/undefined</td>
<td><code>value !== null &amp;&amp; value !== undefined</code></td>
<td>Set <code>metricValue = null</code></td>
</tr>
<tr>
<td>NaN check</td>
<td><code>!isNaN(value)</code></td>
<td>Set <code>metricValue = null</code></td>
</tr>
<tr>
<td>Finite check</td>
<td><code>isFinite(value)</code></td>
<td>Set <code>metricValue = null</code></td>
</tr>
<tr>
<td>Pass all</td>
<td>All checks pass</td>
<td>Set <code>metricValue = value</code></td>
</tr>
</tbody>
</table>
<pre><code class="typescript"><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">value</span><span class="hl-1"> = </span><span class="hl-4">stats</span><span class="hl-1">[</span><span class="hl-4">metric</span><span class="hl-1">];</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">metricValue</span><span class="hl-1"> =</span><br/><span class="hl-1">  </span><span class="hl-4">value</span><span class="hl-1"> !== </span><span class="hl-7">null</span><span class="hl-1"> &amp;&amp;</span><br/><span class="hl-1">  </span><span class="hl-4">value</span><span class="hl-1"> !== </span><span class="hl-7">undefined</span><span class="hl-1"> &amp;&amp;</span><br/><span class="hl-1">  </span><span class="hl-7">typeof</span><span class="hl-1"> </span><span class="hl-4">value</span><span class="hl-1"> === </span><span class="hl-2">&quot;number&quot;</span><span class="hl-1"> &amp;&amp;</span><br/><span class="hl-1">  !</span><span class="hl-0">isNaN</span><span class="hl-1">(</span><span class="hl-4">value</span><span class="hl-1">) &amp;&amp;</span><br/><span class="hl-1">  </span><span class="hl-0">isFinite</span><span class="hl-1">(</span><span class="hl-4">value</span><span class="hl-1">)</span><br/><span class="hl-1">    ? </span><span class="hl-4">value</span><br/><span class="hl-1">    : </span><span class="hl-7">null</span><span class="hl-1">;</span>
</code><button type="button">Copy</button></pre>

<p>Invalid metrics result in <code>metricValue = null</code>, which is excluded from best strategy selection. This ensures that strategies producing invalid statistics (e.g., <code>NaN</code> Sharpe ratio due to zero volatility) do not win by default.</p>
<a id="best-strategy-update-logic" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Best Strategy Update Logic<a href="#best-strategy-update-logic" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>The comparison uses a simple maximization strategy where higher metric values are better:</p>
<pre><code class="typescript"><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">isBetter</span><span class="hl-1"> =</span><br/><span class="hl-1">  </span><span class="hl-4">bestMetric</span><span class="hl-1"> === </span><span class="hl-7">null</span><span class="hl-1"> ||</span><br/><span class="hl-1">  (</span><span class="hl-4">metricValue</span><span class="hl-1"> !== </span><span class="hl-7">null</span><span class="hl-1"> &amp;&amp; </span><span class="hl-4">metricValue</span><span class="hl-1"> &gt; </span><span class="hl-4">bestMetric</span><span class="hl-1">);</span><br/><br/><span class="hl-3">if</span><span class="hl-1"> (</span><span class="hl-4">isBetter</span><span class="hl-1"> &amp;&amp; </span><span class="hl-4">metricValue</span><span class="hl-1"> !== </span><span class="hl-7">null</span><span class="hl-1">) {</span><br/><span class="hl-1">  </span><span class="hl-4">bestMetric</span><span class="hl-1"> = </span><span class="hl-4">metricValue</span><span class="hl-1">;</span><br/><span class="hl-1">  </span><span class="hl-4">bestStrategy</span><span class="hl-1"> = </span><span class="hl-4">strategyName</span><span class="hl-1">;</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<p>Key behaviors:</p>
<ul>
<li><strong>First valid strategy</strong>: Always becomes best if <code>bestMetric === null</code> initially</li>
<li><strong>Null metrics</strong>: Strategies with <code>metricValue === null</code> never become best</li>
<li><strong>Ties</strong>: First strategy to achieve a tied metric wins (no tie-breaking logic)</li>
<li><strong>Maximization only</strong>: The system does not support minimization metrics (e.g., max drawdown)</li>
</ul>
<p>For metric selection details and supported metrics, see <a href="design_63_strategy_comparison.html">Strategy Comparison</a>.</p>
<a id="progress-tracking-and-emission" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Progress Tracking and Emission<a href="#progress-tracking-and-emission" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The walker emits two types of progress updates: fine-grained progress events via <code>progressWalkerEmitter</code> and rich contract objects via <code>walkerEmitter</code>.</p>
<a id="walkercontract-structure" class="tsd-anchor"></a><h3 class="tsd-anchor-link">WalkerContract Structure<a href="#walkercontract-structure" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Each iteration yields a <code>WalkerContract</code> object containing cumulative progress state:</p>
<pre><code class="typescript"><span class="hl-7">interface</span><span class="hl-1"> </span><span class="hl-13">WalkerContract</span><span class="hl-1"> {</span><br/><span class="hl-1">  </span><span class="hl-4">walkerName</span><span class="hl-1">: </span><span class="hl-13">string</span><span class="hl-1">;           </span><span class="hl-5">// Walker identifier</span><br/><span class="hl-1">  </span><span class="hl-4">exchangeName</span><span class="hl-1">: </span><span class="hl-13">string</span><span class="hl-1">;         </span><span class="hl-5">// Exchange context</span><br/><span class="hl-1">  </span><span class="hl-4">frameName</span><span class="hl-1">: </span><span class="hl-13">string</span><span class="hl-1">;            </span><span class="hl-5">// Frame context</span><br/><span class="hl-1">  </span><span class="hl-4">symbol</span><span class="hl-1">: </span><span class="hl-13">string</span><span class="hl-1">;               </span><span class="hl-5">// Trading symbol</span><br/><span class="hl-1">  </span><span class="hl-4">strategyName</span><span class="hl-1">: </span><span class="hl-13">string</span><span class="hl-1">;         </span><span class="hl-5">// Current strategy just completed</span><br/><span class="hl-1">  </span><span class="hl-4">stats</span><span class="hl-1">: </span><span class="hl-13">object</span><span class="hl-1">;                </span><span class="hl-5">// Full statistics for current strategy</span><br/><span class="hl-1">  </span><span class="hl-4">metricValue</span><span class="hl-1">: </span><span class="hl-13">number</span><span class="hl-1"> | </span><span class="hl-13">null</span><span class="hl-1">;   </span><span class="hl-5">// Extracted metric (null if invalid)</span><br/><span class="hl-1">  </span><span class="hl-4">metric</span><span class="hl-1">: </span><span class="hl-13">WalkerMetric</span><span class="hl-1">;         </span><span class="hl-5">// Metric name being compared</span><br/><span class="hl-1">  </span><span class="hl-4">bestMetric</span><span class="hl-1">: </span><span class="hl-13">number</span><span class="hl-1"> | </span><span class="hl-13">null</span><span class="hl-1">;    </span><span class="hl-5">// Best metric value so far</span><br/><span class="hl-1">  </span><span class="hl-4">bestStrategy</span><span class="hl-1">: </span><span class="hl-13">StrategyName</span><span class="hl-1"> | </span><span class="hl-13">null</span><span class="hl-1">; </span><span class="hl-5">// Best strategy so far</span><br/><span class="hl-1">  </span><span class="hl-4">strategiesTested</span><span class="hl-1">: </span><span class="hl-13">number</span><span class="hl-1">;     </span><span class="hl-5">// Cumulative count</span><br/><span class="hl-1">  </span><span class="hl-4">totalStrategies</span><span class="hl-1">: </span><span class="hl-13">number</span><span class="hl-1">;      </span><span class="hl-5">// Total strategies to test</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<p>The contract is yielded after each strategy completes, enabling consumers to track real-time progress:</p>
<pre><code class="typescript"><span class="hl-3">for</span><span class="hl-1"> </span><span class="hl-3">await</span><span class="hl-1"> (</span><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">progress</span><span class="hl-1"> </span><span class="hl-7">of</span><span class="hl-1"> </span><span class="hl-4">walkerLogic</span><span class="hl-1">.</span><span class="hl-0">run</span><span class="hl-1">(...)) {</span><br/><span class="hl-1">  </span><span class="hl-4">console</span><span class="hl-1">.</span><span class="hl-0">log</span><span class="hl-1">(</span><span class="hl-2">`</span><span class="hl-7">${</span><span class="hl-4">progress</span><span class="hl-9">.</span><span class="hl-4">strategiesTested</span><span class="hl-7">}</span><span class="hl-2">/</span><span class="hl-7">${</span><span class="hl-4">progress</span><span class="hl-9">.</span><span class="hl-4">totalStrategies</span><span class="hl-7">}</span><span class="hl-2">`</span><span class="hl-1">);</span><br/><span class="hl-1">  </span><span class="hl-4">console</span><span class="hl-1">.</span><span class="hl-0">log</span><span class="hl-1">(</span><span class="hl-2">`Best so far: </span><span class="hl-7">${</span><span class="hl-4">progress</span><span class="hl-9">.</span><span class="hl-4">bestStrategy</span><span class="hl-7">}</span><span class="hl-2"> = </span><span class="hl-7">${</span><span class="hl-4">progress</span><span class="hl-9">.</span><span class="hl-4">bestMetric</span><span class="hl-7">}</span><span class="hl-2">`</span><span class="hl-1">);</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<a id="progress-event-emission" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Progress Event Emission<a href="#progress-event-emission" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>The walker emits progress events through two channels:</p>
<ol>
<li><strong>progressWalkerEmitter</strong>: Emits after each strategy completes with simple progress percentage</li>
<li><strong>walkerEmitter</strong>: Emits full <code>WalkerContract</code> object with all context</li>
</ol>
<pre><code class="typescript"><span class="hl-5">// Progress event (simple)</span><br/><span class="hl-3">await</span><span class="hl-1"> </span><span class="hl-4">progressWalkerEmitter</span><span class="hl-1">.</span><span class="hl-0">next</span><span class="hl-1">({</span><br/><span class="hl-1">  </span><span class="hl-4">walkerName:</span><span class="hl-1"> </span><span class="hl-4">context</span><span class="hl-1">.</span><span class="hl-4">walkerName</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">exchangeName:</span><span class="hl-1"> </span><span class="hl-4">context</span><span class="hl-1">.</span><span class="hl-4">exchangeName</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">frameName:</span><span class="hl-1"> </span><span class="hl-4">context</span><span class="hl-1">.</span><span class="hl-4">frameName</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">symbol</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">totalStrategies:</span><span class="hl-1"> </span><span class="hl-4">strategies</span><span class="hl-1">.</span><span class="hl-4">length</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">processedStrategies:</span><span class="hl-1"> </span><span class="hl-4">strategiesTested</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">progress:</span><span class="hl-1"> </span><span class="hl-4">strategies</span><span class="hl-1">.</span><span class="hl-4">length</span><span class="hl-1"> &gt; </span><span class="hl-6">0</span><span class="hl-1"> ? </span><span class="hl-4">strategiesTested</span><span class="hl-1"> / </span><span class="hl-4">strategies</span><span class="hl-1">.</span><span class="hl-4">length</span><span class="hl-1"> : </span><span class="hl-6">0</span><span class="hl-1">,</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-5">// Walker event (rich contract)</span><br/><span class="hl-3">await</span><span class="hl-1"> </span><span class="hl-4">walkerEmitter</span><span class="hl-1">.</span><span class="hl-0">next</span><span class="hl-1">(</span><span class="hl-4">walkerContract</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>Consumers can listen to either channel:</p>
<ul>
<li>Use <code>listenWalkerProgress()</code> for simple progress bars</li>
<li>Use <code>listenWalker()</code> for detailed monitoring with metric values</li>
</ul>
<a id="final-results-emission" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Final Results Emission<a href="#final-results-emission" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>After all strategies complete, the walker emits a final summary via <code>walkerCompleteSubject</code>:</p>
<pre><code class="typescript"><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">finalResults</span><span class="hl-1"> = {</span><br/><span class="hl-1">  </span><span class="hl-4">walkerName:</span><span class="hl-1"> </span><span class="hl-4">context</span><span class="hl-1">.</span><span class="hl-4">walkerName</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">symbol</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">exchangeName:</span><span class="hl-1"> </span><span class="hl-4">context</span><span class="hl-1">.</span><span class="hl-4">exchangeName</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">frameName:</span><span class="hl-1"> </span><span class="hl-4">context</span><span class="hl-1">.</span><span class="hl-4">frameName</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">metric</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">totalStrategies:</span><span class="hl-1"> </span><span class="hl-4">strategies</span><span class="hl-1">.</span><span class="hl-4">length</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">bestStrategy</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">bestMetric</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">bestStats:</span><span class="hl-1"> </span><span class="hl-4">bestStrategy</span><span class="hl-1"> !== </span><span class="hl-7">null</span><br/><span class="hl-1">    ? </span><span class="hl-3">await</span><span class="hl-1"> </span><span class="hl-7">this</span><span class="hl-1">.</span><span class="hl-4">backtestMarkdownService</span><span class="hl-1">.</span><span class="hl-0">getData</span><span class="hl-1">(</span><span class="hl-4">symbol</span><span class="hl-1">, </span><span class="hl-4">bestStrategy</span><span class="hl-1">)</span><br/><span class="hl-1">    : </span><span class="hl-7">null</span><span class="hl-1">,</span><br/><span class="hl-1">};</span><br/><br/><span class="hl-3">await</span><span class="hl-1"> </span><span class="hl-4">walkerCompleteSubject</span><span class="hl-1">.</span><span class="hl-0">next</span><span class="hl-1">(</span><span class="hl-4">finalResults</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>This final emission includes the full statistics object for the best strategy, enabling post-processing and report generation.</p>
<a id="callback-lifecycle" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Callback Lifecycle<a href="#callback-lifecycle" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The walker schema supports four lifecycle callbacks that execute at specific points during orchestration:</p>
<a id="callback-invocation-points" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Callback Invocation Points<a href="#callback-invocation-points" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p><img src="../media/62_Walker_Execution_Flow_3.svg" alt="Mermaid Diagram"></p>
<p><strong>Diagram: Walker Callback Invocation Points</strong> - Shows the four callback types and when they execute during the walker lifecycle.</p>
<a id="callback-signatures" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Callback Signatures<a href="#callback-signatures" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><table>
<thead>
<tr>
<th>Callback</th>
<th>Signature</th>
<th>When Invoked</th>
<th>Use Case</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>onStrategyStart</code></td>
<td><code>(strategyName: string, symbol: string) =&gt; void</code></td>
<td>Before backtest starts</td>
<td>Initialize strategy-specific state, log start</td>
</tr>
<tr>
<td><code>onStrategyComplete</code></td>
<td><code>(strategyName: string, symbol: string, stats: object, metricValue: number | null) =&gt; void</code></td>
<td>After metrics extracted, before yield</td>
<td>Process results, update external state</td>
</tr>
<tr>
<td><code>onStrategyError</code></td>
<td><code>(strategyName: string, symbol: string, error: Error) =&gt; void</code></td>
<td>Backtest throws exception</td>
<td>Log errors, alert monitoring</td>
</tr>
<tr>
<td><code>onComplete</code></td>
<td><code>(finalResults: object) =&gt; void</code></td>
<td>After all strategies complete</td>
<td>Generate final report, persist best strategy</td>
</tr>
</tbody>
</table>
<p>Callbacks are optional and defined in the walker schema passed to <code>addWalker()</code>. All callbacks execute synchronously in the main execution flow.</p>
<a id="example-callback-implementation" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Example Callback Implementation<a href="#example-callback-implementation" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><pre><code class="typescript"><span class="hl-0">addWalker</span><span class="hl-1">({</span><br/><span class="hl-1">  </span><span class="hl-4">walkerName:</span><span class="hl-1"> </span><span class="hl-2">&quot;strategy-optimizer&quot;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">strategies:</span><span class="hl-1"> [</span><span class="hl-2">&quot;strat-v1&quot;</span><span class="hl-1">, </span><span class="hl-2">&quot;strat-v2&quot;</span><span class="hl-1">, </span><span class="hl-2">&quot;strat-v3&quot;</span><span class="hl-1">],</span><br/><span class="hl-1">  </span><span class="hl-4">metric:</span><span class="hl-1"> </span><span class="hl-2">&quot;sharpeRatio&quot;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">exchangeName:</span><span class="hl-1"> </span><span class="hl-2">&quot;binance&quot;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">frameName:</span><span class="hl-1"> </span><span class="hl-2">&quot;2023-backtest&quot;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">callbacks:</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-0">onStrategyStart</span><span class="hl-4">:</span><span class="hl-1"> (</span><span class="hl-4">strategyName</span><span class="hl-1">, </span><span class="hl-4">symbol</span><span class="hl-1">) </span><span class="hl-7">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">      </span><span class="hl-4">console</span><span class="hl-1">.</span><span class="hl-0">log</span><span class="hl-1">(</span><span class="hl-2">`[START] </span><span class="hl-7">${</span><span class="hl-4">strategyName</span><span class="hl-7">}</span><span class="hl-2"> on </span><span class="hl-7">${</span><span class="hl-4">symbol</span><span class="hl-7">}</span><span class="hl-2">`</span><span class="hl-1">);</span><br/><span class="hl-1">    },</span><br/><span class="hl-1">    </span><span class="hl-0">onStrategyComplete</span><span class="hl-4">:</span><span class="hl-1"> (</span><span class="hl-4">strategyName</span><span class="hl-1">, </span><span class="hl-4">symbol</span><span class="hl-1">, </span><span class="hl-4">stats</span><span class="hl-1">, </span><span class="hl-4">metricValue</span><span class="hl-1">) </span><span class="hl-7">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">      </span><span class="hl-4">console</span><span class="hl-1">.</span><span class="hl-0">log</span><span class="hl-1">(</span><span class="hl-2">`[DONE] </span><span class="hl-7">${</span><span class="hl-4">strategyName</span><span class="hl-7">}</span><span class="hl-2">: </span><span class="hl-7">${</span><span class="hl-4">metricValue</span><span class="hl-7">}</span><span class="hl-2">`</span><span class="hl-1">);</span><br/><span class="hl-1">      </span><span class="hl-5">// Store in database for historical tracking</span><br/><span class="hl-1">      </span><span class="hl-4">db</span><span class="hl-1">.</span><span class="hl-0">insertWalkerResult</span><span class="hl-1">(</span><span class="hl-4">strategyName</span><span class="hl-1">, </span><span class="hl-4">symbol</span><span class="hl-1">, </span><span class="hl-4">stats</span><span class="hl-1">);</span><br/><span class="hl-1">    },</span><br/><span class="hl-1">    </span><span class="hl-0">onStrategyError</span><span class="hl-4">:</span><span class="hl-1"> (</span><span class="hl-4">strategyName</span><span class="hl-1">, </span><span class="hl-4">symbol</span><span class="hl-1">, </span><span class="hl-4">error</span><span class="hl-1">) </span><span class="hl-7">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">      </span><span class="hl-4">console</span><span class="hl-1">.</span><span class="hl-0">error</span><span class="hl-1">(</span><span class="hl-2">`[ERROR] </span><span class="hl-7">${</span><span class="hl-4">strategyName</span><span class="hl-7">}</span><span class="hl-2">: </span><span class="hl-7">${</span><span class="hl-4">error</span><span class="hl-9">.</span><span class="hl-4">message</span><span class="hl-7">}</span><span class="hl-2">`</span><span class="hl-1">);</span><br/><span class="hl-1">      </span><span class="hl-4">alerting</span><span class="hl-1">.</span><span class="hl-0">sendSlackMessage</span><span class="hl-1">(</span><span class="hl-2">`Strategy </span><span class="hl-7">${</span><span class="hl-4">strategyName</span><span class="hl-7">}</span><span class="hl-2"> failed`</span><span class="hl-1">);</span><br/><span class="hl-1">    },</span><br/><span class="hl-1">    </span><span class="hl-0">onComplete</span><span class="hl-4">:</span><span class="hl-1"> (</span><span class="hl-4">finalResults</span><span class="hl-1">) </span><span class="hl-7">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">      </span><span class="hl-4">console</span><span class="hl-1">.</span><span class="hl-0">log</span><span class="hl-1">(</span><span class="hl-2">`Winner: </span><span class="hl-7">${</span><span class="hl-4">finalResults</span><span class="hl-9">.</span><span class="hl-4">bestStrategy</span><span class="hl-7">}</span><span class="hl-2"> = </span><span class="hl-7">${</span><span class="hl-4">finalResults</span><span class="hl-9">.</span><span class="hl-4">bestMetric</span><span class="hl-7">}</span><span class="hl-2">`</span><span class="hl-1">);</span><br/><span class="hl-1">      </span><span class="hl-5">// Deploy best strategy to production</span><br/><span class="hl-1">      </span><span class="hl-4">deployment</span><span class="hl-1">.</span><span class="hl-0">deploy</span><span class="hl-1">(</span><span class="hl-4">finalResults</span><span class="hl-1">.</span><span class="hl-4">bestStrategy</span><span class="hl-1">);</span><br/><span class="hl-1">    }</span><br/><span class="hl-1">  }</span><br/><span class="hl-1">});</span>
</code><button type="button">Copy</button></pre>

<a id="cancellation-mechanism" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Cancellation Mechanism<a href="#cancellation-mechanism" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The walker supports mid-execution cancellation via the <code>walkerStopSubject</code> event stream. This enables external systems to terminate long-running walker processes without waiting for all strategies to complete.</p>
<a id="cancellation-implementation" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Cancellation Implementation<a href="#cancellation-implementation" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>The walker sets up a cancellation listener before the strategy loop begins:</p>
<pre><code class="typescript"><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">CANCEL_SYMBOL</span><span class="hl-1"> = </span><span class="hl-0">Symbol</span><span class="hl-1">(</span><span class="hl-2">&quot;CANCEL_SYMBOL&quot;</span><span class="hl-1">);</span><br/><br/><span class="hl-7">let</span><span class="hl-1"> </span><span class="hl-4">pendingStrategy</span><span class="hl-1">: </span><span class="hl-13">string</span><span class="hl-1">;</span><br/><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">listenStop</span><span class="hl-1"> = </span><span class="hl-4">walkerStopSubject</span><br/><span class="hl-1">  .</span><span class="hl-0">filter</span><span class="hl-1">((</span><span class="hl-4">data</span><span class="hl-1">) </span><span class="hl-7">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-7">let</span><span class="hl-1"> </span><span class="hl-4">isOk</span><span class="hl-1"> = </span><span class="hl-7">true</span><span class="hl-1">;</span><br/><span class="hl-1">    </span><span class="hl-4">isOk</span><span class="hl-1"> = </span><span class="hl-4">isOk</span><span class="hl-1"> &amp;&amp; </span><span class="hl-4">data</span><span class="hl-1">.</span><span class="hl-4">symbol</span><span class="hl-1"> === </span><span class="hl-4">symbol</span><span class="hl-1">;</span><br/><span class="hl-1">    </span><span class="hl-4">isOk</span><span class="hl-1"> = </span><span class="hl-4">isOk</span><span class="hl-1"> &amp;&amp; </span><span class="hl-4">data</span><span class="hl-1">.</span><span class="hl-4">strategyName</span><span class="hl-1"> === </span><span class="hl-4">pendingStrategy</span><span class="hl-1">;</span><br/><span class="hl-1">    </span><span class="hl-3">return</span><span class="hl-1"> </span><span class="hl-4">isOk</span><span class="hl-1">;</span><br/><span class="hl-1">  })</span><br/><span class="hl-1">  .</span><span class="hl-0">map</span><span class="hl-1">(() </span><span class="hl-7">=&gt;</span><span class="hl-1"> </span><span class="hl-8">CANCEL_SYMBOL</span><span class="hl-1">)</span><br/><span class="hl-1">  .</span><span class="hl-0">toPromise</span><span class="hl-1">();</span>
</code><button type="button">Copy</button></pre>

<p>The listener filters stop events by matching <code>symbol</code> and <code>strategyName</code>, ensuring that only relevant stop signals trigger cancellation. The <code>CANCEL_SYMBOL</code> sentinel value distinguishes cancellation from normal backtest completion.</p>
<a id="race-condition-handling" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Race Condition Handling<a href="#race-condition-handling" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Each strategy execution races between normal completion and cancellation:</p>
<pre><code class="typescript"><span class="hl-3">for</span><span class="hl-1"> (</span><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">strategyName</span><span class="hl-1"> </span><span class="hl-7">of</span><span class="hl-1"> </span><span class="hl-4">strategies</span><span class="hl-1">) {</span><br/><span class="hl-1">  </span><span class="hl-4">pendingStrategy</span><span class="hl-1"> = </span><span class="hl-4">strategyName</span><span class="hl-1">; </span><span class="hl-5">// Update filter context</span><br/><span class="hl-1">  </span><br/><span class="hl-1">  </span><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">iterator</span><span class="hl-1"> = </span><span class="hl-7">this</span><span class="hl-1">.</span><span class="hl-4">backtestLogicPublicService</span><span class="hl-1">.</span><span class="hl-0">run</span><span class="hl-1">(</span><span class="hl-4">symbol</span><span class="hl-1">, {...});</span><br/><span class="hl-1">  </span><br/><span class="hl-1">  </span><span class="hl-7">let</span><span class="hl-1"> </span><span class="hl-4">result</span><span class="hl-1"> = </span><span class="hl-3">await</span><span class="hl-1"> </span><span class="hl-13">Promise</span><span class="hl-1">.</span><span class="hl-0">race</span><span class="hl-1">([</span><br/><span class="hl-1">    </span><span class="hl-3">await</span><span class="hl-1"> </span><span class="hl-0">resolveDocuments</span><span class="hl-1">(</span><span class="hl-4">iterator</span><span class="hl-1">), </span><span class="hl-5">// Normal completion</span><br/><span class="hl-1">    </span><span class="hl-4">listenStop</span><span class="hl-1">,                        </span><span class="hl-5">// Cancellation signal</span><br/><span class="hl-1">  ]);</span><br/><span class="hl-1">  </span><br/><span class="hl-1">  </span><span class="hl-3">if</span><span class="hl-1"> (</span><span class="hl-4">result</span><span class="hl-1"> === </span><span class="hl-8">CANCEL_SYMBOL</span><span class="hl-1">) {</span><br/><span class="hl-1">    </span><span class="hl-7">this</span><span class="hl-1">.</span><span class="hl-4">loggerService</span><span class="hl-1">.</span><span class="hl-0">info</span><span class="hl-1">(</span><span class="hl-2">&quot;walkerLogicPrivateService received stop signal, cancelling walker&quot;</span><span class="hl-1">, {...});</span><br/><span class="hl-1">    </span><span class="hl-3">break</span><span class="hl-1">; </span><span class="hl-5">// Exit strategy loop</span><br/><span class="hl-1">  }</span><br/><span class="hl-1">  </span><br/><span class="hl-1">  </span><span class="hl-5">// Continue with metric extraction...</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<p>The race pattern ensures immediate response to cancellation without waiting for the current backtest to complete. The strategy loop breaks immediately upon receiving <code>CANCEL_SYMBOL</code>, skipping remaining strategies.</p>
<a id="triggering-cancellation" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Triggering Cancellation<a href="#triggering-cancellation" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>External code can trigger cancellation by emitting to <code>walkerStopSubject</code>:</p>
<pre><code class="typescript"><span class="hl-3">import</span><span class="hl-1"> { </span><span class="hl-4">walkerStopSubject</span><span class="hl-1"> } </span><span class="hl-3">from</span><span class="hl-1"> </span><span class="hl-2">&quot;./config/emitters&quot;</span><span class="hl-1">;</span><br/><br/><span class="hl-5">// Cancel specific walker execution</span><br/><span class="hl-4">walkerStopSubject</span><span class="hl-1">.</span><span class="hl-0">next</span><span class="hl-1">({</span><br/><span class="hl-1">  </span><span class="hl-4">symbol:</span><span class="hl-1"> </span><span class="hl-2">&quot;BTCUSDT&quot;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">strategyName:</span><span class="hl-1"> </span><span class="hl-2">&quot;current-strategy-name&quot;</span><span class="hl-1">, </span><span class="hl-5">// Must match pendingStrategy</span><br/><span class="hl-1">});</span>
</code><button type="button">Copy</button></pre>

<p>The cancellation is non-destructive: already-completed strategies retain their results, and the walker emits a final <code>walkerCompleteSubject</code> event with partial results. However, <code>onComplete</code> callback still executes, receiving results from only the strategies that completed before cancellation.</p>
<a id="asyncgenerator-streaming-pattern" class="tsd-anchor"></a><h2 class="tsd-anchor-link">AsyncGenerator Streaming Pattern<a href="#asyncgenerator-streaming-pattern" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The walker uses an <code>AsyncGenerator</code> return type to enable streaming consumption of results without accumulating all data in memory. This pattern supports early termination and real-time progress monitoring.</p>
<a id="generator-signature" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Generator Signature<a href="#generator-signature" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><pre><code class="typescript"><span class="hl-4">public</span><span class="hl-1"> </span><span class="hl-4">async</span><span class="hl-1"> *</span><span class="hl-0">run</span><span class="hl-1">(</span><br/><span class="hl-1">  </span><span class="hl-4">symbol</span><span class="hl-1">: </span><span class="hl-4">string</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">strategies</span><span class="hl-1">: </span><span class="hl-4">StrategyName</span><span class="hl-1">[],</span><br/><span class="hl-1">  </span><span class="hl-4">metric</span><span class="hl-1">: </span><span class="hl-4">WalkerMetric</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-4">context</span><span class="hl-1">: {</span><br/><span class="hl-1">    </span><span class="hl-4">exchangeName:</span><span class="hl-1"> </span><span class="hl-4">string</span><span class="hl-1">;</span><br/><span class="hl-1">    </span><span class="hl-4">frameName</span><span class="hl-1">: </span><span class="hl-4">string</span><span class="hl-1">;</span><br/><span class="hl-1">    </span><span class="hl-4">walkerName</span><span class="hl-1">: </span><span class="hl-4">string</span><span class="hl-1">;</span><br/><span class="hl-1">  }</span><br/><span class="hl-1">): </span><span class="hl-4">AsyncGenerator</span><span class="hl-1">&lt;</span><span class="hl-4">WalkerContract</span><span class="hl-1">&gt;</span>
</code><button type="button">Copy</button></pre>

<p>The generator yields after each strategy completes, producing an unbounded stream for potentially large strategy sets.</p>
<a id="consumption-patterns" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Consumption Patterns<a href="#consumption-patterns" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p><strong>Pattern 1: Complete consumption with resolveDocuments()</strong></p>
<pre><code class="typescript"><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">results</span><span class="hl-1"> = </span><span class="hl-3">await</span><span class="hl-1"> </span><span class="hl-0">resolveDocuments</span><span class="hl-1">(</span><span class="hl-4">walkerLogic</span><span class="hl-1">.</span><span class="hl-0">run</span><span class="hl-1">(</span><span class="hl-4">symbol</span><span class="hl-1">, </span><span class="hl-4">strategies</span><span class="hl-1">, </span><span class="hl-4">metric</span><span class="hl-1">, </span><span class="hl-4">context</span><span class="hl-1">));</span><br/><span class="hl-5">// results: WalkerContract[] - all strategies completed</span>
</code><button type="button">Copy</button></pre>

<p>This pattern buffers all results in memory and waits for the walker to complete.</p>
<p><strong>Pattern 2: Streaming consumption with for-await-of</strong></p>
<pre><code class="typescript"><span class="hl-3">for</span><span class="hl-1"> </span><span class="hl-3">await</span><span class="hl-1"> (</span><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">contract</span><span class="hl-1"> </span><span class="hl-7">of</span><span class="hl-1"> </span><span class="hl-4">walkerLogic</span><span class="hl-1">.</span><span class="hl-0">run</span><span class="hl-1">(</span><span class="hl-4">symbol</span><span class="hl-1">, </span><span class="hl-4">strategies</span><span class="hl-1">, </span><span class="hl-4">metric</span><span class="hl-1">, </span><span class="hl-4">context</span><span class="hl-1">)) {</span><br/><span class="hl-1">  </span><span class="hl-4">console</span><span class="hl-1">.</span><span class="hl-0">log</span><span class="hl-1">(</span><span class="hl-2">`Progress: </span><span class="hl-7">${</span><span class="hl-4">contract</span><span class="hl-9">.</span><span class="hl-4">strategiesTested</span><span class="hl-7">}</span><span class="hl-2">/</span><span class="hl-7">${</span><span class="hl-4">contract</span><span class="hl-9">.</span><span class="hl-4">totalStrategies</span><span class="hl-7">}</span><span class="hl-2">`</span><span class="hl-1">);</span><br/><span class="hl-1">  </span><span class="hl-4">console</span><span class="hl-1">.</span><span class="hl-0">log</span><span class="hl-1">(</span><span class="hl-2">`Current: </span><span class="hl-7">${</span><span class="hl-4">contract</span><span class="hl-9">.</span><span class="hl-4">strategyName</span><span class="hl-7">}</span><span class="hl-2"> = </span><span class="hl-7">${</span><span class="hl-4">contract</span><span class="hl-9">.</span><span class="hl-4">metricValue</span><span class="hl-7">}</span><span class="hl-2">`</span><span class="hl-1">);</span><br/><span class="hl-1">  </span><span class="hl-4">console</span><span class="hl-1">.</span><span class="hl-0">log</span><span class="hl-1">(</span><span class="hl-2">`Best: </span><span class="hl-7">${</span><span class="hl-4">contract</span><span class="hl-9">.</span><span class="hl-4">bestStrategy</span><span class="hl-7">}</span><span class="hl-2"> = </span><span class="hl-7">${</span><span class="hl-4">contract</span><span class="hl-9">.</span><span class="hl-4">bestMetric</span><span class="hl-7">}</span><span class="hl-2">`</span><span class="hl-1">);</span><br/><span class="hl-1">  </span><br/><span class="hl-1">  </span><span class="hl-5">// Early termination possible</span><br/><span class="hl-1">  </span><span class="hl-3">if</span><span class="hl-1"> (</span><span class="hl-4">contract</span><span class="hl-1">.</span><span class="hl-4">bestMetric</span><span class="hl-1"> &gt; </span><span class="hl-6">2.0</span><span class="hl-1">) {</span><br/><span class="hl-1">    </span><span class="hl-4">console</span><span class="hl-1">.</span><span class="hl-0">log</span><span class="hl-1">(</span><span class="hl-2">&quot;Found excellent strategy, stopping search&quot;</span><span class="hl-1">);</span><br/><span class="hl-1">    </span><span class="hl-3">break</span><span class="hl-1">;</span><br/><span class="hl-1">  }</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<p>This pattern processes results one at a time without accumulation, enabling memory-efficient monitoring.</p>
<p><strong>Pattern 3: Callback-based consumption via events</strong></p>
<pre><code class="typescript"><span class="hl-0">listenWalker</span><span class="hl-1">((</span><span class="hl-4">contract</span><span class="hl-1">) </span><span class="hl-7">=&gt;</span><span class="hl-1"> {</span><br/><span class="hl-1">  </span><span class="hl-0">updateDashboard</span><span class="hl-1">(</span><span class="hl-4">contract</span><span class="hl-1">);</span><br/><span class="hl-1">});</span><br/><br/><span class="hl-5">// Walker runs in background, callbacks fire as progress occurs</span><br/><span class="hl-4">Walker</span><span class="hl-1">.</span><span class="hl-0">background</span><span class="hl-1">(</span><span class="hl-4">symbol</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>This pattern decouples walker execution from result consumption via the event bus.</p>
<a id="memory-efficiency" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Memory Efficiency<a href="#memory-efficiency" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>The generator pattern provides constant memory overhead regardless of strategy count, as only one <code>WalkerContract</code> exists in memory at a time during streaming consumption. The backtest results from previous strategies are released as soon as their metrics are extracted, preventing accumulation of large signal datasets. The walker itself maintains only scalar tracking state (<code>bestMetric</code>, <code>bestStrategy</code>, <code>strategiesTested</code>).</p>
<p>For walker executions testing hundreds of strategies over years of data, this streaming architecture prevents out-of-memory errors that would occur with array accumulation patterns.</p>
</div></div><div class="col-sidebar"><div class="page-menu"><div class="tsd-navigation settings"><details class="tsd-accordion"><summary class="tsd-accordion-summary"><h3><svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-chevronDown"></use></svg>Settings</h3></summary><div class="tsd-accordion-details"><div class="tsd-filter-visibility"><span class="settings-label">Member Visibility</span><ul id="tsd-filter-options"><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-protected" name="protected"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Protected</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-inherited" name="inherited" checked/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Inherited</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-external" name="external"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>External</span></label></li></ul></div><div class="tsd-theme-toggle"><label class="settings-label" for="tsd-theme">Theme</label><select id="tsd-theme"><option value="os">OS</option><option value="light">Light</option><option value="dark">Dark</option></select></div></div></details></div><details open class="tsd-accordion tsd-page-navigation"><summary class="tsd-accordion-summary"><h3><svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-chevronDown"></use></svg>On This Page</h3></summary><div class="tsd-accordion-details"><a href="#walker-execution-flow"><span>Walker <wbr/>Execution <wbr/>Flow</span></a><ul><li><a href="#purpose-and-scope"><span>Purpose and <wbr/>Scope</span></a></li><li><a href="#overview"><span>Overview</span></a></li><li><a href="#execution-architecture"><span>Execution <wbr/>Architecture</span></a></li><li><a href="#sequential-strategy-iteration"><span>Sequential <wbr/>Strategy <wbr/>Iteration</span></a></li><li><ul><li><a href="#main-iteration-loop"><span>Main <wbr/>Iteration <wbr/>Loop</span></a></li><li><a href="#state-machine-for-single-strategy-execution"><span>State <wbr/>Machine for <wbr/>Single <wbr/>Strategy <wbr/>Execution</span></a></li></ul></li><li><a href="#backtest-orchestration"><span>Backtest <wbr/>Orchestration</span></a></li><li><ul><li><a href="#backtest-execution-context"><span>Backtest <wbr/>Execution <wbr/>Context</span></a></li><li><a href="#integration-with-backtestlogicpublicservice"><span>Integration with <wbr/>Backtest<wbr/>Logic<wbr/>Public<wbr/>Service</span></a></li><li><a href="#error-handling-during-backtest"><span>Error <wbr/>Handling <wbr/>During <wbr/>Backtest</span></a></li></ul></li><li><a href="#metric-extraction-and-comparison"><span>Metric <wbr/>Extraction and <wbr/>Comparison</span></a></li><li><ul><li><a href="#metric-validation-pipeline"><span>Metric <wbr/>Validation <wbr/>Pipeline</span></a></li><li><a href="#best-strategy-update-logic"><span>Best <wbr/>Strategy <wbr/>Update <wbr/>Logic</span></a></li></ul></li><li><a href="#progress-tracking-and-emission"><span>Progress <wbr/>Tracking and <wbr/>Emission</span></a></li><li><ul><li><a href="#walkercontract-structure"><span>Walker<wbr/>Contract <wbr/>Structure</span></a></li><li><a href="#progress-event-emission"><span>Progress <wbr/>Event <wbr/>Emission</span></a></li><li><a href="#final-results-emission"><span>Final <wbr/>Results <wbr/>Emission</span></a></li></ul></li><li><a href="#callback-lifecycle"><span>Callback <wbr/>Lifecycle</span></a></li><li><ul><li><a href="#callback-invocation-points"><span>Callback <wbr/>Invocation <wbr/>Points</span></a></li><li><a href="#callback-signatures"><span>Callback <wbr/>Signatures</span></a></li><li><a href="#example-callback-implementation"><span>Example <wbr/>Callback <wbr/>Implementation</span></a></li></ul></li><li><a href="#cancellation-mechanism"><span>Cancellation <wbr/>Mechanism</span></a></li><li><ul><li><a href="#cancellation-implementation"><span>Cancellation <wbr/>Implementation</span></a></li><li><a href="#race-condition-handling"><span>Race <wbr/>Condition <wbr/>Handling</span></a></li><li><a href="#triggering-cancellation"><span>Triggering <wbr/>Cancellation</span></a></li></ul></li><li><a href="#asyncgenerator-streaming-pattern"><span>Async<wbr/>Generator <wbr/>Streaming <wbr/>Pattern</span></a></li><li><ul><li><a href="#generator-signature"><span>Generator <wbr/>Signature</span></a></li><li><a href="#consumption-patterns"><span>Consumption <wbr/>Patterns</span></a></li><li><a href="#memory-efficiency"><span>Memory <wbr/>Efficiency</span></a></li></ul></li></ul></div></details></div><div class="site-menu"><nav class="tsd-navigation"><a href="../modules.html">backtest-kit</a><ul class="tsd-small-nested-navigation" id="tsd-nav-container"><li>Loading...</li></ul></nav></div></div></div><footer><p class="tsd-generator">Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p></footer><div class="overlay"></div></body></html>

<!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function(m,e,t,r,i,k,a){
        m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();
        for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
        k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)
    })(window, document,'script','https://mc.yandex.ru/metrika/tag.js?id=105455585', 'ym');

    ym(105455585, 'init', {ssr:true, webvisor:true, clickmap:true, ecommerce:"dataLayer", accurateTrackBounce:true, trackLinks:true});
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/105455585" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3MQZEBBDDR"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-3MQZEBBDDR');
</script>
