<!DOCTYPE html><html class="default" lang="en" data-base=".."><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="IE=edge"/><title>design/06_execution_modes | backtest-kit</title><meta name="description" content="Documentation for backtest-kit"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="../assets/style.css"/><link rel="stylesheet" href="../assets/highlight.css"/><script defer src="../assets/main.js"></script><script async src="../assets/icons.js" id="tsd-icons-script"></script><script async src="../assets/search.js" id="tsd-search-script"></script><script async src="../assets/navigation.js" id="tsd-nav-script"></script><script async src="../assets/hierarchy.js" id="tsd-hierarchy-script"></script></head><body><script>document.documentElement.dataset.theme = localStorage.getItem("tsd-theme") || "os";document.body.style.display="none";setTimeout(() => app?app.showPage():document.body.style.removeProperty("display"),500)</script><header class="tsd-page-toolbar"><div class="tsd-toolbar-contents container"><div class="table-cell" id="tsd-search"><div class="field"><label for="tsd-search-field" class="tsd-widget tsd-toolbar-icon search no-caption"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-search"></use></svg></label><input type="text" id="tsd-search-field" aria-label="Search"/></div><div class="field"><div id="tsd-toolbar-links"></div></div><ul class="results"><li class="state loading">Preparing search index...</li><li class="state failure">The search index is not available</li></ul><a href="../index.html" class="title">backtest-kit</a></div><div class="table-cell" id="tsd-widgets"><a href="#" class="tsd-widget tsd-toolbar-icon menu no-caption" data-toggle="menu" aria-label="Menu"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-menu"></use></svg></a></div></div></header><div class="container container-main"><div class="col-content"><div class="tsd-page-title"><ul class="tsd-breadcrumb"><li><a href="../modules.html">backtest-kit</a></li><li><a href="design_06_execution_modes.html">design/06_execution_modes</a></li></ul></div><div class="tsd-panel tsd-typography"><a id="execution-modes" class="tsd-anchor"></a><h1 class="tsd-anchor-link">Execution Modes<a href="#execution-modes" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h1><a id="purpose-and-scope" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Purpose and Scope<a href="#purpose-and-scope" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This document describes the three execution modes available in backtest-kit: <strong>Backtest</strong> (historical simulation), <strong>Live</strong> (real-time trading), and <strong>Walker</strong> (strategy comparison). Each mode implements a distinct temporal progression model and completion semantic while sharing the same core strategy execution framework.</p>
<p>For information about strategy lifecycle within these modes, see <a href="design_07_signal_lifecycle_overview.html">Signal Lifecycle Overview</a>. For component registration patterns used across all modes, see <a href="design_08_component_registration.html">Component Registration</a>. For detailed API documentation of each mode's methods, see sections <a href="design_17_backtest_api.html">4.3</a>, <a href="design_18_live_trading_api.html">4.4</a>, and <a href="design_19_walker_api.html">4.5</a>.</p>
<hr>
<a id="mode-overview" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Mode Overview<a href="#mode-overview" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The framework provides three orthogonal execution modes that differ in temporal progression, completion semantics, and result aggregation patterns:</p>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Backtest Mode</th>
<th>Live Mode</th>
<th>Walker Mode</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Purpose</strong></td>
<td>Historical simulation</td>
<td>Real-time trading</td>
<td>Strategy comparison</td>
</tr>
<tr>
<td><strong>Temporal Model</strong></td>
<td>Sequential timeframe iteration</td>
<td>Real-time Date.now()</td>
<td>Multiple sequential backtests</td>
</tr>
<tr>
<td><strong>Completion</strong></td>
<td>Finite (when timeframes exhausted)</td>
<td>Infinite (never completes)</td>
<td>Finite (when all strategies tested)</td>
</tr>
<tr>
<td><strong>Primary Service</strong></td>
<td><code>BacktestLogicPrivateService</code></td>
<td><code>LiveLogicPrivateService</code></td>
<td><code>WalkerLogicPrivateService</code></td>
</tr>
<tr>
<td><strong>Result Type</strong></td>
<td><code>IStrategyBacktestResult</code></td>
<td><code>IStrategyTickResultOpened | IStrategyTickResultClosed</code></td>
<td><code>WalkerContract</code></td>
</tr>
<tr>
<td><strong>Data Source</strong></td>
<td>Historical via <code>getNextCandles()</code></td>
<td>Current via <code>getCandles()</code></td>
<td>Historical via backtest delegation</td>
</tr>
<tr>
<td><strong>Crash Recovery</strong></td>
<td>Not applicable</td>
<td>Yes (via persistence layer)</td>
<td>Not applicable</td>
</tr>
<tr>
<td><strong>Progress Tracking</strong></td>
<td><code>progressBacktestEmitter</code></td>
<td>Not applicable</td>
<td><code>progressWalkerEmitter</code></td>
</tr>
</tbody>
</table>
<hr>
<a id="mode-selection-and-entry-points" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Mode Selection and Entry Points<a href="#mode-selection-and-entry-points" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p><img src="../media/06_Execution_Modes_0.svg" alt="Mermaid Diagram"></p>
<p><strong>Service Layering Pattern</strong></p>
<p>Each mode implements a four-tier architecture separating user-facing utilities, command validation, public contracts, and private implementation:</p>
<ol>
<li><strong>Utils Layer</strong>: User-facing singleton exports (<code>Backtest</code>, <code>Live</code>, <code>Walker</code>) providing simplified method access with logging</li>
<li><strong>Command Layer</strong>: Validation services ensuring schema registration and parameter correctness before execution</li>
<li><strong>Public Layer</strong>: Context setup and AsyncGenerator type contracts for external consumption</li>
<li><strong>Private Layer</strong>: Core execution logic implementing temporal progression and result streaming</li>
</ol>
<hr>
<a id="backtest-mode" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Backtest Mode<a href="#backtest-mode" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><a id="characteristics" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Characteristics<a href="#characteristics" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Backtest mode performs historical simulation by iterating through predefined timeframes and evaluating strategy signals against past market data. The execution model implements an optimized skip-ahead pattern where timeframes are bypassed during active signal periods to minimize redundant tick() calls.</p>
<p><strong>Temporal Progression:</strong></p>
<ul>
<li>Iterates through <code>Date[]</code> array generated by <code>FrameGlobalService</code></li>
<li>Each timeframe represents a specific historical moment</li>
<li>Progression is deterministic and repeatable</li>
<li>No real-time constraints or timing dependencies</li>
</ul>
<p><strong>Completion Semantics:</strong></p>
<ul>
<li>Finite execution: completes when all timeframes are processed</li>
<li>AsyncGenerator yields each closed signal result</li>
<li>Consumer can terminate early via <code>break</code> in for-await loop</li>
</ul>
<p><strong>Data Requirements:</strong></p>
<ul>
<li>Historical candles fetched via <code>ClientExchange.getNextCandles()</code></li>
<li>Requires future data relative to signal open time</li>
<li>Candle availability validated before backtest proceeds</li>
</ul>
<a id="execution-flow" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Execution Flow<a href="#execution-flow" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p><img src="../media/06_Execution_Modes_1.svg" alt="Mermaid Diagram"></p>
<p><strong>Skip-Ahead Optimization</strong></p>
<p>When a signal opens, the execution loop skips all timeframes until the signal closes. This optimization eliminates redundant tick() calls during the signal's active period since the strategy's state is deterministic once a position is opened.</p>
<pre><code class="typescript"><span class="hl-5">// Skip timeframes until closeTimestamp</span><br/><span class="hl-3">while</span><span class="hl-1"> (</span><br/><span class="hl-1">  </span><span class="hl-4">i</span><span class="hl-1"> &lt; </span><span class="hl-4">timeframes</span><span class="hl-1">.</span><span class="hl-4">length</span><span class="hl-1"> &amp;&amp;</span><br/><span class="hl-1">  </span><span class="hl-4">timeframes</span><span class="hl-1">[</span><span class="hl-4">i</span><span class="hl-1">].</span><span class="hl-0">getTime</span><span class="hl-1">() &lt; </span><span class="hl-4">backtestResult</span><span class="hl-1">.</span><span class="hl-4">closeTimestamp</span><br/><span class="hl-1">) {</span><br/><span class="hl-1">  </span><span class="hl-4">i</span><span class="hl-1">++;</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<a id="key-service-classes" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Key Service Classes<a href="#key-service-classes" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><table>
<thead>
<tr>
<th>Class</th>
<th>Responsibility</th>
<th>Key Methods</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>BacktestLogicPrivateService</code></td>
<td>Core execution loop with timeframe iteration</td>
<td><code>run(symbol): AsyncGenerator&lt;IStrategyBacktestResult&gt;</code></td>
</tr>
<tr>
<td><code>BacktestLogicPublicService</code></td>
<td>Context setup and validation</td>
<td><code>run(symbol, context)</code></td>
</tr>
<tr>
<td><code>BacktestCommandService</code></td>
<td>Schema validation and delegation</td>
<td><code>run(symbol, context)</code></td>
</tr>
<tr>
<td><code>FrameGlobalService</code></td>
<td>Timeframe generation from frame schema</td>
<td><code>getTimeframe(symbol, frameName): Promise&lt;Date[]&gt;</code></td>
</tr>
<tr>
<td><code>StrategyGlobalService</code></td>
<td>Strategy method invocation with context injection</td>
<td><code>tick()</code>, <code>backtest()</code></td>
</tr>
<tr>
<td><code>ExchangeGlobalService</code></td>
<td>Data fetching with execution context</td>
<td><code>getNextCandles()</code></td>
</tr>
</tbody>
</table>
<hr>
<a id="live-mode" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Live Mode<a href="#live-mode" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><a id="characteristics-1" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Characteristics<a href="#characteristics-1" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Live mode performs real-time trading by continuously polling the strategy with current timestamps in an infinite loop. The execution model implements crash recovery through persistent storage, allowing processes to restart and resume active positions without data loss.</p>
<p><strong>Temporal Progression:</strong></p>
<ul>
<li>Infinite <code>while(true)</code> loop creating new <code>Date()</code> each iteration</li>
<li>Each tick represents the current real-time moment</li>
<li>Progression is non-deterministic and time-dependent</li>
<li>Sleep interval (<code>TICK_TTL = 61 seconds</code>) controls polling frequency</li>
</ul>
<p><strong>Completion Semantics:</strong></p>
<ul>
<li>Infinite execution: never completes naturally</li>
<li>AsyncGenerator continues yielding results indefinitely</li>
<li>Process termination via external signal (SIGTERM, SIGINT) or error</li>
</ul>
<p><strong>Crash Recovery:</strong></p>
<ul>
<li>State persisted via <code>PersistSignalAdapter</code>, <code>PersistScheduleAdapter</code>, <code>PersistRiskAdapter</code></li>
<li>Strategy initialization calls <code>waitForInit()</code> to restore state</li>
<li>Active positions and scheduled signals recovered from disk on restart</li>
</ul>
<a id="execution-flow-1" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Execution Flow<a href="#execution-flow-1" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p><img src="../media/06_Execution_Modes_2.svg" alt="Mermaid Diagram"></p>
<p><strong>Tick Throttling and Sleep Pattern</strong></p>
<p>The <code>TICK_TTL</code> constant (61 seconds) controls the polling interval between strategy evaluations. This value exceeds one minute to ensure each tick represents a new 1-minute candle boundary when fetching data.</p>
<pre><code class="typescript"><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-7">TICK_TTL</span><span class="hl-1"> = </span><span class="hl-8">1</span><span class="hl-1"> * </span><span class="hl-8">60</span><span class="hl-1"> * </span><span class="hl-8">1_000</span><span class="hl-1"> + </span><span class="hl-8">1</span><span class="hl-1">; </span><span class="hl-5">// 61 seconds</span>
</code><button type="button">Copy</button></pre>

<a id="crash-recovery-architecture" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Crash Recovery Architecture<a href="#crash-recovery-architecture" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p><img src="../media/06_Execution_Modes_3.svg" alt="Mermaid Diagram"></p>
<p><strong>State Restoration Process</strong></p>
<ol>
<li>On process start, <code>ClientStrategy</code> checks for persisted state via <code>PersistSignalAdapter.hasValue()</code></li>
<li>If state exists, <code>readValue()</code> loads the serialized signal object</li>
<li>Strategy reconstructs internal state including signal, scheduled signals, and risk positions</li>
<li>Execution resumes from the restored state as if no crash occurred</li>
</ol>
<a id="key-service-classes-1" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Key Service Classes<a href="#key-service-classes-1" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><table>
<thead>
<tr>
<th>Class</th>
<th>Responsibility</th>
<th>Key Methods</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>LiveLogicPrivateService</code></td>
<td>Core execution loop with infinite polling</td>
<td><code>run(symbol): AsyncGenerator&lt;IStrategyTickResultOpened | IStrategyTickResultClosed&gt;</code></td>
</tr>
<tr>
<td><code>LiveLogicPublicService</code></td>
<td>Context setup and validation</td>
<td><code>run(symbol, context)</code></td>
</tr>
<tr>
<td><code>LiveCommandService</code></td>
<td>Schema validation and delegation</td>
<td><code>run(symbol, context)</code></td>
</tr>
<tr>
<td><code>StrategyGlobalService</code></td>
<td>Strategy method invocation with context injection</td>
<td><code>tick()</code></td>
</tr>
<tr>
<td><code>PersistSignalAdapter</code></td>
<td>Signal state persistence</td>
<td><code>readValue()</code>, <code>writeValue()</code>, <code>hasValue()</code>, <code>removeValue()</code></td>
</tr>
</tbody>
</table>
<hr>
<a id="walker-mode" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Walker Mode<a href="#walker-mode" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><a id="characteristics-2" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Characteristics<a href="#characteristics-2" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Walker mode performs strategy comparison by executing multiple backtests sequentially and ranking results by a configurable performance metric. The execution model implements real-time progress tracking, allowing consumers to monitor strategy evaluation as it progresses.</p>
<p><strong>Temporal Progression:</strong></p>
<ul>
<li>Sequential iteration through strategy array</li>
<li>Each iteration runs a complete backtest via <code>BacktestLogicPublicService</code></li>
<li>Progression depends on backtest execution time per strategy</li>
<li>No parallel execution (strategies tested serially)</li>
</ul>
<p><strong>Completion Semantics:</strong></p>
<ul>
<li>Finite execution: completes when all strategies tested</li>
<li>AsyncGenerator yields <code>WalkerContract</code> after each strategy</li>
<li>Final result includes best strategy and comparative statistics</li>
</ul>
<p><strong>Metric Selection:</strong></p>
<ul>
<li>Default: <code>sharpeRatio</code></li>
<li>Alternatives: <code>winRate</code>, <code>avgPnl</code>, <code>totalPnl</code>, <code>certaintyRatio</code>, <code>annualizedSharpe</code></li>
<li>Higher values considered better for all metrics</li>
</ul>
<a id="execution-flow-2" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Execution Flow<a href="#execution-flow-2" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><p><img src="../media/06_Execution_Modes_4.svg" alt="Mermaid Diagram"></p>
<p><strong>Metric Extraction and Comparison</strong></p>
<p>Walker extracts the specified metric from <code>BacktestMarkdownService.getData()</code> results, which provides comprehensive statistics including Sharpe ratio, win rate, PNL, and other performance measures. The comparison logic treats higher values as better for all metrics.</p>
<pre><code class="typescript"><span class="hl-5">// Extract metric value</span><br/><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-7">value</span><span class="hl-1"> = </span><span class="hl-4">stats</span><span class="hl-1">[</span><span class="hl-4">metric</span><span class="hl-1">];</span><br/><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-7">metricValue</span><span class="hl-1"> =</span><br/><span class="hl-1">  </span><span class="hl-4">value</span><span class="hl-1"> !== </span><span class="hl-6">null</span><span class="hl-1"> &amp;&amp;</span><br/><span class="hl-1">  </span><span class="hl-4">value</span><span class="hl-1"> !== </span><span class="hl-6">undefined</span><span class="hl-1"> &amp;&amp;</span><br/><span class="hl-1">  </span><span class="hl-6">typeof</span><span class="hl-1"> </span><span class="hl-4">value</span><span class="hl-1"> === </span><span class="hl-2">&quot;number&quot;</span><span class="hl-1"> &amp;&amp;</span><br/><span class="hl-1">  !</span><span class="hl-0">isNaN</span><span class="hl-1">(</span><span class="hl-4">value</span><span class="hl-1">) &amp;&amp;</span><br/><span class="hl-1">  </span><span class="hl-0">isFinite</span><span class="hl-1">(</span><span class="hl-4">value</span><span class="hl-1">)</span><br/><span class="hl-1">    ? </span><span class="hl-4">value</span><br/><span class="hl-1">    : </span><span class="hl-6">null</span><span class="hl-1">;</span><br/><br/><span class="hl-5">// Update best strategy if needed</span><br/><span class="hl-6">const</span><span class="hl-1"> </span><span class="hl-7">isBetter</span><span class="hl-1"> =</span><br/><span class="hl-1">  </span><span class="hl-4">bestMetric</span><span class="hl-1"> === </span><span class="hl-6">null</span><span class="hl-1"> ||</span><br/><span class="hl-1">  (</span><span class="hl-4">metricValue</span><span class="hl-1"> !== </span><span class="hl-6">null</span><span class="hl-1"> &amp;&amp; </span><span class="hl-4">metricValue</span><span class="hl-1"> &gt; </span><span class="hl-4">bestMetric</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<a id="key-service-classes-2" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Key Service Classes<a href="#key-service-classes-2" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h3><table>
<thead>
<tr>
<th>Class</th>
<th>Responsibility</th>
<th>Key Methods</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>WalkerLogicPrivateService</code></td>
<td>Core execution loop iterating strategies</td>
<td><code>run(symbol, strategies, metric, context): AsyncGenerator&lt;WalkerContract&gt;</code></td>
</tr>
<tr>
<td><code>WalkerLogicPublicService</code></td>
<td>Context setup and validation</td>
<td><code>run(symbol, context)</code></td>
</tr>
<tr>
<td><code>WalkerCommandService</code></td>
<td>Schema validation and delegation</td>
<td><code>run(symbol, context)</code></td>
</tr>
<tr>
<td><code>BacktestLogicPublicService</code></td>
<td>Backtest execution for each strategy</td>
<td><code>run(symbol, context)</code></td>
</tr>
<tr>
<td><code>BacktestMarkdownService</code></td>
<td>Statistics calculation and retrieval</td>
<td><code>getData(symbol, strategyName)</code></td>
</tr>
<tr>
<td><code>WalkerSchemaService</code></td>
<td>Walker schema storage and retrieval</td>
<td><code>get(walkerName)</code></td>
</tr>
</tbody>
</table>
<hr>
<a id="mode-comparison-shared-components" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Mode Comparison: Shared Components<a href="#mode-comparison-shared-components" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>All three execution modes share the same core strategy execution framework, differing only in temporal progression and result aggregation:</p>
<p><img src="../media/06_Execution_Modes_5.svg" alt="Mermaid Diagram"></p>
<p><strong>Polymorphic Design Pattern</strong></p>
<p>The framework implements a polymorphic architecture where execution mode is orthogonal to strategy logic. All three modes invoke the same <code>ClientStrategy.tick()</code> method with different temporal contexts:</p>
<ul>
<li><strong>Backtest</strong>: Historical <code>Date</code> from timeframe array</li>
<li><strong>Live</strong>: Real-time <code>Date</code> from <code>new Date()</code></li>
<li><strong>Walker</strong>: Historical <code>Date</code> from timeframe array (via Backtest delegation)</li>
</ul>
<p>The <code>backtest</code> boolean parameter in execution context distinguishes between backtest simulation and live execution, enabling mode-specific behaviors like persistence and progress tracking.</p>
<hr>
<a id="data-access-patterns-by-mode" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Data Access Patterns by Mode<a href="#data-access-patterns-by-mode" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p><img src="../media/06_Execution_Modes_6.svg" alt="Mermaid Diagram"></p>
<p><strong>getCandles() vs getNextCandles()</strong></p>
<p>The <code>ClientExchange</code> class provides two distinct methods for candle retrieval with different temporal semantics:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Direction</th>
<th>Use Case</th>
<th>Mode</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>getCandles()</code></td>
<td>Backwards from <code>ExecutionContext.when</code></td>
<td>Fetch historical data for indicator calculation</td>
<td>Both Backtest and Live</td>
</tr>
<tr>
<td><code>getNextCandles()</code></td>
<td>Forwards from <code>ExecutionContext.when</code></td>
<td>Fetch future data for signal simulation</td>
<td>Backtest only</td>
</tr>
</tbody>
</table>
<p>The <code>getNextCandles()</code> method validates that requested data does not exceed <code>Date.now()</code>, returning empty array if future data is requested. This prevents time-travel paradoxes in live mode.</p>
<hr>
<a id="performance-and-event-emission" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Performance and Event Emission<a href="#performance-and-event-emission" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>Each mode emits distinct performance metrics and progress events through the event system:</p>
<table>
<thead>
<tr>
<th>Event Type</th>
<th>Backtest</th>
<th>Live</th>
<th>Walker</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Progress</strong></td>
<td><code>progressBacktestEmitter</code> (frames processed)</td>
<td>Not applicable</td>
<td><code>progressWalkerEmitter</code> (strategies tested)</td>
</tr>
<tr>
<td><strong>Performance</strong></td>
<td><code>performanceEmitter</code> (timeframe duration, signal duration)</td>
<td><code>performanceEmitter</code> (tick duration)</td>
<td>Not applicable (delegates to Backtest)</td>
</tr>
<tr>
<td><strong>Signal</strong></td>
<td><code>signalBacktestEmitter</code></td>
<td><code>signalLiveEmitter</code></td>
<td><code>signalBacktestEmitter</code> (via delegation)</td>
</tr>
<tr>
<td><strong>Completion</strong></td>
<td><code>doneBacktestSubject</code></td>
<td><code>doneLiveSubject</code> (never fires)</td>
<td><code>doneWalkerSubject</code></td>
</tr>
<tr>
<td><strong>Error</strong></td>
<td><code>errorEmitter</code> (recoverable errors)</td>
<td><code>errorEmitter</code> (recoverable errors)</td>
<td><code>errorEmitter</code> (recoverable errors)</td>
</tr>
</tbody>
</table>
<p><strong>Performance Monitoring</strong></p>
<p>All modes track execution timing via <code>performanceEmitter</code> with mode-specific metric types:</p>
<ul>
<li>Backtest: <code>backtest_timeframe</code>, <code>backtest_signal</code>, <code>backtest_total</code></li>
<li>Live: <code>live_tick</code></li>
<li>Walker: Inherits backtest metrics for each strategy run</li>
</ul>
</div></div><div class="col-sidebar"><div class="page-menu"><div class="tsd-navigation settings"><details class="tsd-accordion"><summary class="tsd-accordion-summary"><h3><svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-chevronDown"></use></svg>Settings</h3></summary><div class="tsd-accordion-details"><div class="tsd-filter-visibility"><span class="settings-label">Member Visibility</span><ul id="tsd-filter-options"><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-protected" name="protected"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Protected</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-inherited" name="inherited" checked/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Inherited</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-external" name="external"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>External</span></label></li></ul></div><div class="tsd-theme-toggle"><label class="settings-label" for="tsd-theme">Theme</label><select id="tsd-theme"><option value="os">OS</option><option value="light">Light</option><option value="dark">Dark</option></select></div></div></details></div><details open class="tsd-accordion tsd-page-navigation"><summary class="tsd-accordion-summary"><h3><svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-chevronDown"></use></svg>On This Page</h3></summary><div class="tsd-accordion-details"><a href="#execution-modes"><span>Execution <wbr/>Modes</span></a><ul><li><a href="#purpose-and-scope"><span>Purpose and <wbr/>Scope</span></a></li><li><a href="#mode-overview"><span>Mode <wbr/>Overview</span></a></li><li><a href="#mode-selection-and-entry-points"><span>Mode <wbr/>Selection and <wbr/>Entry <wbr/>Points</span></a></li><li><a href="#backtest-mode"><span>Backtest <wbr/>Mode</span></a></li><li><ul><li><a href="#characteristics"><span>Characteristics</span></a></li><li><a href="#execution-flow"><span>Execution <wbr/>Flow</span></a></li><li><a href="#key-service-classes"><span>Key <wbr/>Service <wbr/>Classes</span></a></li></ul></li><li><a href="#live-mode"><span>Live <wbr/>Mode</span></a></li><li><ul><li><a href="#characteristics-1"><span>Characteristics</span></a></li><li><a href="#execution-flow-1"><span>Execution <wbr/>Flow</span></a></li><li><a href="#crash-recovery-architecture"><span>Crash <wbr/>Recovery <wbr/>Architecture</span></a></li><li><a href="#key-service-classes-1"><span>Key <wbr/>Service <wbr/>Classes</span></a></li></ul></li><li><a href="#walker-mode"><span>Walker <wbr/>Mode</span></a></li><li><ul><li><a href="#characteristics-2"><span>Characteristics</span></a></li><li><a href="#execution-flow-2"><span>Execution <wbr/>Flow</span></a></li><li><a href="#key-service-classes-2"><span>Key <wbr/>Service <wbr/>Classes</span></a></li></ul></li><li><a href="#mode-comparison-shared-components"><span>Mode <wbr/>Comparison: <wbr/>Shared <wbr/>Components</span></a></li><li><a href="#data-access-patterns-by-mode"><span>Data <wbr/>Access <wbr/>Patterns by <wbr/>Mode</span></a></li><li><a href="#performance-and-event-emission"><span>Performance and <wbr/>Event <wbr/>Emission</span></a></li></ul></div></details></div><div class="site-menu"><nav class="tsd-navigation"><a href="../modules.html">backtest-kit</a><ul class="tsd-small-nested-navigation" id="tsd-nav-container"><li>Loading...</li></ul></nav></div></div></div><footer><p class="tsd-generator">Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p></footer><div class="overlay"></div></body></html>

<!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function(m,e,t,r,i,k,a){
        m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();
        for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
        k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)
    })(window, document,'script','https://mc.yandex.ru/metrika/tag.js?id=105455585', 'ym');

    ym(105455585, 'init', {ssr:true, webvisor:true, clickmap:true, ecommerce:"dataLayer", accurateTrackBounce:true, trackLinks:true});
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/105455585" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3MQZEBBDDR"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-3MQZEBBDDR');
</script>
