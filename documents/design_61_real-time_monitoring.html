<!DOCTYPE html><html class="default" lang="en" data-base=".."><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="IE=edge"/><title>design/61_real-time_monitoring | backtest-kit</title><meta name="description" content="Documentation for backtest-kit"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="../assets/style.css"/><link rel="stylesheet" href="../assets/highlight.css"/><script defer src="../assets/main.js"></script><script async src="../assets/icons.js" id="tsd-icons-script"></script><script async src="../assets/search.js" id="tsd-search-script"></script><script async src="../assets/navigation.js" id="tsd-nav-script"></script><script async src="../assets/hierarchy.js" id="tsd-hierarchy-script"></script></head><body><script>document.documentElement.dataset.theme = localStorage.getItem("tsd-theme") || "os";document.body.style.display="none";setTimeout(() => app?app.showPage():document.body.style.removeProperty("display"),500)</script><header class="tsd-page-toolbar"><div class="tsd-toolbar-contents container"><div class="table-cell" id="tsd-search"><div class="field"><label for="tsd-search-field" class="tsd-widget tsd-toolbar-icon search no-caption"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-search"></use></svg></label><input type="text" id="tsd-search-field" aria-label="Search"/></div><div class="field"><div id="tsd-toolbar-links"></div></div><ul class="results"><li class="state loading">Preparing search index...</li><li class="state failure">The search index is not available</li></ul><a href="../index.html" class="title">backtest-kit</a></div><div class="table-cell" id="tsd-widgets"><a href="#" class="tsd-widget tsd-toolbar-icon menu no-caption" data-toggle="menu" aria-label="Menu"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-menu"></use></svg></a></div></div></header><div class="container container-main"><div class="col-content"><div class="tsd-page-title"><ul class="tsd-breadcrumb"><li><a href="../modules.html">backtest-kit</a></li><li><a href="design_61_real-time_monitoring.html">design/61_real-time_monitoring</a></li></ul></div><div class="tsd-panel tsd-typography"><a id="real-time-monitoring" class="tsd-anchor"></a><h1 class="tsd-anchor-link">Real-time Monitoring<a href="#real-time-monitoring" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h1><p>Real-time monitoring is the continuous process of evaluating signal states during live trading execution. The system uses an infinite loop with periodic sleep intervals to check signal status, emit events, collect performance metrics, and handle errors without interrupting execution. This page covers the monitoring loop architecture, tick evaluation, event emission, and state-specific monitoring behavior.</p>
<p>For information about the overall live execution flow, see <a href="design_59_live_execution_flow.html">10.1</a>. For crash recovery mechanisms, see <a href="design_60_crash_recovery.html">10.2</a>. For interval-based throttling to prevent signal spam, see <a href="design_62_interval_throttling.html">10.4</a>.</p>
<hr>
<a id="monitoring-loop-architecture" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Monitoring Loop Architecture<a href="#monitoring-loop-architecture" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The monitoring loop is implemented in <code>LiveLogicPrivateService</code> as an infinite <code>while(true)</code> loop that continuously evaluates signal status. Each iteration creates a real-time timestamp with <code>new Date()</code>, calls <code>tick()</code> to evaluate signal state, emits events, and sleeps for <code>TICK_TTL</code> before the next iteration.</p>
<p><img src="../media/61_Real-time_Monitoring_0.svg" alt="Mermaid Diagram"></p>
<p><strong>Key Components:</strong></p>
<table>
<thead>
<tr>
<th>Component</th>
<th>Type</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TICK_TTL</code></td>
<td><code>const number</code></td>
<td>Sleep interval between ticks: <code>1 * 60 * 1_000 + 1</code> (just over 1 minute)</td>
</tr>
<tr>
<td><code>when</code></td>
<td><code>Date</code></td>
<td>Real-time timestamp created with <code>new Date()</code> for each iteration</td>
</tr>
<tr>
<td><code>result</code></td>
<td><code>IStrategyTickResult</code></td>
<td>Discriminated union returned by <code>tick()</code> method</td>
</tr>
<tr>
<td><code>sleep()</code></td>
<td>Function</td>
<td>Async delay from <code>functools-kit</code> to pause between iterations</td>
</tr>
</tbody>
</table>
<p><strong>Loop Behavior:</strong></p>
<ol>
<li><strong>Continuous Execution</strong>: Never exits except via <code>getStopped()</code> check when idle or after signal closes</li>
<li><strong>Real-time Timestamps</strong>: Each iteration uses current time, not historical data</li>
<li><strong>Error Recovery</strong>: Errors are logged and emitted but do not break the loop</li>
<li><strong>State-Aware Sleep</strong>: All states sleep for <code>TICK_TTL</code> except when breaking</li>
</ol>
<hr>
<a id="tick-evaluation-process" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Tick Evaluation Process<a href="#tick-evaluation-process" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The <code>tick()</code> method evaluates the current signal state by checking for pending signals, validating scheduled signals, or generating new signals via <code>getSignal()</code>. The evaluation is wrapped in an execution context containing symbol, timestamp, and backtest flag.</p>
<p><img src="../media/61_Real-time_Monitoring_1.svg" alt="Mermaid Diagram"></p>
<p><strong>Validation Chain:</strong></p>
<p>The signal validation process runs multiple checks sequentially before allowing a signal to be created:</p>
<table>
<thead>
<tr>
<th>Validation Type</th>
<th>Service</th>
<th>Checks</th>
</tr>
</thead>
<tbody>
<tr>
<td>Schema Existence</td>
<td><code>StrategyValidationService</code></td>
<td>Strategy is registered via <code>addStrategy()</code></td>
</tr>
<tr>
<td>Risk Existence</td>
<td><code>RiskValidationService</code></td>
<td>Risk profiles exist if specified</td>
</tr>
<tr>
<td>Signal Type</td>
<td><code>ClientStrategy</code></td>
<td><code>position</code> is &quot;long&quot; or &quot;short&quot;</td>
</tr>
<tr>
<td>Price Logic</td>
<td><code>ClientStrategy</code></td>
<td>TP &gt; priceOpen &gt; SL for long, SL &gt; priceOpen &gt; TP for short</td>
</tr>
<tr>
<td>Price Distance</td>
<td><code>ClientStrategy</code></td>
<td>TP/SL meet minimum distance requirements</td>
</tr>
<tr>
<td>Time Validity</td>
<td><code>ClientStrategy</code></td>
<td><code>minuteEstimatedTime</code> is positive</td>
</tr>
<tr>
<td>Risk Checks</td>
<td><code>ClientRisk.checkSignal()</code></td>
<td>Portfolio limits, custom validations</td>
</tr>
</tbody>
</table>
<hr>
<a id="event-driven-monitoring" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Event-Driven Monitoring<a href="#event-driven-monitoring" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The monitoring system emits events through RxJS Subjects for external observers to track execution without coupling to internal logic. Events are emitted at multiple points during tick evaluation and are processed sequentially via <code>queued()</code> wrapper.</p>
<p><img src="../media/61_Real-time_Monitoring_2.svg" alt="Mermaid Diagram"></p>
<p><strong>Event Types and Payloads:</strong></p>
<table>
<thead>
<tr>
<th>Emitter</th>
<th>Contract Type</th>
<th>Emitted When</th>
<th>Key Fields</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>signalEmitter</code></td>
<td><code>IStrategyTickResult</code></td>
<td>Every tick result</td>
<td><code>action</code>, <code>signal</code>, <code>currentPrice</code>, <code>symbol</code></td>
</tr>
<tr>
<td><code>signalLiveEmitter</code></td>
<td><code>IStrategyTickResult</code></td>
<td>Live mode only</td>
<td>Same as <code>signalEmitter</code></td>
</tr>
<tr>
<td><code>performanceEmitter</code></td>
<td><code>PerformanceContract</code></td>
<td>Every tick</td>
<td><code>metricType: &quot;live_tick&quot;</code>, <code>duration</code>, <code>timestamp</code></td>
</tr>
<tr>
<td><code>errorEmitter</code></td>
<td><code>Error</code></td>
<td>Tick fails</td>
<td><code>message</code>, <code>stack</code></td>
</tr>
<tr>
<td><code>partialProfitSubject</code></td>
<td><code>PartialProfitContract</code></td>
<td>Profit milestone</td>
<td><code>level</code>, <code>data</code>, <code>currentPrice</code>, <code>backtest</code></td>
</tr>
<tr>
<td><code>partialLossSubject</code></td>
<td><code>PartialLossContract</code></td>
<td>Loss milestone</td>
<td><code>level</code>, <code>data</code>, <code>currentPrice</code>, <code>backtest</code></td>
</tr>
<tr>
<td><code>riskSubject</code></td>
<td><code>RiskContract</code></td>
<td>Signal rejected</td>
<td><code>symbol</code>, <code>pendingSignal</code>, <code>activePositionCount</code>, <code>comment</code></td>
</tr>
</tbody>
</table>
<p><strong>Listener Pattern:</strong></p>
<p>All listener functions use the <code>queued()</code> wrapper to ensure sequential processing:</p>
<pre><code class="typescript"><span class="hl-5">// From src/function/event.ts</span><br/><span class="hl-3">export</span><span class="hl-1"> </span><span class="hl-7">function</span><span class="hl-1"> </span><span class="hl-0">listenSignalLive</span><span class="hl-1">(</span><span class="hl-0">fn</span><span class="hl-1">: (</span><span class="hl-4">event</span><span class="hl-1">: </span><span class="hl-11">IStrategyTickResult</span><span class="hl-1">) </span><span class="hl-7">=&gt;</span><span class="hl-1"> </span><span class="hl-11">void</span><span class="hl-1">) {</span><br/><span class="hl-1">  </span><span class="hl-3">return</span><span class="hl-1"> </span><span class="hl-4">signalLiveEmitter</span><span class="hl-1">.</span><span class="hl-0">subscribe</span><span class="hl-1">(</span><span class="hl-0">queued</span><span class="hl-1">(</span><span class="hl-7">async</span><span class="hl-1"> (</span><span class="hl-4">event</span><span class="hl-1">) </span><span class="hl-7">=&gt;</span><span class="hl-1"> </span><span class="hl-0">fn</span><span class="hl-1">(</span><span class="hl-4">event</span><span class="hl-1">)));</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<p>The <code>queued()</code> wrapper guarantees that:</p>
<ul>
<li>Events are processed in the order they are emitted</li>
<li>The next event waits for the previous callback to complete</li>
<li>No concurrent execution of the same callback</li>
<li>Async callbacks are properly awaited</li>
</ul>
<hr>
<a id="performance-metrics-collection" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Performance Metrics Collection<a href="#performance-metrics-collection" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>Each tick iteration emits performance metrics to track execution duration and detect bottlenecks. The metrics include operation type, duration, timestamp, and delta from the previous event.</p>
<p><img src="../media/61_Real-time_Monitoring_3.svg" alt="Mermaid Diagram"></p>
<p><strong>Performance Contract Fields:</strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>timestamp</code></td>
<td><code>number</code></td>
<td>Current event timestamp in milliseconds</td>
</tr>
<tr>
<td><code>previousTimestamp</code></td>
<td><code>number | null</code></td>
<td>Previous event timestamp for delta calculation</td>
</tr>
<tr>
<td><code>metricType</code></td>
<td><code>&quot;live_tick&quot;</code></td>
<td>Operation type being measured</td>
</tr>
<tr>
<td><code>duration</code></td>
<td><code>number</code></td>
<td>Execution time in milliseconds (from <code>performance.now()</code>)</td>
</tr>
<tr>
<td><code>strategyName</code></td>
<td><code>string</code></td>
<td>Strategy being executed</td>
</tr>
<tr>
<td><code>exchangeName</code></td>
<td><code>string</code></td>
<td>Exchange being used</td>
</tr>
<tr>
<td><code>symbol</code></td>
<td><code>string</code></td>
<td>Trading pair symbol</td>
</tr>
<tr>
<td><code>backtest</code></td>
<td><code>boolean</code></td>
<td>Always <code>false</code> for live mode</td>
</tr>
</tbody>
</table>
<p><strong>Metric Types:</strong></p>
<p>For live trading, the primary metric is:</p>
<ul>
<li><code>&quot;live_tick&quot;</code>: Time to complete one monitoring iteration including tick evaluation, event emission, and state checks</li>
</ul>
<p>The <code>previousTimestamp</code> field enables calculating time between events for monitoring system throughput.</p>
<hr>
<a id="error-handling-during-monitoring" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Error Handling During Monitoring<a href="#error-handling-during-monitoring" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The monitoring loop implements graceful error handling to ensure that transient failures do not stop live trading execution. Errors are logged, emitted for external observers, and followed by a sleep before retry.</p>
<p><img src="../media/61_Real-time_Monitoring_4.svg" alt="Mermaid Diagram"></p>
<p><strong>Error Handling Strategy:</strong></p>
<table>
<thead>
<tr>
<th>Step</th>
<th>Action</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td>Console Warning</td>
<td><code>console.warn()</code> with context</td>
<td>Immediate visibility in logs</td>
</tr>
<tr>
<td>Logger Service</td>
<td><code>loggerService.warn()</code> with <code>errorData()</code></td>
<td>Structured logging with stack trace</td>
</tr>
<tr>
<td>Error Emission</td>
<td><code>errorEmitter.next(error)</code></td>
<td>External observers can react</td>
</tr>
<tr>
<td>Sleep</td>
<td><code>sleep(TICK_TTL)</code></td>
<td>Prevent tight error loops</td>
</tr>
<tr>
<td>Continue</td>
<td><code>continue</code> keyword</td>
<td>Skip to next iteration without breaking loop</td>
</tr>
</tbody>
</table>
<p><strong>Error Context:</strong></p>
<p>The warning message includes full context for debugging:</p>
<pre><code><span class="hl-4">backtestLogicPrivateService</span><span class="hl-1"> </span><span class="hl-4">tick</span><span class="hl-1"> </span><span class="hl-4">failed</span><span class="hl-1"> </span><span class="hl-4">when</span><span class="hl-1">=</span><span class="hl-4">$</span><span class="hl-1">{</span><span class="hl-4">when</span><span class="hl-1">.</span><span class="hl-0">toISOString</span><span class="hl-1">()} </span><br/><span class="hl-4">symbol</span><span class="hl-1">=</span><span class="hl-4">$</span><span class="hl-1">{</span><span class="hl-4">symbol</span><span class="hl-1">} </span><span class="hl-4">strategyName</span><span class="hl-1">=</span><span class="hl-4">$</span><span class="hl-1">{</span><span class="hl-4">strategyName</span><span class="hl-1">} </span><span class="hl-4">exchangeName</span><span class="hl-1">=</span><span class="hl-4">$</span><span class="hl-1">{</span><span class="hl-4">exchangeName</span><span class="hl-1">}</span>
</code><button>Copy</button></pre>

<p><strong>Retry Behavior:</strong></p>
<ul>
<li>No retry limit - loop continues indefinitely</li>
<li>Errors do not accumulate - each is handled independently</li>
<li>Sleep interval matches normal tick interval to maintain timing</li>
<li>Next iteration starts fresh with new <code>Date()</code> timestamp</li>
</ul>
<hr>
<a id="state-specific-monitoring-behavior" class="tsd-anchor"></a><h2 class="tsd-anchor-link">State-Specific Monitoring Behavior<a href="#state-specific-monitoring-behavior" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The monitoring loop handles each signal state differently, with varying sleep durations and yield behavior. Understanding state-specific behavior is critical for efficient monitoring.</p>
<p><img src="../media/61_Real-time_Monitoring_5.svg" alt="Mermaid Diagram"></p>
<p><strong>State Behavior Summary:</strong></p>
<table>
<thead>
<tr>
<th>State</th>
<th>Yielded?</th>
<th>Sleep After?</th>
<th>Stop Check?</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>idle</code></td>
<td>No</td>
<td>Yes</td>
<td>Before sleep</td>
<td>No signal exists, safe to stop</td>
</tr>
<tr>
<td><code>scheduled</code></td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>Waiting for price activation, keep monitoring</td>
</tr>
<tr>
<td><code>active</code></td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>Position open, keep monitoring TP/SL</td>
</tr>
<tr>
<td><code>opened</code></td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>Notify consumer of new position</td>
</tr>
<tr>
<td><code>closed</code></td>
<td>Yes</td>
<td>Yes</td>
<td>After yield</td>
<td>Notify consumer of PNL, allow graceful stop</td>
</tr>
<tr>
<td><code>cancelled</code></td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>Notify consumer of cancelled scheduled signal</td>
</tr>
</tbody>
</table>
<p><strong>Yield Behavior:</strong></p>
<p>Only <code>opened</code>, <code>closed</code>, and <code>cancelled</code> results are yielded to the async generator consumer. This means:</p>
<ul>
<li>Consumer receives notification when positions open or close</li>
<li>Consumer does not receive continuous updates during active monitoring</li>
<li>For continuous monitoring, use event listeners instead of generator consumption</li>
</ul>
<p><strong>Stop Check Timing:</strong></p>
<p>The <code>getStopped()</code> check occurs at strategic points:</p>
<ul>
<li><strong>Before idle sleep</strong>: Safe to stop when no active position</li>
<li><strong>After closed yield</strong>: Graceful exit after position completes</li>
<li><strong>Not during active/scheduled</strong>: Prevents stopping mid-position</li>
</ul>
<hr>
<a id="continuous-monitoring-vs-backtest-monitoring" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Continuous Monitoring vs. Backtest Monitoring<a href="#continuous-monitoring-vs-backtest-monitoring" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The monitoring behavior differs significantly between live and backtest modes. Live monitoring operates on real-time data with sleep intervals, while backtest monitoring fast-forwards through historical data without delays.</p>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Live Monitoring</th>
<th>Backtest Monitoring</th>
</tr>
</thead>
<tbody>
<tr>
<td>Loop Type</td>
<td><code>while(true)</code> infinite loop</td>
<td><code>while (i &lt; timeframes.length)</code> finite loop</td>
</tr>
<tr>
<td>Timestamp Source</td>
<td><code>new Date()</code> real-time</td>
<td><code>timeframes[i]</code> historical array</td>
</tr>
<tr>
<td>Sleep Intervals</td>
<td><code>sleep(TICK_TTL)</code> between ticks</td>
<td>No sleep, continuous iteration</td>
</tr>
<tr>
<td>Timeframe Skipping</td>
<td>No skipping, monitors every minute</td>
<td>Skips to <code>closeTimestamp</code> after signal opens</td>
</tr>
<tr>
<td>Signal Processing</td>
<td><code>tick()</code> only, monitors one signal</td>
<td><code>tick()</code> for idle, <code>backtest()</code> for opened</td>
</tr>
<tr>
<td>Persistence</td>
<td>Writes after every tick</td>
<td>No disk I/O during backtest</td>
</tr>
<tr>
<td>Performance Focus</td>
<td>Minimize latency for real-time response</td>
<td>Maximize throughput for historical analysis</td>
</tr>
<tr>
<td>Stop Behavior</td>
<td>Breaks loop when idle or closed</td>
<td>Breaks loop at any idle state</td>
</tr>
<tr>
<td>Event Emission</td>
<td><code>signalLiveEmitter</code></td>
<td><code>signalBacktestEmitter</code></td>
</tr>
</tbody>
</table>
<p><strong>Key Architectural Difference:</strong></p>
<p>Live monitoring prioritizes <strong>reliability</strong> and <strong>real-time response</strong>:</p>
<ul>
<li>Persistence after every tick for crash recovery</li>
<li>Sleep intervals prevent API rate limiting</li>
<li>Error recovery without stopping execution</li>
</ul>
<p>Backtest monitoring prioritizes <strong>speed</strong> and <strong>efficiency</strong>:</p>
<ul>
<li>No persistence to avoid disk I/O overhead</li>
<li>Timeframe skipping reduces redundant checks</li>
<li>Fast-forward through signal duration with <code>backtest()</code> method</li>
</ul>
</div></div><div class="col-sidebar"><div class="page-menu"><div class="tsd-navigation settings"><details class="tsd-accordion"><summary class="tsd-accordion-summary"><h3><svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-chevronDown"></use></svg>Settings</h3></summary><div class="tsd-accordion-details"><div class="tsd-filter-visibility"><span class="settings-label">Member Visibility</span><ul id="tsd-filter-options"><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-protected" name="protected"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Protected</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-inherited" name="inherited" checked/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Inherited</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-external" name="external"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>External</span></label></li></ul></div><div class="tsd-theme-toggle"><label class="settings-label" for="tsd-theme">Theme</label><select id="tsd-theme"><option value="os">OS</option><option value="light">Light</option><option value="dark">Dark</option></select></div></div></details></div><details open class="tsd-accordion tsd-page-navigation"><summary class="tsd-accordion-summary"><h3><svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-chevronDown"></use></svg>On This Page</h3></summary><div class="tsd-accordion-details"><a href="#real-time-monitoring"><span>Real-<wbr/>time <wbr/>Monitoring</span></a><ul><li><a href="#monitoring-loop-architecture"><span>Monitoring <wbr/>Loop <wbr/>Architecture</span></a></li><li><a href="#tick-evaluation-process"><span>Tick <wbr/>Evaluation <wbr/>Process</span></a></li><li><a href="#event-driven-monitoring"><span>Event-<wbr/>Driven <wbr/>Monitoring</span></a></li><li><a href="#performance-metrics-collection"><span>Performance <wbr/>Metrics <wbr/>Collection</span></a></li><li><a href="#error-handling-during-monitoring"><span>Error <wbr/>Handling <wbr/>During <wbr/>Monitoring</span></a></li><li><a href="#state-specific-monitoring-behavior"><span>State-<wbr/>Specific <wbr/>Monitoring <wbr/>Behavior</span></a></li><li><a href="#continuous-monitoring-vs-backtest-monitoring"><span>Continuous <wbr/>Monitoring vs. <wbr/>Backtest <wbr/>Monitoring</span></a></li></ul></div></details></div><div class="site-menu"><nav class="tsd-navigation"><a href="../modules.html">backtest-kit</a><ul class="tsd-small-nested-navigation" id="tsd-nav-container"><li>Loading...</li></ul></nav></div></div></div><footer><p class="tsd-generator">Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p></footer><div class="overlay"></div></body></html>

<!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function(m,e,t,r,i,k,a){
        m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();
        for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
        k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)
    })(window, document,'script','https://mc.yandex.ru/metrika/tag.js?id=105455585', 'ym');

    ym(105455585, 'init', {ssr:true, webvisor:true, clickmap:true, ecommerce:"dataLayer", accurateTrackBounce:true, trackLinks:true});
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/105455585" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3MQZEBBDDR"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-3MQZEBBDDR');
</script>
