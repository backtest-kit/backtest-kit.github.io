<!DOCTYPE html><html class="default" lang="en" data-base=".."><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="IE=edge"/><title>private/classes | backtest-kit</title><meta name="description" content="Documentation for backtest-kit"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="../assets/style.css"/><link rel="stylesheet" href="../assets/highlight.css"/><script defer src="../assets/main.js"></script><script async src="../assets/icons.js" id="tsd-icons-script"></script><script async src="../assets/search.js" id="tsd-search-script"></script><script async src="../assets/navigation.js" id="tsd-nav-script"></script><script async src="../assets/hierarchy.js" id="tsd-hierarchy-script"></script></head><body><script>document.documentElement.dataset.theme = localStorage.getItem("tsd-theme") || "os";document.body.style.display="none";setTimeout(() => app?app.showPage():document.body.style.removeProperty("display"),500)</script><header class="tsd-page-toolbar"><div class="tsd-toolbar-contents container"><div class="table-cell" id="tsd-search"><div class="field"><label for="tsd-search-field" class="tsd-widget tsd-toolbar-icon search no-caption"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-search"></use></svg></label><input type="text" id="tsd-search-field" aria-label="Search"/></div><div class="field"><div id="tsd-toolbar-links"></div></div><ul class="results"><li class="state loading">Preparing search index...</li><li class="state failure">The search index is not available</li></ul><a href="../index.html" class="title">backtest-kit</a></div><div class="table-cell" id="tsd-widgets"><a href="#" class="tsd-widget tsd-toolbar-icon menu no-caption" data-toggle="menu" aria-label="Menu"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-menu"></use></svg></a></div></div></header><div class="container container-main"><div class="col-content"><div class="tsd-page-title"><ul class="tsd-breadcrumb"><li><a href="../modules.html">backtest-kit</a></li><li><a href="private_classes.html">private/classes</a></li></ul></div><div class="tsd-panel tsd-typography"><a id="backtest-kit-api-reference" class="tsd-anchor"></a><h1 class="tsd-anchor-link">backtest-kit api reference<a href="#backtest-kit-api-reference" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h1><p><img src="../media/uml.svg" alt="schema"></p>
<p><strong>Overview:</strong></p>
<p>Backtest-kit is a production-ready TypeScript framework for backtesting and live trading strategies with crash-safe state persistence, signal validation, and memory-optimized architecture. The framework follows clean architecture principles with dependency injection, separation of concerns, and type-safe discriminated unions.</p>
<p><strong>Core Concepts:</strong></p>
<ul>
<li><strong>Signal Lifecycle:</strong> Type-safe state machine (idle → opened → active → closed) with discriminated unions</li>
<li><strong>Execution Modes:</strong> Backtest mode (historical data) and Live mode (real-time with crash recovery)</li>
<li><strong>VWAP Pricing:</strong> Volume Weighted Average Price from last 5 1-minute candles for all entry/exit decisions</li>
<li><strong>Signal Validation:</strong> Comprehensive validation ensures TP/SL logic, positive prices, and valid timestamps</li>
<li><strong>Interval Throttling:</strong> Prevents signal spam with configurable intervals (1m, 3m, 5m, 15m, 30m, 1h)</li>
<li><strong>Crash-Safe Persistence:</strong> Atomic file writes with automatic state recovery for live trading</li>
<li><strong>Async Generators:</strong> Memory-efficient streaming for backtest and live execution</li>
<li><strong>Accurate PNL:</strong> Calculation with fees (0.1%) and slippage (0.1%) for realistic simulations</li>
<li><strong>Event System:</strong> Signal emitters for backtest/live/global signals, errors, and completion events</li>
<li><strong>Graceful Shutdown:</strong> Live.background() waits for open positions to close before stopping</li>
<li><strong>Pluggable Persistence:</strong> Custom adapters for Redis, MongoDB, or any storage backend</li>
</ul>
<p><strong>Architecture Layers:</strong></p>
<ul>
<li><strong>Client Layer:</strong> Pure business logic without DI (ClientStrategy, ClientExchange, ClientFrame) using prototype methods for memory efficiency</li>
<li><strong>Service Layer:</strong> DI-based services organized by responsibility:
<ul>
<li><strong>Schema Services:</strong> Registry pattern for configuration with shallow validation (StrategySchemaService, ExchangeSchemaService, FrameSchemaService)</li>
<li><strong>Validation Services:</strong> Runtime existence validation with memoization (StrategyValidationService, ExchangeValidationService, FrameValidationService)</li>
<li><strong>Connection Services:</strong> Memoized client instance creators (StrategyConnectionService, ExchangeConnectionService, FrameConnectionService)</li>
<li><strong>Global Services:</strong> Context wrappers for public API (StrategyGlobalService, ExchangeGlobalService, FrameGlobalService)</li>
<li><strong>Logic Services:</strong> Async generator orchestration (BacktestLogicPrivateService, LiveLogicPrivateService)</li>
<li><strong>Markdown Services:</strong> Auto-generated reports with tick-based event log (BacktestMarkdownService, LiveMarkdownService)</li>
</ul>
</li>
<li><strong>Persistence Layer:</strong> Crash-safe atomic file writes with PersistSignalAdaper, extensible via PersistBase</li>
<li><strong>Event Layer:</strong> Subject-based emitters (signalEmitter, errorEmitter, doneEmitter) with queued async processing</li>
</ul>
<p><strong>Key Design Patterns:</strong></p>
<ul>
<li><strong>Discriminated Unions:</strong> Type-safe state machines without optional fields</li>
<li><strong>Async Generators:</strong> Stream results without memory accumulation, enable early termination</li>
<li><strong>Dependency Injection:</strong> Custom DI container with Symbol-based tokens</li>
<li><strong>Memoization:</strong> Client instances cached by schema name using functools-kit</li>
<li><strong>Context Propagation:</strong> Nested contexts using di-scoped (ExecutionContext + MethodContext)</li>
<li><strong>Registry Pattern:</strong> Schema services use ToolRegistry for configuration management</li>
<li><strong>Singleshot Initialization:</strong> One-time operations with cached promise results</li>
<li><strong>Persist-and-Restart:</strong> Stateless process design with disk-based state recovery</li>
<li><strong>Pluggable Adapters:</strong> PersistBase as base class for custom storage backends</li>
<li><strong>Queued Processing:</strong> Sequential event handling with functools-kit queued wrapper</li>
</ul>
<p><strong>Data Flow (Backtest):</strong></p>
<ol>
<li>User calls Backtest.background(symbol, context) or Backtest.run(symbol, context)</li>
<li>Validation services check strategyName, exchangeName, frameName existence</li>
<li>BacktestLogicPrivateService.run(symbol) creates async generator with yield</li>
<li>MethodContextService.runInContext sets strategyName, exchangeName, frameName</li>
<li>Loop through timeframes, call StrategyGlobalService.tick()</li>
<li>ExecutionContextService.runInContext sets symbol, when, backtest=true</li>
<li>ClientStrategy.tick() checks VWAP against TP/SL conditions</li>
<li>If opened: fetch candles and call ClientStrategy.backtest(candles)</li>
<li>Yield closed result and skip timeframes until closeTimestamp</li>
<li>Emit signals via signalEmitter, signalBacktestEmitter</li>
<li>On completion emit doneEmitter with { backtest: true, symbol, strategyName, exchangeName }</li>
</ol>
<p><strong>Data Flow (Live):</strong></p>
<ol>
<li>User calls Live.background(symbol, context) or Live.run(symbol, context)</li>
<li>Validation services check strategyName, exchangeName existence</li>
<li>LiveLogicPrivateService.run(symbol) creates infinite async generator with while(true)</li>
<li>MethodContextService.runInContext sets schema names</li>
<li>Loop: create when = new Date(), call StrategyGlobalService.tick()</li>
<li>ClientStrategy.waitForInit() loads persisted signal state from PersistSignalAdaper</li>
<li>ClientStrategy.tick() with interval throttling and validation</li>
<li>setPendingSignal() persists state via PersistSignalAdaper.writeSignalData()</li>
<li>Yield opened and closed results, sleep(TICK_TTL) between ticks</li>
<li>Emit signals via signalEmitter, signalLiveEmitter</li>
<li>On stop() call: wait for lastValue?.action === 'closed' before breaking loop (graceful shutdown)</li>
<li>On completion emit doneEmitter with { backtest: false, symbol, strategyName, exchangeName }</li>
</ol>
<p><strong>Event System:</strong></p>
<ul>
<li><strong>Signal Events:</strong> listenSignal, listenSignalBacktest, listenSignalLive for tick results (idle/opened/active/closed)</li>
<li><strong>Error Events:</strong> listenError for background execution errors (Live.background, Backtest.background)</li>
<li><strong>Completion Events:</strong> listenDone, listenDoneOnce for background execution completion with DoneContract</li>
<li><strong>Queued Processing:</strong> All listeners use queued wrapper from functools-kit for sequential async execution</li>
<li><strong>Filter Predicates:</strong> Once listeners (listenSignalOnce, listenDoneOnce) accept filter function for conditional triggering</li>
</ul>
<p><strong>Performance Optimizations:</strong></p>
<ul>
<li>Memoization of client instances by schema name</li>
<li>Prototype methods (not arrow functions) for memory efficiency</li>
<li>Fast backtest method skips individual ticks</li>
<li>Timeframe skipping after signal closes</li>
<li>VWAP caching per tick/candle</li>
<li>Async generators stream without array accumulation</li>
<li>Interval throttling prevents excessive signal generation</li>
<li>Singleshot initialization runs exactly once per instance</li>
<li>LiveMarkdownService bounded queue (MAX_EVENTS = 25) prevents memory leaks</li>
<li>Smart idle event replacement (only replaces if no open/active signals after last idle)</li>
</ul>
<p><strong>Use Cases:</strong></p>
<ul>
<li>Algorithmic trading with backtest validation and live deployment</li>
<li>Strategy research and hypothesis testing on historical data</li>
<li>Signal generation with ML models or technical indicators</li>
<li>Portfolio management tracking multiple strategies across symbols</li>
<li>Educational projects for learning trading system architecture</li>
<li>Event-driven trading bots with real-time notifications (Telegram, Discord, email)</li>
<li>Multi-exchange trading with pluggable exchange adapters</li>
</ul>
<p><strong>Test Coverage:</strong></p>
<p>The framework includes comprehensive unit tests using worker-testbed (tape-based testing):</p>
<ul>
<li><strong>exchange.test.mjs:</strong> Tests exchange helper functions (getCandles, getAveragePrice, getDate, getMode, formatPrice, formatQuantity) with mock candle data and VWAP calculations</li>
<li><strong>event.test.mjs:</strong> Tests Live.background() execution and event listener system (listenSignalLive, listenSignalLiveOnce, listenDone, listenDoneOnce) for async coordination</li>
<li><strong>validation.test.mjs:</strong> Tests signal validation logic (valid long/short positions, invalid TP/SL relationships, negative price detection, timestamp validation) using listenError for error handling</li>
<li><strong>pnl.test.mjs:</strong> Tests PNL calculation accuracy with realistic fees (0.1%) and slippage (0.1%) simulation</li>
<li><strong>backtest.test.mjs:</strong> Tests Backtest.run() and Backtest.background() with signal lifecycle verification (idle → opened → active → closed), listenDone events, early termination, and all close reasons (take_profit, stop_loss, time_expired)</li>
<li><strong>callbacks.test.mjs:</strong> Tests strategy lifecycle callbacks (onOpen, onClose, onTimeframe) with correct parameter passing, backtest flag verification, and signal object integrity</li>
<li><strong>report.test.mjs:</strong> Tests markdown report generation (Backtest.getReport, Live.getReport) with statistics validation (win rate, average PNL, total PNL, closed signals count) and table formatting</li>
</ul>
<p>All tests follow consistent patterns:</p>
<ul>
<li>Unique exchange/strategy/frame names per test to prevent cross-contamination</li>
<li>Mock candle generator (getMockCandles.mjs) with forward timestamp progression</li>
<li>createAwaiter from functools-kit for async coordination</li>
<li>Background execution with Backtest.background() and event-driven completion detection</li>
</ul>
<a id="backtest-kit-classes" class="tsd-anchor"></a><h1 class="tsd-anchor-link">backtest-kit classes<a href="#backtest-kit-classes" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h1><a id="class-walkervalidationservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class WalkerValidationService<a href="#class-walkervalidationservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This service helps you keep track of and make sure your walker configurations are set up correctly. A walker defines the ranges of parameters you'll test when optimizing or tuning models. Think of it as a central place to register your walkers, so you know they're available and valid before you start running tests. It remembers the results of validations to speed things up and provides a simple way to see a list of all the walkers you’ve defined. You can use it to add new walkers, double-check that a walker exists before using it, and get a complete overview of all your walkers.</p>
<a id="class-walkerutils" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class WalkerUtils<a href="#class-walkerutils" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>WalkerUtils provides helpful tools for working with walkers, which are essentially automated trading strategies. It simplifies running and managing these strategies, automatically handling some of the underlying complexities.</p>
<p>Think of it as a central place to kick off walker comparisons – it manages the process and keeps things organized. You can start a comparison, run it in the background without needing to see all the details, or stop it entirely.</p>
<p>The class also provides functions to get data from completed comparisons, generate reports, and save those reports to a file. It even allows you to list all the active walkers and their current status, so you can keep an eye on what's running. It's designed to be easy to use, with a single, readily accessible instance to manage all your walker operations.</p>
<a id="class-walkerschemaservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class WalkerSchemaService<a href="#class-walkerschemaservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This service helps you keep track of different trading strategies, or &quot;walkers,&quot; and their associated configurations in a safe and organized way. Think of it as a central library for your trading blueprints. It uses a special system to ensure the configurations are structured correctly, preventing errors down the line.</p>
<p>You can add new trading strategies using <code>addWalker()</code>, and retrieve them later by their name using <code>get()</code>. If a strategy already exists, you can update parts of its configuration with <code>override()</code>. Before adding a new strategy, <code>validateShallow()</code> checks to make sure it has all the necessary components in the right format. The service stores all these configurations in a secure registry.</p>
<a id="class-walkerreportservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class WalkerReportService<a href="#class-walkerreportservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The WalkerReportService helps you keep track of how your trading strategies are performing during optimization. It acts like a diligent record keeper, capturing the results of each test run and storing them in a database.</p>
<p>This service listens for updates from the optimization process and logs key details like metrics and statistics for each strategy. You can use it to monitor your progress, identify the best-performing strategies, and compare different parameter settings.</p>
<p>To use it, you subscribe to receive these updates, and when you’re done, you can unsubscribe to stop the flow of information. The system makes sure you don't accidentally subscribe multiple times, preventing unwanted data.</p>
<a id="class-walkermarkdownservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class WalkerMarkdownService<a href="#class-walkermarkdownservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This service helps you automatically create and save reports about your trading strategies as they’re being tested. It listens for updates during the testing process, keeping track of how each strategy is performing.  The service gathers results and organizes them into easy-to-read markdown tables, which it then saves to files on your computer, making it simple to review and compare your strategies.</p>
<p>You can subscribe to receive these updates as they happen, and unsubscribe when you no longer need them.  There's a way to get specific data about a strategy’s performance, generate a complete report, or clear out all the accumulated data if you want to start fresh. Each strategy run, or “walker,” gets its own dedicated storage space to keep things organized.</p>
<a id="class-walkerlogicpublicservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class WalkerLogicPublicService<a href="#class-walkerlogicpublicservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This service helps manage and run your trading strategies, also known as &quot;walkers.&quot; It simplifies things by automatically passing important information, like the strategy's name and the exchange being used, along with each execution. Think of it as a conductor orchestrating different parts of your backtesting process.</p>
<p>It relies on a private service to handle the core logic and another to understand the structure of your walkers.</p>
<p>The <code>run</code> method is key; it allows you to execute comparisons for a specific financial instrument (like a stock ticker) and automatically provides the necessary context for each strategy. This method returns a sequence of results as your walkers complete.</p>
<a id="class-walkerlogicprivateservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class WalkerLogicPrivateService<a href="#class-walkerlogicprivateservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This service helps you compare different trading strategies against each other. It acts as an orchestrator, running each strategy one after another and giving you updates on their progress. As each strategy finishes, you'll receive information about its performance, and the service keeps track of the best-performing strategy in real-time. Finally, it provides a complete ranked list of all the strategies you tested, so you can easily see which ones performed the best for a specific symbol. To run a comparison, you need to specify the trading symbol, a list of strategies to test, the metric you’re using to evaluate them (like profit or Sharpe ratio), and some context information about the exchange, frame, and walker.</p>
<a id="class-walkercommandservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class WalkerCommandService<a href="#class-walkercommandservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>WalkerCommandService acts as a central access point for interacting with walker functionality within the backtest-kit. Think of it as a helpful intermediary, simplifying how you use the underlying walker logic. It's designed to be easily incorporated into your applications using dependency injection.</p>
<p>It manages several internal services, including those responsible for logging, handling walker logic, validating strategies and exchanges, and ensuring the overall structure of your backtesting setup is sound.</p>
<p>The main thing this service lets you do is <code>run</code> a walker comparison. You provide a symbol (like a stock ticker) and context information – specifying the walker, exchange, and frame you want to use – and it returns a stream of results from the walker comparison.</p>
<a id="class-strategyvalidationservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class StrategyValidationService<a href="#class-strategyvalidationservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This service helps you keep track of and make sure your trading strategies are set up correctly. It acts like a central control panel for your strategies, letting you register new ones and double-check that everything – the strategy itself, the associated risk settings, and any actions it triggers – are all valid.</p>
<p>To make things faster, it remembers the results of previous validations, so it doesn't have to re-check everything every time.</p>
<p>You can use it to:</p>
<ul>
<li>Add new strategies to your system.</li>
<li>Verify that a specific strategy exists and that its settings are okay.</li>
<li>Get a complete list of all the strategies you've registered.</li>
</ul>
<p>It relies on other services, like risk and action validation, to handle the specifics of those areas.</p>
<a id="class-strategyutils" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class StrategyUtils<a href="#class-strategyutils" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>StrategyUtils provides helpful tools for understanding how your trading strategies are performing. It acts as a central place to gather and present information about strategy events, like when a partial profit was taken or a trailing stop was triggered.</p>
<p>You can use it to get statistical summaries of your strategy's actions, like how many times it canceled a scheduled order. It also allows you to create clear, readable reports in Markdown format that include a table of all events with details like price, percentage values, and timestamps. Finally, you can easily save these reports to files for later review and analysis. Think of it as a way to keep track of your strategy's history and learn from its behavior.</p>
<a id="class-strategyschemaservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class StrategySchemaService<a href="#class-strategyschemaservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This service helps you keep track of your trading strategy blueprints, ensuring they're structured correctly and easily accessible. It acts like a central catalog for your strategies.</p>
<p>Think of it as a way to register each strategy, giving it a unique name so you can find it later. When you add a strategy, it performs a quick check to make sure it has all the necessary building blocks.</p>
<p>You can update existing strategies by providing just the parts you want to change.  Retrieving a strategy is as simple as knowing its name – the service will fetch the complete blueprint for you. It uses a special system for type-safe storage, which helps prevent errors.</p>
<a id="class-strategyreportservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class StrategyReportService<a href="#class-strategyreportservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This service helps you keep a detailed record of what your trading strategies are doing. Think of it as a meticulous auditor, writing down every significant action – like canceling orders, closing positions, or adjusting stop-loss levels – to a separate JSON file for each event.</p>
<p>To start using it, you need to &quot;subscribe&quot; to begin logging, and then &quot;unsubscribe&quot; when you're done. It's designed to write each event immediately to disk, providing a reliable history for review and debugging, unlike other services that might hold information in memory.</p>
<p>The service provides functions for logging different types of strategy actions:</p>
<ul>
<li><strong>cancelScheduled:</strong> Records when a scheduled order is canceled.</li>
<li><strong>closePending:</strong> Logs the closure of a pending order.</li>
<li><strong>partialProfit/partialLoss:</strong> Tracks partial position closures that result in profit or loss.</li>
<li><strong>trailingStop/trailingTake:</strong> Records adjustments to trailing stop-loss or take-profit levels.</li>
<li><strong>breakeven:</strong> Logs when the stop-loss is moved to the entry price.</li>
<li><strong>activateScheduled:</strong> Records when a scheduled signal is activated early.</li>
<li><strong>averageBuy:</strong> Tracks entries when implementing a dollar-cost averaging (DCA) strategy.</li>
</ul>
<p>Each of these functions takes information about the trade, like the symbol being traded, the current price, and details about the strategy itself. The “subscribe” and “unsubscribe” methods manage the logging process, ensuring it’s turned on and off appropriately.</p>
<a id="class-strategymarkdownservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class StrategyMarkdownService<a href="#class-strategymarkdownservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This service helps you gather and analyze data about your trading strategies, particularly useful for backtesting. Think of it as a collector for events like canceling orders, closing positions, and setting stop losses. Instead of writing each event to a file immediately, it holds them temporarily, allowing for more efficient batch reporting.</p>
<p>To start using it, you need to &quot;subscribe&quot; to begin collecting events. Once subscribed, the service automatically records various actions your strategy takes. You can then retrieve aggregated statistics, generate nicely formatted markdown reports, or save those reports to files. When you're finished, you “unsubscribe” to stop collecting data and clean up the accumulated information.</p>
<p>The service is designed to avoid performance bottlenecks by storing data in memory, using a clever caching system for reports specific to each symbol and strategy. You can customize the reports by choosing which details to include. It also provides options to clear data – either selectively for a specific strategy or a complete wipe.</p>
<a id="class-strategycoreservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class StrategyCoreService<a href="#class-strategycoreservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This service acts as a central hub for managing strategy operations, especially during backtesting or live trading. It combines the functionality of several other services to inject important information like the trading symbol, timestamp, and backtest status into the strategy execution.</p>
<p>Think of it as a wrapper around your strategy logic, providing extra context and ensuring everything runs smoothly.</p>
<p>Here's a breakdown of what it does:</p>
<ul>
<li><strong>Validation:</strong> It checks if a strategy and its related configurations are valid, avoiding repeated checks by remembering previous validations.</li>
<li><strong>Signal Management:</strong> It can retrieve the current pending and scheduled signals for a symbol, which is helpful for monitoring things like take-profit (TP) and stop-loss (SL) levels.</li>
<li><strong>State Checks:</strong> You can use it to quickly determine if a strategy is stopped or has reached breakeven.</li>
<li><strong>Tick and Backtest Execution:</strong> It handles the core operations of running a strategy’s <code>tick()</code> or <code>backtest()</code> function, making sure it has the necessary data.</li>
<li><strong>Control Functions:</strong> It offers actions like stopping a strategy, cancelling scheduled signals, closing pending signals (without stopping the strategy entirely), and disposing of strategy instances.</li>
<li><strong>Partial Position Management:</strong> Functions exist to execute partial closes based on profit or loss levels and adjust trailing stop-loss and take-profit distances.</li>
<li><strong>Early Activation:</strong> It allows for early activation of scheduled signals.</li>
<li><strong>Averaging:</strong> Provides a way to add new entries to a position to average the buy price.</li>
</ul>
<p>Essentially, this service simplifies the interaction with strategy logic by providing convenient functions and handling common tasks. It’s particularly useful for automating backtesting and ensuring a consistent environment for your strategies.</p>
<a id="class-strategyconnectionservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class StrategyConnectionService<a href="#class-strategyconnectionservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The <code>StrategyConnectionService</code> acts as a central hub for managing and executing trading strategies within the backtest-kit framework. Think of it as a smart router that directs requests to the correct strategy based on the symbol, strategy name, and exchange details.</p>
<p>It intelligently handles strategy operations like getting signals, checking for breakeven points, stopping strategies, and disposing of resources. Importantly, it keeps track of which strategies are running and caches them to improve performance.</p>
<p>When you need to run a live tick or a backtest, this service ensures the right strategy gets the data it needs and that everything is handled correctly. It’s also responsible for canceling scheduled signals and closing positions, always making sure that these actions are done within the proper context.</p>
<p>It offers methods for:</p>
<ul>
<li><strong>Getting Strategies:</strong>  Retrieves the correct strategy implementation, creating it only once and reusing it for efficiency.</li>
<li><strong>Signal Management:</strong>  Fetches pending and scheduled signals for monitoring and action.</li>
<li><strong>Breakeven &amp; Stopped State:</strong> Checks conditions related to breakeven and whether a strategy should be stopped.</li>
<li><strong>Executing Trades:</strong>  Handles both live <code>tick()</code> and backtesting <code>backtest()</code> operations.</li>
<li><strong>Control Operations:</strong>  Allows you to stop, dispose, and clear strategies.</li>
<li><strong>Partial and Trailing Adjustments:</strong>  Manages partial profit/loss closures and trailing stop/take adjustments.</li>
<li><strong>Early Activation:</strong>  Allows for early activation of scheduled signals.</li>
<li><strong>Average Buy:</strong>  Adds new entries to a DCA strategy.</li>
</ul>
<p>Essentially, <code>StrategyConnectionService</code> keeps things organized and optimized so that your strategies run smoothly and efficiently.</p>
<a id="class-storageliveadapter" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class StorageLiveAdapter<a href="#class-storageliveadapter" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The <code>StorageLiveAdapter</code> is a flexible component for managing trading signals, allowing you to easily switch between different storage methods. It acts as a bridge, providing a consistent interface while letting you choose how your signals are actually stored – whether it's on disk, in memory, or even as temporary &quot;dummy&quot; data for testing.</p>
<p>You can swap out the underlying storage mechanism by specifying a constructor for a particular storage utility. There are several pre-built adapters to choose from, including one that uses persistent storage (the default), one that stores data only in memory, and a dummy adapter which is great for testing without actually saving any data.</p>
<p>The adapter handles events like signals being opened, closed, scheduled, or cancelled, passing these on to the selected storage implementation. You can also retrieve signals by their ID or list all signals currently stored. Essentially, it gives you control over where and how your trading signals are kept, with a simple way to change that behavior.</p>
<a id="class-storagebacktestadapter" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class StorageBacktestAdapter<a href="#class-storagebacktestadapter" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The StorageBacktestAdapter acts as a flexible middleman for managing how your backtest data is stored. It allows you to easily switch between different storage methods without changing much of your core backtesting logic.</p>
<p>You can choose to persist your data to a file using the default persistent storage, keep everything in memory for fast but temporary results, or use a dummy adapter that essentially ignores all writes—useful for testing.</p>
<p>The adapter handles events like signals being opened, closed, scheduled, or cancelled, and it provides ways to find signals by their ID and list all stored signals.  You control which storage method is used by swapping out the underlying storage implementation, making it simple to adapt to different testing needs.</p>
<a id="class-storageadapter" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class StorageAdapter<a href="#class-storageadapter" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The StorageAdapter is the central place where your trading signals are kept, whether they’re from a backtest or live data. It automatically updates itself as new signals are generated and ensures that you can easily access them all in one spot.</p>
<p>You can think of <code>enable</code> as turning on the signal storage – it subscribes to the signal sources to receive updates. The <code>disable</code> function does the opposite, cleaning up and unsubscribing when you no longer need it, and it’s perfectly safe to call it multiple times.</p>
<p>Need to find a specific signal? The <code>findSignalById</code> method lets you locate a signal using its unique ID. And if you need to see all the signals from a backtest or live source, <code>listSignalBacktest</code> and <code>listSignalLive</code> provide those lists.</p>
<a id="class-sizingvalidationservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class SizingValidationService<a href="#class-sizingvalidationservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This service helps you keep track of your position sizing strategies and makes sure they're correctly set up. Think of it as a central place to register all your sizing approaches, like fixed percentages or Kelly Criterion methods. Before you use a sizing strategy, you can use this service to confirm it exists and is properly configured, preventing potential errors.  It even remembers its validation results, making the process quicker each time. You can add new sizing strategies using <code>addSizing</code>, double-check their existence and methods with <code>validate</code>, and get a complete list of registered strategies with <code>list</code>. The service also utilizes a logger service and an internal map to manage the sizing information efficiently.</p>
<a id="class-sizingschemaservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class SizingSchemaService<a href="#class-sizingschemaservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This service helps you keep track of different sizing strategies for your trading backtests. It's like a central library where you can store and manage your sizing rules. The service uses a secure and organized way to store these sizing strategies, ensuring they are typed correctly.</p>
<p>You can add new sizing strategies using <code>register</code>, update existing ones with <code>override</code>, and easily retrieve a specific strategy using its name with <code>get</code>. Before a sizing strategy is added, it's checked to make sure it has all the necessary parts and is structured correctly – this is done with the <code>validateShallow</code> functionality.  The service relies on a logging system to track what's happening and a tool registry for managing the sizing strategies themselves.</p>
<a id="class-sizingglobalservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class SizingGlobalService<a href="#class-sizingglobalservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This service, SizingGlobalService, handles the calculations needed to determine how much of an asset to trade. Think of it as the engine that figures out your position sizes based on your risk tolerance and trading strategy. It relies on other services to do the heavy lifting – one for connecting to data sources and another for validating the sizing rules.  You generally won’t interact with this directly, as it's used behind the scenes by the core backtesting process and the public trading API. The <code>calculate</code> function is the key method, taking in parameters like risk limits and a context to figure out the right size for each trade.</p>
<a id="class-sizingconnectionservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class SizingConnectionService<a href="#class-sizingconnectionservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This service helps manage how position sizes are calculated within your trading strategies. It acts as a central hub, directing sizing requests to the correct implementation based on a name you provide.</p>
<p>Think of it as a smart router for sizing calculations.</p>
<p>It remembers which sizing methods it's already set up, so it doesn't have to recreate them every time you need them - making things faster and more efficient.</p>
<p>You'll use the <code>sizingName</code> to tell it which sizing method to use, and it handles the rest, taking into account risk management parameters and various sizing approaches like fixed percentage, Kelly Criterion, or ATR-based sizing. If your strategy doesn’t have any sizing configuration, the <code>sizingName</code> will be an empty string.</p>
<a id="class-scheduleutils" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class ScheduleUtils<a href="#class-scheduleutils" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This class, <code>ScheduleUtils</code>, is designed to help you keep track of and analyze scheduled trading signals. It acts as a central point for accessing information about signals waiting to be executed and how long they've been waiting. Think of it as a tool to monitor the health and performance of your scheduling system.</p>
<p>You can use it to gather statistics on scheduled signals for a particular trading symbol and strategy, or to create detailed markdown reports summarizing signal activity. The reports can even be saved directly to a file. Because it's implemented as a singleton, it’s easy to use throughout your backtesting framework. This makes it simple to understand how your scheduled signals are behaving and identify potential bottlenecks or issues.</p>
<a id="class-schedulereportservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class ScheduleReportService<a href="#class-schedulereportservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This service helps you keep track of how your scheduled signals are performing by automatically logging key events to a database. It listens for signals being scheduled, opened (meaning they're about to be executed), and cancelled.</p>
<p>The service calculates how long each signal takes from scheduling to execution or cancellation, giving you insights into potential delays. It prevents accidental duplicate subscriptions, ensuring the logging process remains reliable. You can easily start and stop the logging by subscribing and unsubscribing, and the unsubscribe function makes sure everything is cleaned up properly. It utilizes a logger to provide helpful debug information along the way.</p>
<a id="class-schedulemarkdownservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class ScheduleMarkdownService<a href="#class-schedulemarkdownservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The ScheduleMarkdownService is designed to automatically create reports about scheduled signals for your trading strategies. It keeps track of when signals are scheduled and cancelled, collecting all the details. These details are then compiled into easy-to-read markdown tables, along with helpful statistics like cancellation rates and average wait times.</p>
<p>It's responsible for listening for these events and organizing the information for each strategy. The reports themselves are saved as markdown files in a designated log directory.</p>
<p>You can retrieve the collected statistics or generate a full report for a specific symbol and strategy. The service also offers a convenient way to clear out the accumulated data when it's no longer needed, either for a specific setup or a complete cleanup. It's all about making it simple to monitor and understand how your strategies are performing in terms of signal scheduling.</p>
<a id="class-riskvalidationservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class RiskValidationService<a href="#class-riskvalidationservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This service helps you keep track of and verify your risk management setups. Think of it as a central place to register all your risk profiles—those rules and configurations you use to manage risk—and double-check that they're actually there before you try to use them. To make things efficient, it remembers previous validation checks so it doesn't have to repeat the process unnecessarily.</p>
<p>You can add new risk profiles using <code>addRisk</code>, confirm a profile exists with <code>validate</code>, and get a complete list of all registered profiles with <code>list</code>. This service keeps your risk management consistent and reliable by ensuring everything's properly configured.</p>
<a id="class-riskutils" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class RiskUtils<a href="#class-riskutils" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The RiskUtils class helps you analyze and understand risk rejections within your backtesting framework. It acts like a central hub for gathering information about rejected trades, providing statistics and reports to help you identify potential issues.</p>
<p>You can use it to get summarized data like the total number of rejections, broken down by the specific asset and trading strategy. It also allows you to generate detailed markdown reports that list each rejected trade with information like the symbol, strategy, position, price, and reason for rejection.</p>
<p>Finally, this class makes it easy to save those reports directly to files, organized by symbol and strategy, so you can review them later. Think of it as a tool for understanding <em>why</em> your strategies are being rejected and what you can do to improve them.</p>
<a id="class-riskschemaservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class RiskSchemaService<a href="#class-riskschemaservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The RiskSchemaService helps you keep track of your risk schemas in a safe and organized way. It uses a special registry to store these schemas, making sure they are typed correctly. You can add new risk profiles using the <code>addRisk()</code> method (through the <code>register</code> property) and easily find them later by their names with the <code>get()</code> method.</p>
<p>Before adding a new risk schema, the service does a quick check with <code>validateShallow</code> to make sure it has all the necessary parts and they are of the expected types. If you need to update an existing risk profile, the <code>override</code> method allows you to make partial changes without replacing the whole schema. The <code>loggerService</code> property provides access to logging functionalities for debugging and monitoring.</p>
<a id="class-riskreportservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class RiskReportService<a href="#class-riskreportservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This service helps you keep track of when your risk management system rejects trading signals. It acts like a recorder, capturing details about each rejected signal – why it was rejected and what the signal looked like.</p>
<p>You can think of it as a way to audit your risk controls and understand why certain trades aren't happening.</p>
<p>The service listens for rejection events and safely stores them in a database. To use it, you subscribe to receive these events; when you're finished, you unsubscribe. It's designed to prevent accidental double-subscription, ensuring things run smoothly.</p>
<a id="class-riskmarkdownservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class RiskMarkdownService<a href="#class-riskmarkdownservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The RiskMarkdownService helps you create reports detailing rejected trades due to risk management rules. It listens for risk rejection events, keeps track of these rejections for each symbol and strategy you're using, and then turns that information into nicely formatted Markdown tables. You can get overall statistics, like the total number of rejections, broken down by symbol and strategy, and easily save those reports to your disk.</p>
<p>The service uses a storage system to keep everything organized, ensuring data for each symbol, strategy, exchange, frame, and backtest is kept separate. You subscribe to receive rejection events, and the service handles the details of accumulating and reporting on them.  There are functions to retrieve data, generate reports, save them to disk, and even clear out the accumulated rejection data when you need to start fresh.  Essentially, it automates the process of documenting and analyzing risk rejections in your trading system.</p>
<a id="class-riskglobalservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class RiskGlobalService<a href="#class-riskglobalservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This service is responsible for managing and validating risk limits within the trading system. Think of it as a central authority that checks if trades are allowed based on pre-defined rules. It works closely with other services to handle risk connections, validations, and logging.</p>
<p>It keeps track of open trades (signals) and makes sure they adhere to the established risk parameters. The <code>validate</code> function helps confirm risk configurations, avoiding unnecessary checks.</p>
<p>You can use it to verify if a trade signal should proceed, register new trades, remove closed trades, and even clear out all risk-related data when needed, providing flexibility for different scenarios and testing environments. It provides methods to add, remove and check signals.</p>
<a id="class-riskconnectionservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class RiskConnectionService<a href="#class-riskconnectionservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The RiskConnectionService acts as a central hub for managing risk checks within your trading framework. It intelligently directs risk-related operations to the correct risk management component based on a specified risk name.</p>
<p>Think of it as a router – when your strategy needs to check if a trade is permissible based on risk limits, this service figures out which specific risk rules to apply. To avoid unnecessary work, it cleverly caches these risk components, so repeated checks for the same exchange and timeframe are much faster.</p>
<p>You'll use it to validate signals against portfolio limits, track opened and closed positions within the risk system, and even clear out cached risk data when needed. The service handles things like validating drawdown, exposure, position counts, and daily loss limits, ensuring your trading stays within defined boundaries.  Strategies without risk configurations will use an empty string for the riskName.</p>
<a id="class-reportutils" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class ReportUtils<a href="#class-reportutils" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>ReportUtils helps you control which parts of the backtest-kit framework, like backtests, live trading, or performance analysis, generate detailed logs. Think of it as a way to turn logging on or off for specific areas.</p>
<p>You can use the <code>enable</code> function to start logging for the services you're interested in; it will begin writing data to JSONL files and send you back a function you <em>must</em> use to stop the logging later, otherwise your application might run into memory problems.</p>
<p>If you just want to stop logging for certain services without affecting others, <code>disable</code> lets you do that. It immediately stops the logging process for the services you specify.</p>
<a id="class-reportbase" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class ReportBase<a href="#class-reportbase" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The <code>ReportBase</code> class helps you reliably log trading events to files for later analysis. It creates a single JSONL file for each report type, appending new events as they happen. It's designed to handle a large volume of data, with built-in safeguards like a 15-second timeout for writing to prevent issues and automatic directory creation for organization.</p>
<p>You can filter these log files based on criteria like the trading symbol, strategy used, exchange, timeframe, signal ID, or the walker involved, making it easy to focus on specific aspects of your backtesting.</p>
<p>The class manages the file writing process for you; you simply provide the data you want to log, along with any relevant options. Internally, it uses a stream-based approach to efficiently write data and includes mechanisms to handle situations where the write buffer is full. Importantly, the initialization process happens only once, ensuring consistency and preventing unnecessary setup.</p>
<a id="class-reportadapter" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class ReportAdapter<a href="#class-reportadapter" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The ReportAdapter helps manage and store your backtesting data consistently. Think of it as a flexible system for directing event logs to different storage locations. It uses a pattern that allows you to easily swap out how data is stored without changing much of your core code.</p>
<p>It remembers which storage instances you're using, so you don’t create new ones every time, improving efficiency. The default storage option writes data to JSONL files.</p>
<p>You can customize the way data is saved by setting a new storage constructor, or even use a &quot;dummy&quot; adapter that simply throws away any data you try to write – useful for testing or preventing accidental logging. The system only starts storing data when you actually write something, which avoids unnecessary setup.</p>
<a id="class-positionsizeutils" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class PositionSizeUtils<a href="#class-positionsizeutils" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This class offers helpful tools for figuring out how much of an asset to trade, a critical part of any trading strategy. It provides pre-built methods for several common position sizing techniques, like using a fixed percentage of your account, applying the Kelly Criterion (which aims to maximize growth), and basing the size on the Average True Range (ATR) to account for volatility.</p>
<p>Each method includes built-in checks to ensure you're using the right approach and providing the necessary information. Think of it as a set of ready-to-use calculators that simplify the often-complex task of determining appropriate position sizes. You just need to supply the relevant details like your account balance, the asset’s price, and any volatility measures.</p>
<a id="class-persiststorageutils" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class PersistStorageUtils<a href="#class-persiststorageutils" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This class provides tools for saving and loading signal data so your backtesting or live trading system doesn't lose information when it stops running. It intelligently manages where and how your signal data is stored, keeping things organized.</p>
<p>The system is designed to be robust; it uses special techniques to ensure data isn't corrupted even if your system crashes unexpectedly. It allows you to choose different ways to store your data, and you can even plug in your own custom methods if you need something specific.</p>
<p>Each signal is stored as a separate file, making it easy to manage individual signals. When you need to load your data, it reads all the signals from storage. When changes are made to the signals, it immediately saves them back to disk. You can even temporarily disable persistence to simulate a non-persistent environment for testing.</p>
<a id="class-persistsignalutils" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class PersistSignalUtils<a href="#class-persistsignalutils" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The <code>PersistSignalUtils</code> class helps manage how signal data is stored and retrieved, especially for trading strategies. It automatically handles creating storage areas for each strategy and allows for customization using different storage adapters.</p>
<p>The class ensures a safe and reliable way to save and load signal states, even if the system crashes during the process. This is crucial for maintaining the integrity of your trading strategy's progress.</p>
<p>You can choose different persistence methods like using a standard JSON format or a dummy adapter that simply ignores writes for testing purposes. It also provides functions to read previously saved signals and write new signals, all designed to be done securely. The <code>readSignalData</code> method is used to bring back a strategy's saved state, while <code>writeSignalData</code> ensures that changes are saved correctly.</p>
<a id="class-persistscheduleutils" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class PersistScheduleUtils<a href="#class-persistscheduleutils" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This class provides tools for safely saving and loading scheduled signals for your trading strategies. It automatically handles storage for each strategy, ensuring that your data is consistent even if your application encounters issues.</p>
<p>You can customize how this data is stored by registering different persistence adapters, or easily switch back to the default JSON-based storage. There’s even a dummy adapter available if you just want to test without actually saving anything to disk.</p>
<p>When a strategy needs to restore its previously saved scheduled signals, the <code>readScheduleData</code> method retrieves them.  And when a strategy needs to save its signals, <code>writeScheduleData</code> does so in a way that protects against data loss due to crashes. This is especially helpful for <code>ClientStrategy</code> in live trading scenarios.</p>
<a id="class-persistriskutils" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class PersistRiskUtils<a href="#class-persistriskutils" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This class, PersistRiskUtils, is designed to safely manage and store information about active trading positions, particularly for different risk profiles. It’s a helper class used by ClientRisk to keep track of what's happening during live trading.</p>
<p>The class uses a clever system where it remembers storage instances for each risk profile to make things efficient. You can even customize how data is stored using different adapters.</p>
<p>When ClientRisk needs to start up or update position data, it relies on <code>readPositionData</code> to load existing positions and <code>writePositionData</code> to save the latest changes. The <code>writePositionData</code> function is designed to be particularly safe, using special techniques to prevent data loss even if something unexpected happens, like a system crash.</p>
<p>To make things even more flexible, it allows you to plug in your own custom storage solutions through <code>usePersistRiskAdapter</code>. If you just want to test things out or disable persistence entirely, you can switch to the default JSON adapter or a &quot;dummy&quot; adapter that ignores all write requests.</p>
<a id="class-persistpartialutils" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class PersistPartialUtils<a href="#class-persistpartialutils" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This class helps manage how your trading strategy remembers its progress, specifically its partial profit and loss levels. It keeps track of this information separately for each symbol and strategy combination, making sure the data is stored reliably even if something unexpected happens.</p>
<p>You can customize how this data is stored by plugging in different adapters, or you can easily switch back to the default JSON storage. There’s even a dummy adapter available that simply ignores all write attempts, which is useful for testing.</p>
<p>The <code>readPartialData</code> function retrieves previously saved partial data, while <code>writePartialData</code> safely saves the current state to disk, preventing data loss from crashes. This is a core component used internally by <code>ClientPartial</code> to maintain your strategy's state during live trading.</p>
<a id="class-persistnotificationutils" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class PersistNotificationUtils<a href="#class-persistnotificationutils" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This class provides tools for reliably saving and loading notification data. Think of it as the behind-the-scenes manager that makes sure your notifications stick around even if things go wrong. It cleverly handles storing each notification as a separate file, using its unique ID as the filename.</p>
<p>It has a built-in mechanism to use different ways of storing the data, allowing for customization, and even a &quot;dummy&quot; mode for testing where changes aren't actually saved.  The <code>readNotificationData</code> function retrieves all saved notifications, while <code>writeNotificationData</code> takes care of safely writing changes to disk, ensuring data isn't lost.  This system is used by other parts of the framework—NotificationPersistLiveUtils and NotificationPersistBacktestUtils—to manage notification persistence. You can even plug in your own custom storage methods if needed.</p>
<a id="class-persistcandleutils" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class PersistCandleUtils<a href="#class-persistcandleutils" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This class helps manage cached candle data, storing each candle as a separate file for efficient access. It’s designed to ensure data integrity, only returning cached data if the entire requested set of candles is present. If even one candle is missing, the cache is considered invalid.</p>
<p>The class utilizes a factory to handle the actual data storage and provides methods to read and write candle data to the cache, guaranteeing atomic operations. It's used internally by the ClientExchange to streamline candle data handling.</p>
<p>You can customize how the data is persisted by registering different adapters, or switch between using standard JSON files, or even a dummy adapter that simply ignores write requests for testing purposes. The read function verifies that all requested candles are available before returning them, maintaining data consistency.</p>
<a id="class-persistbreakevenutils" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class PersistBreakevenUtils<a href="#class-persistbreakevenutils" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This class helps manage and save your breakeven data, which is essential for tracking and restoring trading strategies. Think of it as a safe place to store information about your breakeven points for different symbols and strategies. It automatically creates folders and files to hold this data, ensuring everything is neatly organized.</p>
<p>The system uses a special trick to make sure the saving and loading process is reliable—it writes files in a way that prevents data loss. It also remembers previously created storage instances, making things faster when you need to access or update your data.</p>
<p>You can even customize how your data is stored; the class allows you to use different adapters, or even switch to a &quot;dummy&quot; adapter that simply ignores all write operations for testing purposes. This offers flexibility for various scenarios.</p>
<a id="class-persistbase" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class PersistBase<a href="#class-persistbase" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>PersistBase provides a foundation for storing and retrieving data to files, ensuring that writes are handled safely and reliably. It's designed to work with named entities, keeping them organized within a designated directory.</p>
<p>The system automatically validates the integrity of stored files and cleans up any that are corrupted.  You can efficiently loop through all the entity IDs that are currently stored using an asynchronous generator.</p>
<p>The <code>waitForInit</code> method helps to set up the storage directory and check for any existing issues when the system first starts up.  The atomic write feature ensures that data isn't lost or corrupted even if interruptions occur during the saving process.  The base class handles file path calculations and includes retry mechanisms for deleting files if needed.</p>
<a id="class-performancereportservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class PerformanceReportService<a href="#class-performancereportservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The PerformanceReportService helps you keep track of how your trading strategies are performing, specifically pinpointing areas where they might be slow or inefficient. It essentially listens for timing events during your strategy's execution and records them.</p>
<p>Think of it as a detective for your code, collecting clues about where time is being spent. These clues are then stored in a database so you can analyze them later.</p>
<p>You can easily tell it to start listening for these events, and it will send you back a way to stop listening when you’re done. It's designed to avoid accidentally subscribing multiple times, which could lead to problems. It uses a logger to output debugging information, too.</p>
<a id="class-performancemarkdownservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class PerformanceMarkdownService<a href="#class-performancemarkdownservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This service helps you keep track of how your trading strategies are performing. It listens for performance data, organizes it by strategy, and calculates key statistics like average, minimum, and maximum values. It also creates detailed reports in markdown format, which includes an analysis of potential bottlenecks in your strategy’s performance. These reports are saved automatically to a designated log directory, making it easy to review and identify areas for improvement.</p>
<p>You can subscribe to receive performance updates or unsubscribe when you no longer need them. There's a method to retrieve accumulated performance statistics for a specific combination of symbol, strategy, exchange, timeframe, and backtest scenario.  You can also request a full performance report or clear the accumulated data if you need to start fresh. The system ensures that data is isolated per unique combination of symbol, strategy, exchange, timeframe and backtest.</p>
<a id="class-performance" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class Performance<a href="#class-performance" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The Performance class helps you understand how well your trading strategies are performing. It provides tools to collect and analyze performance data, making it easier to identify areas for improvement.</p>
<p>You can use <code>getData</code> to get a detailed breakdown of performance metrics, like how long different operations take and how much they vary. This gives you a clear picture of where your strategy spends its time.</p>
<p>To communicate your findings effectively, <code>getReport</code> generates user-friendly markdown reports that visualize performance trends and highlight potential bottlenecks.</p>
<p>Finally, <code>dump</code> allows you to save these reports directly to your file system, making it simple to share your analysis or track performance over time. You can customize the output path or choose specific columns to include in the report.</p>
<a id="class-partialutils" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class PartialUtils<a href="#class-partialutils" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This class helps you analyze and report on partial profit and loss data from your backtesting or live trading. It’s like having a central hub for pulling together all those little profit and loss events that happen during a trade.</p>
<p>You can use it to get overall statistics like total profit/loss event counts. It can also create nicely formatted markdown reports, showing you a table of all the partial profit and loss events for a specific trading strategy and symbol.</p>
<p>Need to save those reports? This class can also generate the report and dump it to a file on your disk, automatically creating the necessary directories. Think of it as an easy way to keep track of how your strategies are performing, step by step.</p>
<a id="class-partialreportservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class PartialReportService<a href="#class-partialreportservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The PartialReportService is designed to keep track of every time a position is partially exited, whether it's a profit or a loss. It acts like a record-keeper, capturing details like the price and level at which each partial exit happened.</p>
<p>To get started, you'll need to &quot;subscribe&quot; to the service, which connects it to the streams of partial profit and loss events.  This subscription is designed to prevent accidental double-subscriptions.</p>
<p>The service then diligently logs these partial exit events, storing the information persistently. If you're done tracking these partial closures, you can &quot;unsubscribe&quot; to stop the service from listening. A logger service is included for debugging purposes, and the <code>tickProfit</code> and <code>tickLoss</code> properties handle processing the specific event types.</p>
<a id="class-partialmarkdownservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class PartialMarkdownService<a href="#class-partialmarkdownservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This service helps you create reports detailing your partial profits and losses during trading. It listens for profit and loss signals, keeping track of them for each symbol and strategy you’re using.</p>
<p>The service organizes this data and turns it into readable markdown tables, offering statistics like the total number of profit and loss events. It’s designed to save these reports to your disk, specifically in a directory structure like <code>dump/partial/{symbol}_{strategyName}.md</code>, making it easy to review your trading performance.</p>
<p>You can subscribe to receive these signals and unsubscribe when you no longer need them. The <code>getData</code> method allows you to retrieve the accumulated statistics, while <code>getReport</code> generates the markdown report itself. You can also use the <code>dump</code> function to directly save these reports to disk, and <code>clear</code> to wipe the stored data if needed, either for a specific combination or everything at once.</p>
<a id="class-partialglobalservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class PartialGlobalService<a href="#class-partialglobalservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This service manages the tracking of partial profits and losses within the trading framework. Think of it as a central hub for these operations, ensuring everything is logged and handled consistently. It's injected into the core trading strategy, providing a single point of access for partial tracking and allowing for centralized monitoring.</p>
<p>It relies on other services to validate the strategy, risk, exchange, and frame configurations involved. The core functionality revolves around the <code>profit</code>, <code>loss</code>, and <code>clear</code> methods – these log activity and then pass the actual processing to a connection service. This layered design keeps the main strategy separate from the underlying connection mechanics, while providing a clear audit trail of partial profit/loss events.</p>
<a id="class-partialconnectionservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class PartialConnectionService<a href="#class-partialconnectionservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The PartialConnectionService helps track profit and loss for individual trading signals. It’s designed to efficiently manage these tracking details, creating and storing information about each signal's performance.</p>
<p>Think of it as a smart factory – whenever a signal is encountered, it either provides an existing tracker or creates a new one, ensuring that each signal has its own dedicated record.  It remembers these trackers so you don't have to constantly create them.</p>
<p>It keeps things organized by linking each tracker to a specific signal ID and whether it's a backtest or live trade. This system also handles cleanup, automatically removing trackers when signals are no longer needed, preventing unnecessary memory usage.</p>
<p>The service provides methods for recording profits, losses, and clearing the records when a signal is closed, each delegating the actual work to the individual trackers.  You can find these trackers using <code>getPartial</code>, and the service automatically handles ensuring they are properly set up. It uses a logger to keep track of events and works closely with other parts of the trading system.</p>
<a id="class-notificationliveadapter" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class NotificationLiveAdapter<a href="#class-notificationliveadapter" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The <code>NotificationLiveAdapter</code> is designed to provide a flexible way to handle notifications during live trading. It acts as a central hub, allowing you to easily swap out different notification methods without changing the core trading logic.</p>
<p>Think of it like a universal translator for notifications – it takes signals from your trading system and sends them to wherever you want them to go, whether that's a simple memory store, a file on your disk, or some other custom system.</p>
<p>Initially, it uses an in-memory storage as its default, but you can switch it to persistent storage (saving notifications to disk) or a &quot;dummy&quot; mode which simply ignores notifications entirely for testing purposes.</p>
<p>The adapter provides methods for handling various events, such as signals, partial profits, losses, strategy commits, risks, and errors – essentially, anything that needs to be reported. You can also retrieve all stored notifications or clear them completely. The <code>useNotificationAdapter</code> method lets you completely customize which notification method is used going forward.</p>
<a id="class-notificationbacktestadapter" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class NotificationBacktestAdapter<a href="#class-notificationbacktestadapter" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This class provides a flexible way to manage notifications during backtesting. It acts as a central point for handling different types of events like signals, profit updates, errors, and more.</p>
<p>You can easily swap out how these notifications are handled – whether you want to store them in memory, persistently on disk, or simply ignore them for testing purposes.  The <code>useMemory</code>, <code>usePersist</code>, and <code>useDummy</code> methods make switching between these different notification strategies simple.</p>
<p>Internally, it uses a specific &quot;notification utils&quot; component to actually process the notifications, and you can even customize this component if you need something beyond the built-in options.  Each of the <code>handle...</code> methods simply passes the data to this underlying component, allowing for a consistent way of dealing with events regardless of how they're stored or handled. The <code>getData</code> and <code>clear</code> methods give you access to and control over the stored notifications, depending on which adapter you're currently using.</p>
<a id="class-notificationadapter" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class NotificationAdapter<a href="#class-notificationadapter" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The NotificationAdapter is a central component for handling notifications during backtesting and live trading. It automatically keeps track of notifications by listening for updates, providing a single place to access them whether they're from a backtest or a live trading session. To prevent unwanted duplicate notifications, it uses a clever “singleshot” feature that ensures you only subscribe to updates once.</p>
<p>You can easily turn notification tracking on and off using the <code>enable</code> and <code>disable</code> functions. If you need to retrieve all the notifications, the <code>getData</code> function lets you grab them, specifying whether you want the backtest or live notifications. And when you’re finished, the <code>clear</code> function provides a simple way to remove all notifications for either backtest or live storage.</p>
<a id="class-markdownutils" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class MarkdownUtils<a href="#class-markdownutils" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This class helps you control which parts of the backtest-kit framework generate markdown reports. Think of it as a central switchboard for turning reports on and off for things like backtests, live trading sessions, performance analysis, and more.</p>
<p>The <code>enable</code> function lets you selectively turn on markdown reporting for certain areas. It sets up the system to gather data and create reports, but crucially, it gives you a function to later turn <em>everything</em> you enabled back off, preventing memory problems.  Make sure to use that cleanup function when you’re done!</p>
<p>The <code>disable</code> function is for shutting down markdown reporting for specific parts of the system.  It immediately stops the report generation process and frees up resources, allowing you to control reporting on a per-service basis.  This doesn’t require a separate cleanup function because the changes happen instantly.</p>
<a id="class-markdownfolderbase" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class MarkdownFolderBase<a href="#class-markdownfolderbase" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This adapter lets you create a well-organized set of markdown reports, with each report saved as its own individual file. It’s designed for situations where you want easy access to each report’s content, like for manual review or creating a structured directory of results.</p>
<p>The adapter automatically creates the necessary directories based on the file path you specify.  Each report's file name includes information about your backtest, making it easy to identify.</p>
<p>The <code>waitForInit</code> method doesn’t actually <em>do</em> anything – it’s just there because the interface requires it, as this adapter doesn’t need any special setup.</p>
<p>The core function is <code>dump</code>, which handles writing the markdown content to the designated file and creating the directory structure if needed. You provide the content to be written and options that define the file path and name.</p>
<a id="class-markdownfilebase" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class MarkdownFileBase<a href="#class-markdownfilebase" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This component handles writing markdown reports in a structured, JSONL format to a single file for each report type. Think of it as a way to centralize all your trading reports – like performance summaries, order books, or market visualizations – into a standardized, easily processable file. It’s designed to write data incrementally, which is helpful for large reports, and includes built-in safeguards to prevent issues like slow writing or stalled processes.</p>
<p>The <code>MarkdownFileBase</code> creates a dedicated file within a <code>dump/markdown</code> directory (it'll create this directory if it doesn't exist) and each line within that file is a JSON object containing the markdown data, along with useful metadata like the trading symbol, strategy name, exchange, timeframe, and signal ID. This metadata makes it much easier to filter and analyze your reports later.</p>
<p>You don’t have to worry about managing the file writing process directly; this component takes care of it, including creating the file, writing the data, and handling potential errors. There's even a timeout to ensure writing doesn’t get stuck.</p>
<p>To use it, you essentially provide the markdown content and some optional metadata, and the component handles writing it to the appropriate JSONL file. The <code>waitForInit</code> method ensures the file and stream are properly set up, and subsequent calls are safely ignored thanks to a built-in mechanism.</p>
<a id="class-markdownadapter" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class MarkdownAdapter<a href="#class-markdownadapter" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The MarkdownAdapter helps you manage how your markdown data is stored, offering flexibility and efficiency. It allows you to easily switch between different storage methods, like saving each piece of data in its own file or appending them to a single JSONL file.</p>
<p>It intelligently caches storage instances to ensure you're not creating unnecessary duplicates, which is especially helpful for larger projects. You can customize the storage mechanism using <code>useMarkdownAdapter</code> to set a specific storage constructor.</p>
<p>Convenience methods like <code>useMd</code>, <code>useJsonl</code>, and <code>useDummy</code> let you quickly switch between the default folder-based storage, a JSONL append-based storage, and a dummy adapter that effectively ignores writes, respectively. The adapter automatically creates the necessary storage when you first write data.</p>
<a id="class-loggerservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class LoggerService<a href="#class-loggerservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The LoggerService helps ensure consistent logging throughout your backtesting framework by automatically adding helpful context to your messages. It lets you provide your own logging mechanism, but automatically includes details like the strategy, exchange, and frame being used, along with information about the symbol, time, and whether it's a backtest. If you don't specify a logger, it defaults to a do-nothing logger.</p>
<p>You can customize the logging behavior using the <code>setLogger</code> method to use your preferred logging library.  The <code>log</code>, <code>debug</code>, <code>info</code>, and <code>warn</code> methods provide different severity levels for your messages, all with automatic context. Internally, it manages context services and a common logger for organized operation.</p>
<a id="class-liveutils" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class LiveUtils<a href="#class-liveutils" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This class provides tools for running and managing live trading sessions. Think of it as a helper for your trading strategies when they're actually running in a live environment. It handles things like automatically restarting if something crashes and keeps track of what's happening.</p>
<p>You can start a live trading session for a specific symbol and strategy using the <code>run</code> method, which acts like a never-ending stream of updates.  If you just want the process to run in the background, performing actions without reporting them directly, the <code>background</code> method is your friend.</p>
<p>Want to know what's currently going on?  Methods like <code>getPendingSignal</code> and <code>getScheduledSignal</code> give you insights into active signals. You can also check if a trade has reached its breakeven point with <code>getBreakeven</code>.</p>
<p>Need to intervene?  Functions like <code>stop</code>, <code>commitCancelScheduled</code>, and <code>commitClosePending</code> allow you to manually control the process without halting the entire trading system. There are also specialized methods for partial profit and loss adjustments, along with trailing stop and take-profit management. The <code>commitTrailingStop</code> and <code>commitTrailingTake</code> functions are particularly important, carefully calculating adjustments to prevent compounding errors. The <code>commitBreakeven</code> method lets you automate stop-loss adjustments.</p>
<p>For more advanced control, <code>commitActivateScheduled</code> allows you to trigger a scheduled trade early, <code>commitAverageBuy</code> facilitates dollar-cost averaging, and <code>commitPartialProfit</code> or <code>commitPartialLoss</code> enable partial position management.</p>
<p>Finally, <code>getData</code> lets you retrieve statistics, <code>getReport</code> generates markdown reports, <code>dump</code> saves reports to a file, and <code>list</code> shows the status of all active trading instances.  Essentially, <code>LiveUtils</code> simplifies the complexities of live trading while providing a robust and controlled environment.</p>
<a id="class-livereportservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class LiveReportService<a href="#class-livereportservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The LiveReportService is designed to keep a real-time record of your trading strategy's activity. It listens for events like when a trade is idle, opened, active, or closed, and diligently saves all the details to a SQLite database.</p>
<p>You can think of it as a live monitoring tool for your trading system, allowing you to analyze performance and troubleshoot issues as they happen.</p>
<p>It uses a logger to output debugging information and includes safeguards to ensure you don't accidentally subscribe to the live signal multiple times.</p>
<p>To start tracking your trades, you'll use the <code>subscribe</code> function, which returns a function that lets you stop the tracking when you’re done.  And if you need to stop tracking at any point, <code>unsubscribe</code> handles that cleanup for you.</p>
<a id="class-livemarkdownservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class LiveMarkdownService<a href="#class-livemarkdownservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The LiveMarkdownService helps you automatically create and save detailed reports about your live trading activity. It listens for every event—like when a strategy is idle, opens a position, becomes active, or closes a trade—and keeps track of it all. These events are then organized into easy-to-read markdown tables, providing a clear overview of what’s happening with each of your strategies.</p>
<p>You'll get useful statistics too, such as win rates and average profit/loss per trade.  The service neatly saves these reports to your computer in a designated folder (logs/live/), making it simple to review and analyze your trading performance.</p>
<p>To use it, you’ll connect it to your trading system's event stream, and it will handle the reporting process automatically. It also provides functions to get existing data, clear data, or customize what's included in the reports.  Each trading combination (symbol, strategy, exchange, frame, and backtest status) gets its own separate report storage, ensuring data is neatly organized.</p>
<a id="class-livelogicpublicservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class LiveLogicPublicService<a href="#class-livelogicpublicservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>LiveLogicPublicService helps manage and orchestrate live trading. It builds upon a private service, automatically handling important context information like the strategy and exchange being used, so you don’t have to pass it around manually with every function call.</p>
<p>Think of it as a continuous, never-ending stream of trading signals – it keeps running indefinitely.  If things go wrong and the process crashes, it's designed to bounce back and pick up where it left off, thanks to saved state. It uses the current time to track and manage the trading progression accurately.</p>
<p>You can start it for a specific trading symbol, and it will provide a stream of results including signals to open, close, or cancel trades.</p>
<a id="class-livelogicprivateservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class LiveLogicPrivateService<a href="#class-livelogicprivateservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This service manages the continuous, real-time execution of your trading strategy. It acts as an engine that constantly monitors market data and generates updates as your strategy opens, closes, or cancels positions. Think of it as an always-on process that streams trading activity to you.</p>
<p>It's designed to be resilient; if something goes wrong, it will recover and pick up where it left off. The process doesn’t stop, continuously cycling through monitoring, evaluating signals, and reporting on changes.</p>
<p>Key components like logging, strategy core logic, and method context are integrated for a comprehensive trading environment. The service provides an efficient, memory-friendly stream of trading events.</p>
<a id="class-livecommandservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class LiveCommandService<a href="#class-livecommandservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This service acts as a central point for live trading operations within the backtest-kit framework. Think of it as a helper that makes it easy to inject dependencies for live trading.</p>
<p>It provides a single <code>run</code> method which is the primary way to start and manage live trading for a specific asset. This method continuously streams results – like opened, closed, or cancelled trades – and is designed to automatically recover from unexpected issues, ensuring a more robust live trading experience.</p>
<p>Internally, it relies on several other services to handle things like logging, validating trading strategies, and verifying exchange details, providing a layered approach to reliability and functionality. These included services for strategy validation, exchange validation, strategy schema, risk validation and action validation.</p>
<a id="class-heatutils" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class HeatUtils<a href="#class-heatutils" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>HeatUtils helps you visualize and analyze your portfolio's performance through heatmaps. Think of it as a tool that simplifies creating insightful reports about how your trading strategies are doing.</p>
<p>It automatically gathers data from all your closed trades, breaking down performance by individual assets and providing overall portfolio metrics. You can easily get the raw data or generate a nicely formatted markdown report showcasing key performance indicators like total profit, Sharpe Ratio, and maximum drawdown, sorted by profitability.</p>
<p>Need to save the report? HeatUtils can do that too, creating the necessary directory and saving the report as a markdown file with a default name based on your strategy. It’s designed to be super convenient to use, acting as a single point of access for all your heatmap needs.</p>
<a id="class-heatreportservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class HeatReportService<a href="#class-heatreportservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This service is designed to keep track of your trading signals, specifically when they've closed out, to help you analyze your performance with heatmaps. It listens for events related to closed signals and records them in a database.</p>
<p>Think of it as a dedicated observer that only cares about when a signal finishes – it doesn’t bother with anything else. This lets you build visualizations that show you how different strategies are performing across all your assets.</p>
<p>You can subscribe to start collecting this data and unsubscribe when you no longer need it. The subscription mechanism is designed to prevent you from accidentally subscribing multiple times, which could lead to problems.</p>
<a id="class-heatmarkdownservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class HeatMarkdownService<a href="#class-heatmarkdownservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The Heatmap Service helps you visualize and understand your trading performance across different strategies and symbols. It continuously gathers data on closed trades, allowing you to see key metrics like profit/loss, Sharpe Ratio, and maximum drawdown, both for individual symbols and your entire portfolio.</p>
<p>Think of it as a live dashboard that summarizes your trading activity. It provides a way to generate reports in Markdown format, making it easy to share your results or keep a record of your progress.  You can specify which data to include in these reports, and it ensures calculations are handled safely, even if unexpected values arise. The service also remembers previous calculations to improve performance.</p>
<p>You can subscribe to receive real-time updates from the trading system and later unsubscribe when you no longer need them.  The service stores data separately for each exchange, timeframe, and backtest mode, ensuring your information is organized.  It's designed to be easily cleared, whether you want to wipe all data or just data related to a specific setup. Finally, it can save those reports directly to a file on your computer.</p>
<a id="class-framevalidationservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class FrameValidationService<a href="#class-framevalidationservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The FrameValidationService helps you keep track of your trading timeframes and makes sure they're set up correctly. Think of it as a central place to manage and check your timeframe configurations. You can use it to register new timeframes, easily verify if a timeframe exists before you try to use it, and even see a complete list of all the timeframes you’ve defined. The service is designed to be efficient, remembering past validation checks to speed things up. It keeps a record of all your timeframes and provides tools to manage and validate them, preventing errors and streamlining your trading setup.</p>
<a id="class-frameschemaservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class FrameSchemaService<a href="#class-frameschemaservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This service helps keep track of the blueprints, or schemas, that define how your trading strategies are structured. It uses a special type-safe system to store these schemas, making sure everything is organized correctly. You can think of it as a central repository where you register new schema designs and easily look up existing ones by name.</p>
<p>The service performs a quick check to make sure new schemas have all the necessary parts before adding them.  You use <code>register</code> to add a completely new schema and <code>override</code> to update an existing one with just the changes you need.  Finally, <code>get</code> allows you to find a schema by its name when you need to use it.</p>
<a id="class-framecoreservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class FrameCoreService<a href="#class-framecoreservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This service, <code>FrameCoreService</code>, handles the behind-the-scenes work of generating the timeframes your backtesting needs. It's a central component that works closely with other services to ensure everything runs smoothly.</p>
<p>Think of it as a factory for creating the sequences of dates you'll use to simulate trading. It relies on another service, <code>FrameConnectionService</code>, to actually pull the timeframe data, and uses another, <code>FrameValidationService</code>, to ensure the timeframes are valid.</p>
<p>The <code>getTimeframe</code> method is the primary way to use it; you give it a symbol (like &quot;BTCUSDT&quot;) and a timeframe name (like &quot;1h&quot;), and it returns an array of dates representing that timeframe. This is what the backtesting engine will iterate over. The service also has internal logging and validation components to help keep things organized and reliable.</p>
<a id="class-frameconnectionservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class FrameConnectionService<a href="#class-frameconnectionservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The FrameConnectionService helps manage and access different trading frames within your backtesting environment. Think of it as a central hub that directs your requests to the right frame implementation, ensuring you’re working with the correct data and configuration.</p>
<p>It intelligently routes requests based on the current method context, making things more streamlined. The service also keeps track of frequently used frames, storing them for quick access and boosting performance—this clever caching avoids unnecessary work.</p>
<p>The service provides a way to retrieve the start and end dates for your backtest, allowing you to focus on a specific period of time. This is useful for isolating and analyzing specific market conditions. When in live mode, no frames are used, and the <code>frameName</code> is empty.</p>
<a id="class-exchangevalidationservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class ExchangeValidationService<a href="#class-exchangevalidationservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This service helps keep track of your trading exchanges and makes sure they're properly set up before your backtests run. Think of it as a central place to register each exchange you're using, like Coinbase or Binance.</p>
<p>It provides methods to add new exchanges, check if an exchange exists, and get a complete list of all exchanges you've registered. To speed things up, it remembers the results of validation checks, so it doesn't have to re-validate every time. This helps your backtesting process run smoothly and avoids errors caused by misconfigured exchanges.</p>
<p>You can use <code>addExchange</code> to register a new exchange.  <code>validate</code> makes sure an exchange is correctly configured before you try to use it.  And <code>list</code> gives you a handy overview of all the exchanges you've registered.</p>
<a id="class-exchangeutils" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class ExchangeUtils<a href="#class-exchangeutils" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This class, <code>ExchangeUtils</code>, is like a helper for working with different cryptocurrency exchanges within the backtest-kit framework. It provides easy access to common exchange operations, making sure everything is validated correctly. There's only one instance of this helper available – think of it as a central, shared tool.</p>
<p>You can use it to retrieve historical price data (candles) for a specific trading pair and time interval.  It smartly figures out the date range needed based on how far back you want to look.  It also calculates the average price (VWAP) using recent trading data.</p>
<p>Need to make sure your order quantities and prices are formatted correctly for a specific exchange? This helper can do that too, following the exchange’s rules for precision.  You can also request the order book, which shows the current buy and sell orders, and retrieve raw candle data with precise control over the date and quantity range.  The class is designed to be compatible with older versions of the framework and helps prevent look-ahead bias when dealing with historical data.</p>
<a id="class-exchangeschemaservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class ExchangeSchemaService<a href="#class-exchangeschemaservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This service helps you keep track of the different exchange configurations your trading system uses. It acts like a central repository where you store and manage details about each exchange, like their data format and rules.</p>
<p>You can add new exchange configurations using <code>addExchange()</code>, and later retrieve them by name when you need to use them.</p>
<p>Before an exchange configuration is accepted, it's quickly checked to make sure it has the essential information it needs. You can also update existing configurations with <code>override()</code> to make changes without replacing the entire setup. Finally, <code>get()</code> allows you to easily find a specific exchange configuration by its name.</p>
<a id="class-exchangecoreservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class ExchangeCoreService<a href="#class-exchangecoreservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The ExchangeCoreService acts as a central hub for interacting with exchanges, ensuring that important information like the trading symbol, time, and whether it’s a backtest or live trade is passed along correctly. It builds upon the ExchangeConnectionService and ExecutionContextService to manage these details.</p>
<p>Validation is a key part of the process, with a built-in mechanism to check and memoize exchange configurations, preventing unnecessary checks.</p>
<p>This service provides several methods for retrieving data: fetching historical candles, obtaining future candles (specifically for backtesting scenarios), calculating average prices, formatting prices and quantities, and retrieving order book information. All these operations are performed with consideration of the execution context. There’s also a function to get raw candle data, allowing for more control over date ranges and limits.</p>
<a id="class-exchangeconnectionservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class ExchangeConnectionService<a href="#class-exchangeconnectionservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The ExchangeConnectionService acts as a central hub for interacting with different cryptocurrency exchanges. It intelligently directs requests to the correct exchange implementation based on the current context, ensuring your code seamlessly works with various platforms. To optimize performance, it remembers previously used exchanges, so you don't have to repeatedly create connections.</p>
<p>This service provides a complete set of functions for common trading tasks: fetching historical and future candles, retrieving average prices (either live or calculated from historical data), and formatting prices and quantities to comply with each exchange's specific rules. You can also retrieve order book data and access raw candles with customizable date ranges. Everything is logged for auditing and debugging purposes. It takes care of the complexities of connecting and communicating with different exchanges, letting you focus on your trading strategies.</p>
<a id="class-constantutils" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class ConstantUtils<a href="#class-constantutils" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The ConstantUtils class provides a set of pre-calculated values used for setting take-profit and stop-loss levels in your trading strategies. These values are based on the Kelly Criterion, a mathematical formula for optimal bet sizing, and incorporate a decay mechanism to manage risk.</p>
<p>Think of it as a framework for breaking down your profit and loss targets into stages.  For instance, if your target profit is 10%, TP_LEVEL1 is reached at 3%, TP_LEVEL2 at 6%, and TP_LEVEL3 at 9%, allowing you to secure profits in increments.</p>
<p>Similarly, SL_LEVEL1 represents an early warning sign at 40% of the stop-loss distance, while SL_LEVEL2 acts as a final exit point at 80%, helping to minimize potential losses.  These constants give you a convenient starting point for configuring your strategy's risk management.</p>
<a id="class-configvalidationservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class ConfigValidationService<a href="#class-configvalidationservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This service helps make sure your trading configuration settings are mathematically sound and won't lead to losses. It checks a wide range of parameters, including percentages like slippage and fees, ensuring they're all positive values.</p>
<p>A crucial check ensures that your minimum take-profit distance is large enough to cover all trading costs, so you can actually make money when a trade hits its target. The service also verifies that ranges are set up correctly, like stop-loss distances, and that time-related settings and candle request parameters are using appropriate values.</p>
<p>The <code>validate</code> function is the core of this service, performing all these checks to keep your trading setup in good shape. It's essentially a safety net to catch potential errors in your configuration.</p>
<a id="class-columnvalidationservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class ColumnValidationService<a href="#class-columnvalidationservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The ColumnValidationService helps you make sure your column configurations are set up correctly and follow the rules. It acts as a quality check for your column definitions, making sure everything is consistent.</p>
<p>It verifies that each column has all the necessary pieces – a key, a label, a format, and a visibility setting. It also ensures that those keys are unique so there's no confusion.</p>
<p>The service checks that your format and visibility settings are actually functions that can be used. Finally, it confirms that the key and label fields contain text. Think of it as a safety net to catch potential errors early on.</p>
<a id="class-clientsizing" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class ClientSizing<a href="#class-clientsizing" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This component, ClientSizing, figures out how much of your assets to allocate to a trade. It's designed to be flexible, allowing you to use different sizing approaches like fixed percentages, the Kelly Criterion, or Average True Range (ATR).</p>
<p>You can also set limits on how much you're willing to risk per trade, either by specifying minimum or maximum position sizes or by capping the percentage of your capital used. It also provides ways to hook in your own logic for verifying trade parameters or keeping a record of sizing decisions. Ultimately, this piece helps make sure your trading strategy takes appropriate position sizes.</p>
<p>The <code>calculate</code> method is the core; it’s what actually determines the position size based on the strategy's input and your sizing configurations.</p>
<a id="class-clientrisk" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class ClientRisk<a href="#class-clientrisk" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>ClientRisk helps manage the overall risk of your trading portfolio by setting limits and validating trade signals. Think of it as a safety net to prevent your strategies from taking on too much risk at once. It keeps track of all open positions across different strategies, allowing it to enforce rules that consider the combined impact of various trading approaches.</p>
<p>This system uses a shared risk instance across multiple strategies, enabling it to assess and control risk in a holistic way. It's automatically used before a trade is executed to ensure it aligns with the defined risk parameters.</p>
<p>The <code>_activePositions</code> property is a central record of your current positions, automatically updating and persisting them to disk (except during backtesting).</p>
<p><code>checkSignal</code> is the core method used to evaluate a trade, considering custom validations and ensuring no limits are breached. Signals are registered with <code>addSignal</code> when opened and removed with <code>removeSignal</code> when closed, enabling continuous risk tracking.</p>
<a id="class-clientframe" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class ClientFrame<a href="#class-clientframe" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The <code>ClientFrame</code> is the engine that creates the timelines your backtests run on. Think of it as the clock for your trading strategies. It generates arrays of timestamps – essentially, a list of dates and times – that tell the backtest how to move through historical data.</p>
<p>To avoid wasting resources, it caches these timelines so it doesn’t have to rebuild them every time. You can customize the intervals it uses, from one minute to three days, and even add your own logic to check or record events as timelines are created.  The <code>getTimeframe</code> property is the core function to get the timeline array; it uses a clever caching system to avoid unnecessary work.</p>
<a id="class-clientexchange" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class ClientExchange<a href="#class-clientexchange" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This class, <code>ClientExchange</code>, is your go-to for accessing exchange data within the backtest-kit framework. It's designed to be efficient, using techniques to minimize memory usage.</p>
<p>You can use it to retrieve historical and future candle data for a specific trading symbol and interval. When backtesting, <code>getNextCandles</code> allows you to fetch future candles needed for generating trading signals.  It can also calculate the VWAP (Volume Weighted Average Price) – a useful indicator based on recent trading activity.</p>
<p>The class also handles the formatting of quantities and prices, ensuring they adhere to the rules of the specific exchange you're interacting with. If you need raw, unfiltered historical data, the <code>getRawCandles</code> method offers a lot of flexibility in specifying the date range and number of candles you want, with built-in safeguards against look-ahead bias. Finally, you can use <code>getOrderBook</code> to get a snapshot of the current order book.</p>
<a id="class-clientaction" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class ClientAction<a href="#class-clientaction" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The <code>ClientAction</code> component is the core of how your custom action handlers, which manage things like logging, notifications, and analytics, are integrated into the trading framework. It takes care of setting up and cleaning up your handlers, ensuring they only run once and are properly disposed of when they're no longer needed.</p>
<p>Think of it as a smart intermediary. It receives events from the trading system, like a new tick of data or a change in a contract's status, and routes those events to the appropriate methods within your action handler.</p>
<p>It manages the lifecycle of the handler, creating it only when necessary and guaranteeing a clean exit.  There are dedicated methods for handling different types of events, like signal updates for live or backtest trading, breakeven, partial profit/loss, and ping-related notifications. Essentially, <code>ClientAction</code> simplifies the process of connecting your custom logic to the trading engine.</p>
<a id="class-cacheutils" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class CacheUtils<a href="#class-cacheutils" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>CacheUtils helps you speed up your backtesting by automatically caching the results of your functions. Think of it as a way to remember calculations so you don't have to repeat them unnecessarily. It's set up to work with timeframes, so the cached results are automatically invalidated when a new timeframe starts.</p>
<p>You get a single, shared instance of this utility, making it simple to use throughout your backtesting code.</p>
<p>There are a few handy tools inside:</p>
<ul>
<li><code>fn</code>: This is the core function. You wrap your existing functions with this to enable caching. It automatically takes care of storing and retrieving results based on the timeframe you specify.</li>
<li><code>flush</code>: This is for cleaning up. It lets you completely remove the cache for a specific function, or for <em>all</em> functions. This is useful if you've changed the function's implementation or want to free up memory.</li>
<li><code>clear</code>: This clears the cache for just the current testing scenario (strategy, exchange, backtest mode). It's like wiping the slate clean for that specific run.</li>
<li><code>gc</code>: This is a garbage collector for your cache. It automatically removes old, expired cache entries to keep things tidy and efficient.</li>
</ul>
<a id="class-breakevenutils" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class BreakevenUtils<a href="#class-breakevenutils" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The BreakevenUtils class helps you analyze and report on breakeven events within your backtesting or live trading system. It acts as a central point for accessing information gathered about when trades hit their breakeven points.</p>
<p>Think of it as a tool to get a summary of how often your strategies reach breakeven, and to create reports detailing those events. You can request simple statistics, like the total number of breakeven events, or generate comprehensive markdown reports.</p>
<p>These reports present each breakeven event in a table with details like the symbol traded, strategy used, entry price, current price, and more.  You can even save these reports directly to files, making it easy to share or archive your results. The reports automatically create the necessary directories if they don’t exist.</p>
<a id="class-breakevenreportservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class BreakevenReportService<a href="#class-breakevenreportservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This service helps you keep track of when your trading signals reach their breakeven point. It's designed to listen for these &quot;breakeven&quot; events and automatically save details about them—like the specifics of the signal—to a database. Think of it as a record-keeping tool for understanding how your strategies perform.</p>
<p>To use it, you'll subscribe to a signal emitter to receive these breakeven notifications. Once subscribed, the service silently logs each event. You can unsubscribe at any time to stop the logging. The system makes sure you don't accidentally subscribe multiple times, preventing duplicate entries in your records. It utilizes a logger to provide debugging information.</p>
<a id="class-breakevenmarkdownservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class BreakevenMarkdownService<a href="#class-breakevenmarkdownservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The BreakevenMarkdownService helps you automatically create and save reports about breakeven events in your trading strategies. It keeps track of these events – times when a trade reached a breakeven point – for each symbol and strategy you're using.</p>
<p>It listens for breakeven signals and organizes them, then transforms that information into easy-to-read markdown tables. You can generate reports with detailed information about each event, as well as overall statistics like the total number of breakeven occurrences.</p>
<p>The service saves these reports to your computer in a standardized format, making it simple to review and analyze your strategy’s performance. You can choose which data to include in the report, and even clear the accumulated data when needed. This service is designed to be efficient, ensuring that each combination of symbol, strategy, exchange, frame, and backtest gets its own isolated storage space.</p>
<a id="class-breakevenglobalservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class BreakevenGlobalService<a href="#class-breakevenglobalservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This service acts as a central hub for managing breakeven calculations within your trading strategy. It's designed to be injected into your strategy, providing a single point of access for breakeven-related operations and ensuring everything is logged for monitoring purposes.</p>
<p>Think of it as a middleman – it receives requests, records them in logs, and then passes them on to a separate connection service that actually handles the underlying calculations.</p>
<p>Several validation services are built-in, making sure your strategy, risk parameters, exchanges, and data frames all exist and are correctly configured before any calculations happen. The <code>validate</code> method streamlines this by remembering previous validations to avoid unnecessary checks.</p>
<p>The <code>check</code> method determines whether breakeven conditions have been met, and the <code>clear</code> method resets the breakeven state when a signal closes, both with detailed logging throughout the process.</p>
<a id="class-breakevenconnectionservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class BreakevenConnectionService<a href="#class-breakevenconnectionservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The BreakevenConnectionService helps track breakeven points for trading signals. It’s designed to efficiently manage and reuse breakeven calculations, avoiding redundant work.</p>
<p>Essentially, it creates a special object, called ClientBreakeven, for each unique trading signal, keeping track of its breakeven details.  These objects are cleverly cached, so you don't have to recreate them every time you need them.</p>
<p>When a signal is opened, this service checks if a breakeven calculation is needed and triggers an event if certain conditions are met. When a signal closes, it clears the breakeven data and removes the cached object, keeping things clean. The service gets injected with other tools it needs to function, such as a logger and a core action service. It’s the central point for managing breakeven calculations within the system.</p>
<a id="class-backtestutils" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class BacktestUtils<a href="#class-backtestutils" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This class provides helpful tools to run and manage backtesting simulations. Think of it as a utility belt for your backtesting experiments.</p>
<p>You can use <code>run</code> to execute a backtest for a specific trading symbol and strategy, getting results as they become available.  If you want to run a test quietly, without seeing the results directly (perhaps for logging or other side effects), use <code>background</code>.</p>
<p>Need to peek at the current pending or scheduled signal? <code>getPendingSignal</code> and <code>getScheduledSignal</code> can retrieve that information.  You can also check if a trade has reached breakeven using <code>getBreakeven</code>.</p>
<p>To control your backtest mid-execution, there are functions like <code>stop</code> (to halt the test), <code>commitCancelScheduled</code> (to cancel a scheduled signal), and <code>commitClosePending</code> (to close a pending signal).</p>
<p>Several other methods allow you to fine-tune active signals – adjusting trailing stops (<code>commitTrailingStop</code>, <code>commitTrailingTake</code>) or taking partial profits/losses (<code>commitPartialProfit</code>, <code>commitPartialLoss</code>).  There's also a function to move the stop-loss to breakeven (<code>commitBreakeven</code>) and activate scheduled signals prematurely (<code>commitActivateScheduled</code>).</p>
<p>If you're building a dollar-cost averaging (DCA) strategy, <code>commitAverageBuy</code> lets you add new entries.  Finally, <code>getData</code> and <code>getReport</code> provide ways to gather statistics and generate reports from completed backtests. <code>dump</code> saves your reports to a file. <code>list</code> provides an overview of all currently running backtest instances.</p>
<p>It's designed as a singleton, meaning there’s just one instance of this class managing all backtest operations, making it simple to access and use throughout your code.</p>
<a id="class-backtestreportservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class BacktestReportService<a href="#class-backtestreportservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The BacktestReportService helps you keep a detailed record of your backtesting strategy's activity. It essentially acts as a diligent observer, capturing every significant event—when a signal is idle, when it's opened, actively being used, or closed.</p>
<p>It stores this information in a database (SQLite), allowing you to later analyze performance and debug any issues that arise. You subscribe the service to receive these events, and it handles all the technical details of logging them. Importantly, it prevents accidental double-logging by ensuring only one subscription is active at a time. You can unsubscribe to stop the logging when you no longer need it. Think of it as a recorder for your backtest, creating a valuable audit trail.</p>
<a id="class-backtestmarkdownservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class BacktestMarkdownService<a href="#class-backtestmarkdownservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The BacktestMarkdownService helps you create readable reports during backtesting, essentially turning your trading experiments into nicely formatted documents. It listens for trading signals, specifically keeping track of signals that have closed.</p>
<p>Think of it as a recorder that neatly organizes your backtest data. It accumulates information about these closed signals and then uses that information to generate markdown tables, which are easy to read and understand.</p>
<p>You can then save these reports directly to your disk, organized by strategy name, allowing you to easily review and analyze the results of your backtests. The service also lets you clear out the recorded data when you're finished with a particular backtest, or just want a fresh start. It makes the whole process of documenting and sharing your backtesting results much simpler.</p>
<a id="class-backtestlogicpublicservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class BacktestLogicPublicService<a href="#class-backtestlogicpublicservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>BacktestLogicPublicService is designed to simplify running backtests within the backtest-kit framework. It acts as a middle layer, handling the context needed for your trading strategies to function correctly. Think of it as a way to automatically pass along important information like the strategy name, exchange, and timeframe to all the underlying components, so you don't have to specify them repeatedly.</p>
<p>The <code>run</code> method is the core of this service - it's how you actually kick off a backtest for a specific trading symbol. It returns a stream of results representing the trades executed during the backtest. Because of the automatic context handling, you can focus on the logic of your strategies without getting bogged down in manually managing context parameters.</p>
<a id="class-backtestlogicprivateservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class BacktestLogicPrivateService<a href="#class-backtestlogicprivateservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The <code>BacktestLogicPrivateService</code> helps orchestrate backtesting processes in a memory-friendly way, especially when dealing with lots of data. It works by getting timeframes, then stepping through them one by one. Whenever a trading signal appears, it fetches the necessary candle data and executes the backtest logic.  Once a signal is closed, the results are streamed out – instead of collecting everything in memory at once.</p>
<p>You can even stop the backtest early if needed, by interrupting the process. This service uses several other services for things like logging, strategy execution, exchanging data, managing timeframes, providing context and handling actions, so it relies on these components to function properly. The <code>run</code> method is the main entry point, letting you kick off a backtest for a specific symbol and receive the results as a continuous stream of data.</p>
<a id="class-backtestcommandservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class BacktestCommandService<a href="#class-backtestcommandservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This service acts as a central point to start and manage backtesting processes within the system. Think of it as the main gateway for running backtests and accessing related functionality. It simplifies how different parts of the application interact with the backtesting engine by providing a consistent interface.</p>
<p>The service relies on several other specialized services for tasks like logging, validating strategy definitions, and checking for potential risks.</p>
<p>You can use the <code>run</code> method to actually execute a backtest. This method takes a symbol (like a stock ticker) and contextual information—such as the names of the strategy, exchange, and frame—to control the backtest's parameters. The backtest results are delivered as a stream of data, showing how the strategy performed at each step.</p>
<a id="class-actionvalidationservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class ActionValidationService<a href="#class-actionvalidationservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The ActionValidationService helps you keep track of and double-check your action handlers—those pieces of code that respond to specific events. Think of it as a central manager for all your actions.</p>
<p>You can add new action handlers using <code>addAction</code>, providing a name and schema for each one. Before using an action handler, it's a good idea to <code>validate</code> it to make sure it's actually registered, preventing unexpected errors.</p>
<p>The service remembers its validation results to speed things up, avoiding redundant checks. If you need to see a complete list of all the action handlers you’ve registered, you can use the <code>list</code> function. It's designed to make sure your actions are reliable and well-managed.</p>
<a id="class-actionschemaservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class ActionSchemaService<a href="#class-actionschemaservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The ActionSchemaService is responsible for keeping track of the blueprints for actions your trading system can take. It ensures these blueprints are well-formed and safe before letting them be used.</p>
<p>Think of it as a librarian for your actions, making sure everything is categorized correctly and follows the rules.</p>
<p>It uses a type-safe system, so errors related to incorrect action definitions are caught early.  You can register new action blueprints, validate existing ones to make sure they are set up properly, and even update them later without needing to completely recreate them. If a blueprint already exists, attempting to register it will result in an error. The service also keeps an eye on the methods available in your action handlers, making sure they only use the approved ones.  Finally, it provides a way to easily retrieve a complete action blueprint when needed.</p>
<a id="class-actionproxy" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class ActionProxy<a href="#class-actionproxy" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The <code>ActionProxy</code> acts as a safety net when your custom trading logic is executed. It's designed to prevent errors in your code from bringing the entire trading system down. Think of it as a wrapper around your own functions, automatically catching any mistakes and logging them, but allowing the system to keep running.</p>
<p>It handles various events like signals, profit/loss levels, scheduled tasks, and cleanup routines. Essentially, whenever your trading strategy needs to react to something (a new candle, a profit target reached, a scheduled event), <code>ActionProxy</code> steps in to ensure that any errors don't stop the trading process.</p>
<p>You don't directly create <code>ActionProxy</code> instances; instead, you use the <code>fromInstance()</code> method, which takes your own code (that implements parts of the <code>IPublicAction</code> interface) and wraps it in this protective layer.  This ensures consistent error handling across all parts of your strategy and makes debugging much easier, because issues are reported without crashing the system. The goal is that the system keeps moving forward even if your custom functions have hiccups.</p>
<a id="class-actioncoreservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class ActionCoreService<a href="#class-actioncoreservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The ActionCoreService acts as a central hub for managing actions within your trading strategies. It's responsible for coordinating how actions are handled, from validating their setup to dispatching signals and cleaning up afterward.</p>
<p>Essentially, it takes the action instructions defined in your strategy’s schema and makes sure everything is set up correctly, then it systematically sends events to each action.  This ensures actions work in a predictable, sequential order.</p>
<p>The service uses several other components internally to handle things like logging, action connections, validations (for strategies, exchanges, frames, and risks), and retrieving strategy schemas.</p>
<p>Key functionalities include:</p>
<ul>
<li><strong>Initialization:</strong> Sets up each action's initial state by fetching data from the strategy schema and invoking an initialization handler.</li>
<li><strong>Signal Routing:</strong> Delivers signal events (for live trading, backtesting, and scheduled pings) to the appropriate actions.</li>
<li><strong>Event Handling:</strong>  Manages various events like breakeven, partial profit/loss, risk rejections, and active pings, routing them to their corresponding actions.</li>
<li><strong>Validation:</strong> Checks the strategy's context and configuration to ensure everything is valid. This is optimized to avoid repetitive checks.</li>
<li><strong>Cleanup:</strong>  Disposes of actions at the end of strategy execution to release resources.</li>
<li><strong>Data Clearing:</strong> Allows for clearing action data, either for a specific action or globally across all strategies.</li>
</ul>
<a id="class-actionconnectionservice" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class ActionConnectionService<a href="#class-actionconnectionservice" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The <code>ActionConnectionService</code> acts as a central hub for directing actions within your backtesting or live trading environment. Think of it as a smart router that ensures the correct action is executed for each specific scenario. It intelligently manages and reuses action implementations (called <code>ClientAction</code> instances) to improve performance, avoiding unnecessary re-creation.</p>
<p>The service relies on a few key pieces of information – the action name, strategy name, exchange name, and frame name – to determine the precise <code>ClientAction</code> to use. It uses caching to store these <code>ClientAction</code> instances, so if the same action is needed again with the same parameters, it retrieves the cached version instead of creating a new one.</p>
<p>It provides several methods for handling different events: <code>signal</code>, <code>signalLive</code>, <code>signalBacktest</code>, <code>breakevenAvailable</code>, <code>partialProfitAvailable</code>, <code>partialLossAvailable</code>, <code>pingScheduled</code>, <code>pingActive</code>, <code>riskRejection</code>, <code>dispose</code> and <code>clear</code>. Each of these routes a specific type of event to the appropriate <code>ClientAction</code> for processing. The <code>initFn</code> method is used to initialize the ClientAction, loading any persisted state it might need. Finally, the <code>clear</code> method helps to release resources by invalidating cached actions.</p>
<a id="class-actionbase" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Class ActionBase<a href="#class-actionbase" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This class, <code>ActionBase</code>, acts as a foundation for building custom components that interact with your backtesting or live trading strategies. Think of it as a starting point for adding things like notifications, logging, or custom business logic. It handles a lot of the boilerplate work for you, including automatically logging events so you don’t have to write that code yourself repeatedly.</p>
<p>When you extend this class, you'll get access to important information like the strategy’s name, frame name, and the specific action that triggered an event.  You'll also be able to implement specific methods to respond to events like signals, breakeven availability, or partial profit milestones.</p>
<p>The lifecycle is straightforward: initialization happens once, event handling occurs as the strategy runs, and a final cleanup process ensures resources are released properly. The class distinguishes between backtest and live trading modes, allowing you to create actions that behave differently in each environment.  You only need to override the methods you want to customize; the default implementations handle basic logging.</p>
</div></div><div class="col-sidebar"><div class="page-menu"><div class="tsd-navigation settings"><details class="tsd-accordion"><summary class="tsd-accordion-summary"><h3><svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-chevronDown"></use></svg>Settings</h3></summary><div class="tsd-accordion-details"><div class="tsd-filter-visibility"><span class="settings-label">Member Visibility</span><ul id="tsd-filter-options"><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-protected" name="protected"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Protected</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-inherited" name="inherited" checked/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Inherited</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-external" name="external"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>External</span></label></li></ul></div><div class="tsd-theme-toggle"><label class="settings-label" for="tsd-theme">Theme</label><select id="tsd-theme"><option value="os">OS</option><option value="light">Light</option><option value="dark">Dark</option></select></div></div></details></div><details open class="tsd-accordion tsd-page-navigation"><summary class="tsd-accordion-summary"><h3><svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-chevronDown"></use></svg>On This Page</h3></summary><div class="tsd-accordion-details"><a href="#backtest-kit-api-reference"><span>backtest-<wbr/>kit api reference</span></a><a href="#backtest-kit-classes"><span>backtest-<wbr/>kit classes</span></a><ul><li><a href="#class-walkervalidationservice"><span>Class <wbr/>Walker<wbr/>Validation<wbr/>Service</span></a></li><li><a href="#class-walkerutils"><span>Class <wbr/>Walker<wbr/>Utils</span></a></li><li><a href="#class-walkerschemaservice"><span>Class <wbr/>Walker<wbr/>Schema<wbr/>Service</span></a></li><li><a href="#class-walkerreportservice"><span>Class <wbr/>Walker<wbr/>Report<wbr/>Service</span></a></li><li><a href="#class-walkermarkdownservice"><span>Class <wbr/>Walker<wbr/>Markdown<wbr/>Service</span></a></li><li><a href="#class-walkerlogicpublicservice"><span>Class <wbr/>Walker<wbr/>Logic<wbr/>Public<wbr/>Service</span></a></li><li><a href="#class-walkerlogicprivateservice"><span>Class <wbr/>Walker<wbr/>Logic<wbr/>Private<wbr/>Service</span></a></li><li><a href="#class-walkercommandservice"><span>Class <wbr/>Walker<wbr/>Command<wbr/>Service</span></a></li><li><a href="#class-strategyvalidationservice"><span>Class <wbr/>Strategy<wbr/>Validation<wbr/>Service</span></a></li><li><a href="#class-strategyutils"><span>Class <wbr/>Strategy<wbr/>Utils</span></a></li><li><a href="#class-strategyschemaservice"><span>Class <wbr/>Strategy<wbr/>Schema<wbr/>Service</span></a></li><li><a href="#class-strategyreportservice"><span>Class <wbr/>Strategy<wbr/>Report<wbr/>Service</span></a></li><li><a href="#class-strategymarkdownservice"><span>Class <wbr/>Strategy<wbr/>Markdown<wbr/>Service</span></a></li><li><a href="#class-strategycoreservice"><span>Class <wbr/>Strategy<wbr/>Core<wbr/>Service</span></a></li><li><a href="#class-strategyconnectionservice"><span>Class <wbr/>Strategy<wbr/>Connection<wbr/>Service</span></a></li><li><a href="#class-storageliveadapter"><span>Class <wbr/>Storage<wbr/>Live<wbr/>Adapter</span></a></li><li><a href="#class-storagebacktestadapter"><span>Class <wbr/>Storage<wbr/>Backtest<wbr/>Adapter</span></a></li><li><a href="#class-storageadapter"><span>Class <wbr/>Storage<wbr/>Adapter</span></a></li><li><a href="#class-sizingvalidationservice"><span>Class <wbr/>Sizing<wbr/>Validation<wbr/>Service</span></a></li><li><a href="#class-sizingschemaservice"><span>Class <wbr/>Sizing<wbr/>Schema<wbr/>Service</span></a></li><li><a href="#class-sizingglobalservice"><span>Class <wbr/>Sizing<wbr/>Global<wbr/>Service</span></a></li><li><a href="#class-sizingconnectionservice"><span>Class <wbr/>Sizing<wbr/>Connection<wbr/>Service</span></a></li><li><a href="#class-scheduleutils"><span>Class <wbr/>Schedule<wbr/>Utils</span></a></li><li><a href="#class-schedulereportservice"><span>Class <wbr/>Schedule<wbr/>Report<wbr/>Service</span></a></li><li><a href="#class-schedulemarkdownservice"><span>Class <wbr/>Schedule<wbr/>Markdown<wbr/>Service</span></a></li><li><a href="#class-riskvalidationservice"><span>Class <wbr/>Risk<wbr/>Validation<wbr/>Service</span></a></li><li><a href="#class-riskutils"><span>Class <wbr/>Risk<wbr/>Utils</span></a></li><li><a href="#class-riskschemaservice"><span>Class <wbr/>Risk<wbr/>Schema<wbr/>Service</span></a></li><li><a href="#class-riskreportservice"><span>Class <wbr/>Risk<wbr/>Report<wbr/>Service</span></a></li><li><a href="#class-riskmarkdownservice"><span>Class <wbr/>Risk<wbr/>Markdown<wbr/>Service</span></a></li><li><a href="#class-riskglobalservice"><span>Class <wbr/>Risk<wbr/>Global<wbr/>Service</span></a></li><li><a href="#class-riskconnectionservice"><span>Class <wbr/>Risk<wbr/>Connection<wbr/>Service</span></a></li><li><a href="#class-reportutils"><span>Class <wbr/>Report<wbr/>Utils</span></a></li><li><a href="#class-reportbase"><span>Class <wbr/>Report<wbr/>Base</span></a></li><li><a href="#class-reportadapter"><span>Class <wbr/>Report<wbr/>Adapter</span></a></li><li><a href="#class-positionsizeutils"><span>Class <wbr/>Position<wbr/>Size<wbr/>Utils</span></a></li><li><a href="#class-persiststorageutils"><span>Class <wbr/>Persist<wbr/>Storage<wbr/>Utils</span></a></li><li><a href="#class-persistsignalutils"><span>Class <wbr/>Persist<wbr/>Signal<wbr/>Utils</span></a></li><li><a href="#class-persistscheduleutils"><span>Class <wbr/>Persist<wbr/>Schedule<wbr/>Utils</span></a></li><li><a href="#class-persistriskutils"><span>Class <wbr/>Persist<wbr/>Risk<wbr/>Utils</span></a></li><li><a href="#class-persistpartialutils"><span>Class <wbr/>Persist<wbr/>Partial<wbr/>Utils</span></a></li><li><a href="#class-persistnotificationutils"><span>Class <wbr/>Persist<wbr/>Notification<wbr/>Utils</span></a></li><li><a href="#class-persistcandleutils"><span>Class <wbr/>Persist<wbr/>Candle<wbr/>Utils</span></a></li><li><a href="#class-persistbreakevenutils"><span>Class <wbr/>Persist<wbr/>Breakeven<wbr/>Utils</span></a></li><li><a href="#class-persistbase"><span>Class <wbr/>Persist<wbr/>Base</span></a></li><li><a href="#class-performancereportservice"><span>Class <wbr/>Performance<wbr/>Report<wbr/>Service</span></a></li><li><a href="#class-performancemarkdownservice"><span>Class <wbr/>Performance<wbr/>Markdown<wbr/>Service</span></a></li><li><a href="#class-performance"><span>Class <wbr/>Performance</span></a></li><li><a href="#class-partialutils"><span>Class <wbr/>Partial<wbr/>Utils</span></a></li><li><a href="#class-partialreportservice"><span>Class <wbr/>Partial<wbr/>Report<wbr/>Service</span></a></li><li><a href="#class-partialmarkdownservice"><span>Class <wbr/>Partial<wbr/>Markdown<wbr/>Service</span></a></li><li><a href="#class-partialglobalservice"><span>Class <wbr/>Partial<wbr/>Global<wbr/>Service</span></a></li><li><a href="#class-partialconnectionservice"><span>Class <wbr/>Partial<wbr/>Connection<wbr/>Service</span></a></li><li><a href="#class-notificationliveadapter"><span>Class <wbr/>Notification<wbr/>Live<wbr/>Adapter</span></a></li><li><a href="#class-notificationbacktestadapter"><span>Class <wbr/>Notification<wbr/>Backtest<wbr/>Adapter</span></a></li><li><a href="#class-notificationadapter"><span>Class <wbr/>Notification<wbr/>Adapter</span></a></li><li><a href="#class-markdownutils"><span>Class <wbr/>Markdown<wbr/>Utils</span></a></li><li><a href="#class-markdownfolderbase"><span>Class <wbr/>Markdown<wbr/>Folder<wbr/>Base</span></a></li><li><a href="#class-markdownfilebase"><span>Class <wbr/>Markdown<wbr/>File<wbr/>Base</span></a></li><li><a href="#class-markdownadapter"><span>Class <wbr/>Markdown<wbr/>Adapter</span></a></li><li><a href="#class-loggerservice"><span>Class <wbr/>Logger<wbr/>Service</span></a></li><li><a href="#class-liveutils"><span>Class <wbr/>Live<wbr/>Utils</span></a></li><li><a href="#class-livereportservice"><span>Class <wbr/>Live<wbr/>Report<wbr/>Service</span></a></li><li><a href="#class-livemarkdownservice"><span>Class <wbr/>Live<wbr/>Markdown<wbr/>Service</span></a></li><li><a href="#class-livelogicpublicservice"><span>Class <wbr/>Live<wbr/>Logic<wbr/>Public<wbr/>Service</span></a></li><li><a href="#class-livelogicprivateservice"><span>Class <wbr/>Live<wbr/>Logic<wbr/>Private<wbr/>Service</span></a></li><li><a href="#class-livecommandservice"><span>Class <wbr/>Live<wbr/>Command<wbr/>Service</span></a></li><li><a href="#class-heatutils"><span>Class <wbr/>Heat<wbr/>Utils</span></a></li><li><a href="#class-heatreportservice"><span>Class <wbr/>Heat<wbr/>Report<wbr/>Service</span></a></li><li><a href="#class-heatmarkdownservice"><span>Class <wbr/>Heat<wbr/>Markdown<wbr/>Service</span></a></li><li><a href="#class-framevalidationservice"><span>Class <wbr/>Frame<wbr/>Validation<wbr/>Service</span></a></li><li><a href="#class-frameschemaservice"><span>Class <wbr/>Frame<wbr/>Schema<wbr/>Service</span></a></li><li><a href="#class-framecoreservice"><span>Class <wbr/>Frame<wbr/>Core<wbr/>Service</span></a></li><li><a href="#class-frameconnectionservice"><span>Class <wbr/>Frame<wbr/>Connection<wbr/>Service</span></a></li><li><a href="#class-exchangevalidationservice"><span>Class <wbr/>Exchange<wbr/>Validation<wbr/>Service</span></a></li><li><a href="#class-exchangeutils"><span>Class <wbr/>Exchange<wbr/>Utils</span></a></li><li><a href="#class-exchangeschemaservice"><span>Class <wbr/>Exchange<wbr/>Schema<wbr/>Service</span></a></li><li><a href="#class-exchangecoreservice"><span>Class <wbr/>Exchange<wbr/>Core<wbr/>Service</span></a></li><li><a href="#class-exchangeconnectionservice"><span>Class <wbr/>Exchange<wbr/>Connection<wbr/>Service</span></a></li><li><a href="#class-constantutils"><span>Class <wbr/>Constant<wbr/>Utils</span></a></li><li><a href="#class-configvalidationservice"><span>Class <wbr/>Config<wbr/>Validation<wbr/>Service</span></a></li><li><a href="#class-columnvalidationservice"><span>Class <wbr/>Column<wbr/>Validation<wbr/>Service</span></a></li><li><a href="#class-clientsizing"><span>Class <wbr/>Client<wbr/>Sizing</span></a></li><li><a href="#class-clientrisk"><span>Class <wbr/>Client<wbr/>Risk</span></a></li><li><a href="#class-clientframe"><span>Class <wbr/>Client<wbr/>Frame</span></a></li><li><a href="#class-clientexchange"><span>Class <wbr/>Client<wbr/>Exchange</span></a></li><li><a href="#class-clientaction"><span>Class <wbr/>Client<wbr/>Action</span></a></li><li><a href="#class-cacheutils"><span>Class <wbr/>Cache<wbr/>Utils</span></a></li><li><a href="#class-breakevenutils"><span>Class <wbr/>Breakeven<wbr/>Utils</span></a></li><li><a href="#class-breakevenreportservice"><span>Class <wbr/>Breakeven<wbr/>Report<wbr/>Service</span></a></li><li><a href="#class-breakevenmarkdownservice"><span>Class <wbr/>Breakeven<wbr/>Markdown<wbr/>Service</span></a></li><li><a href="#class-breakevenglobalservice"><span>Class <wbr/>Breakeven<wbr/>Global<wbr/>Service</span></a></li><li><a href="#class-breakevenconnectionservice"><span>Class <wbr/>Breakeven<wbr/>Connection<wbr/>Service</span></a></li><li><a href="#class-backtestutils"><span>Class <wbr/>Backtest<wbr/>Utils</span></a></li><li><a href="#class-backtestreportservice"><span>Class <wbr/>Backtest<wbr/>Report<wbr/>Service</span></a></li><li><a href="#class-backtestmarkdownservice"><span>Class <wbr/>Backtest<wbr/>Markdown<wbr/>Service</span></a></li><li><a href="#class-backtestlogicpublicservice"><span>Class <wbr/>Backtest<wbr/>Logic<wbr/>Public<wbr/>Service</span></a></li><li><a href="#class-backtestlogicprivateservice"><span>Class <wbr/>Backtest<wbr/>Logic<wbr/>Private<wbr/>Service</span></a></li><li><a href="#class-backtestcommandservice"><span>Class <wbr/>Backtest<wbr/>Command<wbr/>Service</span></a></li><li><a href="#class-actionvalidationservice"><span>Class <wbr/>Action<wbr/>Validation<wbr/>Service</span></a></li><li><a href="#class-actionschemaservice"><span>Class <wbr/>Action<wbr/>Schema<wbr/>Service</span></a></li><li><a href="#class-actionproxy"><span>Class <wbr/>Action<wbr/>Proxy</span></a></li><li><a href="#class-actioncoreservice"><span>Class <wbr/>Action<wbr/>Core<wbr/>Service</span></a></li><li><a href="#class-actionconnectionservice"><span>Class <wbr/>Action<wbr/>Connection<wbr/>Service</span></a></li><li><a href="#class-actionbase"><span>Class <wbr/>Action<wbr/>Base</span></a></li></ul></div></details></div><div class="site-menu"><nav class="tsd-navigation"><a href="../modules.html">backtest-kit</a><ul class="tsd-small-nested-navigation" id="tsd-nav-container"><li>Loading...</li></ul></nav></div></div></div><footer><p class="tsd-generator">Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p></footer><div class="overlay"></div></body></html>

<!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function(m,e,t,r,i,k,a){
        m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();
        for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
        k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)
    })(window, document,'script','https://mc.yandex.ru/metrika/tag.js?id=105455585', 'ym');

    ym(105455585, 'init', {ssr:true, webvisor:true, clickmap:true, ecommerce:"dataLayer", accurateTrackBounce:true, trackLinks:true});
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/105455585" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3MQZEBBDDR"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-3MQZEBBDDR');
</script>
