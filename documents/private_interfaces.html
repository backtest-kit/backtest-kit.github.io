<!DOCTYPE html><html class="default" lang="en" data-base=".."><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="IE=edge"/><title>private/interfaces | backtest-kit</title><meta name="description" content="Documentation for backtest-kit"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="../assets/style.css"/><link rel="stylesheet" href="../assets/highlight.css"/><script defer src="../assets/main.js"></script><script async src="../assets/icons.js" id="tsd-icons-script"></script><script async src="../assets/search.js" id="tsd-search-script"></script><script async src="../assets/navigation.js" id="tsd-nav-script"></script><script async src="../assets/hierarchy.js" id="tsd-hierarchy-script"></script></head><body><script>document.documentElement.dataset.theme = localStorage.getItem("tsd-theme") || "os";document.body.style.display="none";setTimeout(() => app?app.showPage():document.body.style.removeProperty("display"),500)</script><header class="tsd-page-toolbar"><div class="tsd-toolbar-contents container"><div class="table-cell" id="tsd-search"><div class="field"><label for="tsd-search-field" class="tsd-widget tsd-toolbar-icon search no-caption"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-search"></use></svg></label><input type="text" id="tsd-search-field" aria-label="Search"/></div><div class="field"><div id="tsd-toolbar-links"></div></div><ul class="results"><li class="state loading">Preparing search index...</li><li class="state failure">The search index is not available</li></ul><a href="../index.html" class="title">backtest-kit</a></div><div class="table-cell" id="tsd-widgets"><a href="#" class="tsd-widget tsd-toolbar-icon menu no-caption" data-toggle="menu" aria-label="Menu"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-menu"></use></svg></a></div></div></header><div class="container container-main"><div class="col-content"><div class="tsd-page-title"><ul class="tsd-breadcrumb"><li><a href="../modules.html">backtest-kit</a></li><li><a href="private_interfaces.html">private/interfaces</a></li></ul></div><div class="tsd-panel tsd-typography"><a id="backtest-kit-api-reference" class="tsd-anchor"></a><h1 class="tsd-anchor-link">backtest-kit api reference<a href="#backtest-kit-api-reference" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h1><p><img src="../media/uml.svg" alt="schema"></p>
<p><strong>Overview:</strong></p>
<p>Backtest-kit is a production-ready TypeScript framework for backtesting and live trading strategies with crash-safe state persistence, signal validation, and memory-optimized architecture. The framework follows clean architecture principles with dependency injection, separation of concerns, and type-safe discriminated unions.</p>
<p><strong>Core Concepts:</strong></p>
<ul>
<li><strong>Signal Lifecycle:</strong> Type-safe state machine (idle → opened → active → closed) with discriminated unions</li>
<li><strong>Execution Modes:</strong> Backtest mode (historical data) and Live mode (real-time with crash recovery)</li>
<li><strong>VWAP Pricing:</strong> Volume Weighted Average Price from last 5 1-minute candles for all entry/exit decisions</li>
<li><strong>Signal Validation:</strong> Comprehensive validation ensures TP/SL logic, positive prices, and valid timestamps</li>
<li><strong>Interval Throttling:</strong> Prevents signal spam with configurable intervals (1m, 3m, 5m, 15m, 30m, 1h)</li>
<li><strong>Crash-Safe Persistence:</strong> Atomic file writes with automatic state recovery for live trading</li>
<li><strong>Async Generators:</strong> Memory-efficient streaming for backtest and live execution</li>
<li><strong>Accurate PNL:</strong> Calculation with fees (0.1%) and slippage (0.1%) for realistic simulations</li>
<li><strong>Event System:</strong> Signal emitters for backtest/live/global signals, errors, and completion events</li>
<li><strong>Graceful Shutdown:</strong> Live.background() waits for open positions to close before stopping</li>
<li><strong>Pluggable Persistence:</strong> Custom adapters for Redis, MongoDB, or any storage backend</li>
</ul>
<p><strong>Architecture Layers:</strong></p>
<ul>
<li><strong>Client Layer:</strong> Pure business logic without DI (ClientStrategy, ClientExchange, ClientFrame) using prototype methods for memory efficiency</li>
<li><strong>Service Layer:</strong> DI-based services organized by responsibility:
<ul>
<li><strong>Schema Services:</strong> Registry pattern for configuration with shallow validation (StrategySchemaService, ExchangeSchemaService, FrameSchemaService)</li>
<li><strong>Validation Services:</strong> Runtime existence validation with memoization (StrategyValidationService, ExchangeValidationService, FrameValidationService)</li>
<li><strong>Connection Services:</strong> Memoized client instance creators (StrategyConnectionService, ExchangeConnectionService, FrameConnectionService)</li>
<li><strong>Global Services:</strong> Context wrappers for public API (StrategyGlobalService, ExchangeGlobalService, FrameGlobalService)</li>
<li><strong>Logic Services:</strong> Async generator orchestration (BacktestLogicPrivateService, LiveLogicPrivateService)</li>
<li><strong>Markdown Services:</strong> Auto-generated reports with tick-based event log (BacktestMarkdownService, LiveMarkdownService)</li>
</ul>
</li>
<li><strong>Persistence Layer:</strong> Crash-safe atomic file writes with PersistSignalAdaper, extensible via PersistBase</li>
<li><strong>Event Layer:</strong> Subject-based emitters (signalEmitter, errorEmitter, doneEmitter) with queued async processing</li>
</ul>
<p><strong>Key Design Patterns:</strong></p>
<ul>
<li><strong>Discriminated Unions:</strong> Type-safe state machines without optional fields</li>
<li><strong>Async Generators:</strong> Stream results without memory accumulation, enable early termination</li>
<li><strong>Dependency Injection:</strong> Custom DI container with Symbol-based tokens</li>
<li><strong>Memoization:</strong> Client instances cached by schema name using functools-kit</li>
<li><strong>Context Propagation:</strong> Nested contexts using di-scoped (ExecutionContext + MethodContext)</li>
<li><strong>Registry Pattern:</strong> Schema services use ToolRegistry for configuration management</li>
<li><strong>Singleshot Initialization:</strong> One-time operations with cached promise results</li>
<li><strong>Persist-and-Restart:</strong> Stateless process design with disk-based state recovery</li>
<li><strong>Pluggable Adapters:</strong> PersistBase as base class for custom storage backends</li>
<li><strong>Queued Processing:</strong> Sequential event handling with functools-kit queued wrapper</li>
</ul>
<p><strong>Data Flow (Backtest):</strong></p>
<ol>
<li>User calls Backtest.background(symbol, context) or Backtest.run(symbol, context)</li>
<li>Validation services check strategyName, exchangeName, frameName existence</li>
<li>BacktestLogicPrivateService.run(symbol) creates async generator with yield</li>
<li>MethodContextService.runInContext sets strategyName, exchangeName, frameName</li>
<li>Loop through timeframes, call StrategyGlobalService.tick()</li>
<li>ExecutionContextService.runInContext sets symbol, when, backtest=true</li>
<li>ClientStrategy.tick() checks VWAP against TP/SL conditions</li>
<li>If opened: fetch candles and call ClientStrategy.backtest(candles)</li>
<li>Yield closed result and skip timeframes until closeTimestamp</li>
<li>Emit signals via signalEmitter, signalBacktestEmitter</li>
<li>On completion emit doneEmitter with { backtest: true, symbol, strategyName, exchangeName }</li>
</ol>
<p><strong>Data Flow (Live):</strong></p>
<ol>
<li>User calls Live.background(symbol, context) or Live.run(symbol, context)</li>
<li>Validation services check strategyName, exchangeName existence</li>
<li>LiveLogicPrivateService.run(symbol) creates infinite async generator with while(true)</li>
<li>MethodContextService.runInContext sets schema names</li>
<li>Loop: create when = new Date(), call StrategyGlobalService.tick()</li>
<li>ClientStrategy.waitForInit() loads persisted signal state from PersistSignalAdaper</li>
<li>ClientStrategy.tick() with interval throttling and validation</li>
<li>setPendingSignal() persists state via PersistSignalAdaper.writeSignalData()</li>
<li>Yield opened and closed results, sleep(TICK_TTL) between ticks</li>
<li>Emit signals via signalEmitter, signalLiveEmitter</li>
<li>On stop() call: wait for lastValue?.action === 'closed' before breaking loop (graceful shutdown)</li>
<li>On completion emit doneEmitter with { backtest: false, symbol, strategyName, exchangeName }</li>
</ol>
<p><strong>Event System:</strong></p>
<ul>
<li><strong>Signal Events:</strong> listenSignal, listenSignalBacktest, listenSignalLive for tick results (idle/opened/active/closed)</li>
<li><strong>Error Events:</strong> listenError for background execution errors (Live.background, Backtest.background)</li>
<li><strong>Completion Events:</strong> listenDone, listenDoneOnce for background execution completion with DoneContract</li>
<li><strong>Queued Processing:</strong> All listeners use queued wrapper from functools-kit for sequential async execution</li>
<li><strong>Filter Predicates:</strong> Once listeners (listenSignalOnce, listenDoneOnce) accept filter function for conditional triggering</li>
</ul>
<p><strong>Performance Optimizations:</strong></p>
<ul>
<li>Memoization of client instances by schema name</li>
<li>Prototype methods (not arrow functions) for memory efficiency</li>
<li>Fast backtest method skips individual ticks</li>
<li>Timeframe skipping after signal closes</li>
<li>VWAP caching per tick/candle</li>
<li>Async generators stream without array accumulation</li>
<li>Interval throttling prevents excessive signal generation</li>
<li>Singleshot initialization runs exactly once per instance</li>
<li>LiveMarkdownService bounded queue (MAX_EVENTS = 25) prevents memory leaks</li>
<li>Smart idle event replacement (only replaces if no open/active signals after last idle)</li>
</ul>
<p><strong>Use Cases:</strong></p>
<ul>
<li>Algorithmic trading with backtest validation and live deployment</li>
<li>Strategy research and hypothesis testing on historical data</li>
<li>Signal generation with ML models or technical indicators</li>
<li>Portfolio management tracking multiple strategies across symbols</li>
<li>Educational projects for learning trading system architecture</li>
<li>Event-driven trading bots with real-time notifications (Telegram, Discord, email)</li>
<li>Multi-exchange trading with pluggable exchange adapters</li>
</ul>
<p><strong>Test Coverage:</strong></p>
<p>The framework includes comprehensive unit tests using worker-testbed (tape-based testing):</p>
<ul>
<li><strong>exchange.test.mjs:</strong> Tests exchange helper functions (getCandles, getAveragePrice, getDate, getMode, formatPrice, formatQuantity) with mock candle data and VWAP calculations</li>
<li><strong>event.test.mjs:</strong> Tests Live.background() execution and event listener system (listenSignalLive, listenSignalLiveOnce, listenDone, listenDoneOnce) for async coordination</li>
<li><strong>validation.test.mjs:</strong> Tests signal validation logic (valid long/short positions, invalid TP/SL relationships, negative price detection, timestamp validation) using listenError for error handling</li>
<li><strong>pnl.test.mjs:</strong> Tests PNL calculation accuracy with realistic fees (0.1%) and slippage (0.1%) simulation</li>
<li><strong>backtest.test.mjs:</strong> Tests Backtest.run() and Backtest.background() with signal lifecycle verification (idle → opened → active → closed), listenDone events, early termination, and all close reasons (take_profit, stop_loss, time_expired)</li>
<li><strong>callbacks.test.mjs:</strong> Tests strategy lifecycle callbacks (onOpen, onClose, onTimeframe) with correct parameter passing, backtest flag verification, and signal object integrity</li>
<li><strong>report.test.mjs:</strong> Tests markdown report generation (Backtest.getReport, Live.getReport) with statistics validation (win rate, average PNL, total PNL, closed signals count) and table formatting</li>
</ul>
<p>All tests follow consistent patterns:</p>
<ul>
<li>Unique exchange/strategy/frame names per test to prevent cross-contamination</li>
<li>Mock candle generator (getMockCandles.mjs) with forward timestamp progression</li>
<li>createAwaiter from functools-kit for async coordination</li>
<li>Background execution with Backtest.background() and event-driven completion detection</li>
</ul>
<a id="backtest-kit-interfaces" class="tsd-anchor"></a><h1 class="tsd-anchor-link">backtest-kit interfaces<a href="#backtest-kit-interfaces" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h1><a id="interface-walkerstopcontract" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface WalkerStopContract<a href="#interface-walkerstopcontract" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface defines a signal that's sent when a walker, which is a component managing a trading strategy, needs to be stopped. Think of it as a notification that something’s interrupting the automated trading process.</p>
<p>It provides key information about what's being stopped, specifically the trading symbol involved, the name of the strategy being paused, and the specific walker that’s being halted. This allows different parts of the system to react to a stop signal and ensure the correct trading activity is interrupted. Because systems might run multiple strategies at once, the walker name lets you target specific walkers within a symbol.</p>
<a id="interface-walkerstatisticsmodel" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface WalkerStatisticsModel<a href="#interface-walkerstatisticsmodel" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The WalkerStatisticsModel helps organize and present the results of your backtesting experiments. Think of it as a container holding all the information you need to compare different trading strategies. It builds upon the existing IWalkerResults interface and adds extra details specifically for comparing strategy performance. Inside, you’ll find <code>strategyResults</code>, which is simply a list of all the results generated by the different strategies you tested—giving you a clear view of how they stack up against each other.</p>
<a id="interface-walkercontract" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface WalkerContract<a href="#interface-walkercontract" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The <code>WalkerContract</code> represents updates during a comparison of different trading strategies. Think of it as a notification that a strategy has finished its test run and its results are available. Each notification includes details like the name of the strategy, the exchange and frame it was tested on, the trading symbol, and the specific statistic calculated (like Sharpe Ratio or drawdown).</p>
<p>You’ll also find the strategy’s performance metrics, along with the overall best performance seen so far and how many strategies have been tested in total. This allows you to monitor the progress of strategy comparisons and see which ones are performing the best as the testing progresses. It essentially provides a running commentary on the backtesting process.</p>
<a id="interface-walkercompletecontract" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface WalkerCompleteContract<a href="#interface-walkercompletecontract" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface describes the event that signals the completion of a backtesting process. It’s triggered when all the strategies being compared have finished running and the final results are ready.</p>
<p>The event package contains vital details about the backtest, like the name of the walker that ran it, the trading symbol being analyzed, the exchange and timeframe used.</p>
<p>You'll also find information about the optimization metric, the total number of strategies tested, and, crucially, which strategy performed the best. This includes the best metric value achieved and the full statistical breakdown for that top-performing strategy. Essentially, it gives you a complete picture of the backtest's outcome.</p>
<a id="interface-validationerrornotification" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ValidationErrorNotification<a href="#interface-validationerrornotification" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This notification lets you know when a validation check fails during your backtesting or live trading. It's essentially a signal that something went wrong with the rules you've set up to ensure your trades are safe and reasonable.</p>
<p>Each notification includes a unique ID to help you track it, a detailed error message you can understand, and all the technical information about the error—like the stack trace—to help you diagnose the problem.  Importantly, this notification always indicates it originated from the live context, meaning it isn't specific to a backtest simulation.</p>
<a id="interface-validateargs" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ValidateArgs<a href="#interface-validateargs" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface, <code>ValidateArgs</code>, is like a checklist for ensuring the names you’re using in your backtesting setup are correct. It outlines all the key names – like the exchange you're trading on, the timeframe you’re using, the strategy you’ve chosen, and even the risk profile and sizing methods – that need to be valid.</p>
<p>Think of it as a way to double-check that you haven't misspelled anything or are trying to use a name that doesn’t exist in your system.</p>
<p>Each property within <code>ValidateArgs</code> expects an enum object, which provides a limited, pre-defined set of acceptable names.  This keeps things consistent and helps prevent errors.</p>
<a id="interface-trailingtakecommitnotification" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface TrailingTakeCommitNotification<a href="#interface-trailingtakecommitnotification" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This notification tells you when a trailing take profit order has been executed. It's fired whenever the trailing take action happens, whether you're backtesting or trading live.</p>
<p>You'll find key details included, like a unique ID for the notification, the exact time it occurred, and whether it happened during a backtest. The notification provides information about the trade itself – the symbol, the strategy that triggered it, and the exchange used.</p>
<p>It also gives you a breakdown of the price points involved, including the original take profit and stop loss prices before any trailing adjustments, as well as the effective prices after the trailing has been applied. The notification also shares details about the position, entry price, and any DCA averaging that may have occurred, along with timestamps for when the signal was initially created and when the position was activated.</p>
<a id="interface-trailingtakecommit" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface TrailingTakeCommit<a href="#interface-trailingtakecommit" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This data represents an event related to a trailing take profit strategy being executed. It tells you that the system is adjusting a take profit price based on the market's movement.</p>
<p>You'll find details like the percentage shift used to adjust the price, the current market price when the adjustment happened, and the direction of the trade – whether it's a long (buy) or short (sell) position.</p>
<p>Crucially, it includes both the updated take profit and stop-loss prices, alongside their original values <em>before</em> any trailing adjustments were made. You can also track when this event was planned and when the associated position was activated. Essentially, this provides a complete picture of a trailing take profit adjustment event, documenting all the key values involved.</p>
<a id="interface-trailingstopcommitnotification" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface TrailingStopCommitNotification<a href="#interface-trailingstopcommitnotification" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This notification lets you know when a trailing stop order has been triggered and executed. It provides a wealth of information about the trade that just happened, including a unique identifier for the notification itself, the exact time it occurred, and whether it was part of a backtest or a live trade. You'll find details like the trading symbol, the name of the strategy that generated the signal, and the exchange where the trade took place.</p>
<p>The notification also includes all the crucial pricing information, like the current market price, entry price, take profit, and stop loss levels - both their current adjusted values and their original values before any trailing adjustments. You can also see the number of entries if the position was created using a DCA (dollar cost averaging) strategy. Finally, timestamps related to signal scheduling and pending status provide a full timeline of the trade's lifecycle.</p>
<a id="interface-trailingstopcommit" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface TrailingStopCommit<a href="#interface-trailingstopcommit" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This describes an event related to a trailing stop order being triggered. It provides details about how the stop loss price has been adjusted.</p>
<p>The <code>action</code> property confirms that this event specifically concerns a trailing stop.</p>
<p>You’ll find the <code>percentShift</code> which indicates how much the stop loss price has moved, based on a percentage. The <code>currentPrice</code> shows the market price at the moment the trailing adjustment happened.</p>
<p>The event also includes essential information about the trade itself, like whether it's a <code>position</code> of &quot;long&quot; (buying) or &quot;short&quot; (selling), and the <code>priceOpen</code> where the trade was initiated.</p>
<p>You can track the current <code>priceTakeProfit</code> and <code>priceStopLoss</code>, along with their <code>original</code> values before any trailing adjustments occurred. Finally, <code>scheduledAt</code> tells you when the signal was initially created and <code>pendingAt</code> marks when the position actually started.</p>
<a id="interface-tickevent" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface TickEvent<a href="#interface-tickevent" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface, <code>TickEvent</code>, acts as a central container for all the data related to a trading event. Think of it as a single record describing what happened – whether a trade was opened, closed, scheduled, or cancelled. It brings together key pieces of information like the timestamp of the event, the type of action taken (opened, scheduled, etc.), and details about the trade itself, such as the symbol being traded, the signal ID, and associated prices.</p>
<p>Many properties are specific to certain actions – for example, take profit and stop loss prices are mainly relevant for scheduled, waiting, opened, active, closed and cancelled events. The interface also provides details about DCA averaging through the <code>totalEntries</code> field and allows tracking modifications to prices with <code>originalPriceTakeProfit</code> and <code>originalPriceStopLoss</code>.  For completed trades, you'll find information like the close reason, duration, and realized PNL.  Finally, <code>pendingAt</code> and <code>scheduledAt</code> give context to when specific states were reached.</p>
<a id="interface-strategystatisticsmodel" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface StrategyStatisticsModel<a href="#interface-strategystatisticsmodel" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This model holds a collection of statistics related to your trading strategy's actions. Think of it as a detailed report card for your strategy, showing how many times it performed certain actions.</p>
<p>You’ll find a comprehensive list of every event that occurred, along with the total number of events recorded.</p>
<p>It breaks down the counts of specific event types, such as canceling scheduled orders, closing pending orders, taking partial profits or losses, using trailing stops, setting breakeven prices, and activating scheduled actions.</p>
<p>There’s also a count for average buy (dollar-cost averaging) events. This information helps you analyze your strategy's behavior and identify areas for optimization.</p>
<a id="interface-strategyevent" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface StrategyEvent<a href="#interface-strategyevent" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This data structure holds all the important details about actions your trading strategy takes, making it easy to create reports and understand what happened during a backtest or live trading. Each event contains a timestamp and identifies the specific strategy, symbol, and exchange involved. You’ll find information about the signal that triggered the action, along with the price at which the action was executed, like the current market price.</p>
<p>For actions like partial profit taking or trailing stops, it includes the percentage used for those calculations.  If an action was scheduled or pending, it provides unique IDs to track its status.</p>
<p>You'll also get key details about the trade itself, such as the trade direction (long or short), entry price, and the take profit and stop loss prices—both the initially set values and the adjusted values if trailing was in use.  For strategies using dollar-cost averaging (DCA), it tracks the total entries and the final, averaged entry price. Lastly, timestamps denote when the signal was first created and when the position became pending, giving a complete picture of the trading timeline.</p>
<a id="interface-signalschedulednotification" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface SignalScheduledNotification<a href="#interface-signalschedulednotification" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This notification tells you when a trading signal has been planned for execution in the future. It's like getting a heads-up that a trade is going to happen, but not <em>right now</em>. Each notification has a unique ID and timestamp indicating exactly when the signal was scheduled.</p>
<p>You'll find details like the trading symbol (e.g., BTCUSDT), the name of the strategy that generated the signal, and the exchange it’s intended for. It also includes key price points – the target entry price, take profit, and stop loss levels – along with their original values before any adjustments.</p>
<p>If you're backtesting, the notification will clearly indicate that.  You'll also see information about any dollar-cost averaging (DCA) strategy used, with the total number of planned entries. Finally, the notification shares the current market price at the time of scheduling, alongside the timestamp of its creation.</p>
<a id="interface-signalopenednotification" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface SignalOpenedNotification<a href="#interface-signalopenednotification" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This notification lets you know when a new trade has started within your backtest kit system. It provides a wealth of information about the trade, including a unique ID for tracking purposes and the exact time it was opened. You’ll find details like the trading symbol (e.g., BTCUSDT), the strategy that triggered the trade, and whether it’s a &quot;long&quot; (buy) or &quot;short&quot; (sell) position.</p>
<p>The notification also breaks down the price points, including the entry price, take profit, and stop loss levels, and even gives you the original prices before any adjustments were made.  For trades using dollar-cost averaging (DCA), the number of entries is included.  Finally, a note field lets the strategy author add a short description for extra context. The timestamps provide a complete timeline from signal creation to the position becoming active.</p>
<a id="interface-signaldata1" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface SignalData$1<a href="#interface-signaldata1" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This data structure holds all the important details about a completed trading signal. Think of it as a record of one specific trade.</p>
<p>It tells you which strategy created the signal, a unique ID for that signal, and the symbol being traded (like BTC/USD). You’ll also find information about whether the trade was a long or short position, the profit and loss (PNL) as a percentage, and why the signal was closed. Finally, it records the exact times the signal was opened and closed, allowing you to track its duration and performance.</p>
<a id="interface-signalcommitbase" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface SignalCommitBase<a href="#interface-signalcommitbase" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface defines the core information shared by all signal commitment events within the backtest-kit framework. Every signal, whether generated during a backtest or in a live trading environment, will include details like the trading symbol (e.g., BTCUSDT), the name of the strategy that produced it, and the exchange being used.</p>
<p>Backtesting signals have a 'frameName' associated with them, indicating the timeframe used during the backtest, while live signals won’t. You’ll also find a unique identifier for each signal, a timestamp marking when it occurred, and information about how many entries were involved in a potential DCA strategy. Importantly, the 'originalPriceOpen' field captures the initial entry price, allowing you to track how it relates to subsequent price movements and any DCA averaging that might have occurred.</p>
<a id="interface-signalclosednotification" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface SignalClosedNotification<a href="#interface-signalclosednotification" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This notification tells you when a trading position, initiated by a strategy, has been closed, whether that was due to a take profit, stop loss, or other reason. It provides a wealth of information about the trade, from its unique identifiers to the specific prices at which it was opened and closed. You’ll find details like the strategy's name, the exchange used, and whether the trade occurred in backtest or live mode.</p>
<p>The notification includes data about the original signal parameters like take profit and stop loss prices, as well as information about any DCA averaging that might have occurred. It also calculates the profit or loss as a percentage, the duration of the position, and offers an optional note for a human-readable explanation of the closure. Finally, you get timestamps for when the signal was created, when it started pending, and when the tick result was created, giving a complete timeline of the trade’s lifecycle.</p>
<a id="interface-signalcancellednotification" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface SignalCancelledNotification<a href="#interface-signalcancellednotification" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This notification tells you when a signal that was planned to be executed was cancelled before it actually happened. It provides a lot of details about the cancelled signal, so you can understand why it didn't go through.</p>
<p>You'll find information like the unique ID of the signal, the trading symbol involved (e.g., BTCUSDT), and the strategy that generated it. It also includes specifics about the planned trade, such as the intended take profit and stop-loss prices, the trade direction (long or short), and the original entry price.</p>
<p>Importantly, the notification details the reason for cancellation— whether it was due to a timeout, a price rejection, or a manual cancellation by a user. You can also see when the signal was originally scheduled and how long it waited before being cancelled. Backtest mode vs live mode is also indicated.</p>
<a id="interface-scheduledevent" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ScheduledEvent<a href="#interface-scheduledevent" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This describes the data you'll find when looking at events related to trading signals – things like when a signal was scheduled, opened, or cancelled. Think of it as a standardized way to represent all the key details about a signal's lifecycle.</p>
<p>Each event record includes a timestamp, what action was taken (scheduled, opened, or cancelled), and the specifics of the trade itself, like the symbol, signal ID, position, and prices. You’ll see details about entry prices, take profit levels, stop losses, and even how those prices might have changed.</p>
<p>If the signal involved a series of entries (like a DCA strategy), you'll find information about the total number of entries and the original entry price before averaging. For cancelled signals, you’ll also learn the reason for cancellation and a unique ID if a user initiated it. Finally, there are fields related to when the position became active, and a duration measurement for cancelled and opened signals.</p>
<a id="interface-schedulestatisticsmodel" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ScheduleStatisticsModel<a href="#interface-schedulestatisticsmodel" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The <code>ScheduleStatisticsModel</code> gives you a clear picture of how your scheduled signals are performing. It summarizes all the scheduled signals, tracking how many were scheduled, how many were activated, and how many were cancelled.</p>
<p>You can see the overall number of events and key performance indicators like cancellation and activation rates, expressed as percentages. It also calculates the average wait times for both cancelled and activated signals, allowing you to understand potential delays in your trading process. The <code>eventList</code> property provides a complete history of each individual scheduled event.</p>
<a id="interface-schedulepingcontract" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface SchedulePingContract<a href="#interface-schedulepingcontract" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This defines how the backtest-kit framework communicates about scheduled signals during their active monitoring period – that's when a signal is running but hasn't been cancelled or activated yet. Every minute, a &quot;ping&quot; event is sent out to let you know a signal is still being watched.</p>
<p>You can use these pings to keep track of what's happening with your signals, and even build custom logic to manage them.</p>
<p>Each ping includes important details like the trading symbol, the name of the strategy using it, the exchange involved, and the full data associated with the scheduled signal. You’ll also find a flag indicating whether the ping originates from a backtest (historical data) or a live trading environment, along with a timestamp for precise timing information.</p>
<p>The framework provides ways to &quot;listen&quot; for these pings, allowing you to react to them as they arrive.</p>
<a id="interface-riskstatisticsmodel" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface RiskStatisticsModel<a href="#interface-riskstatisticsmodel" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This model holds important information about risk rejections that have occurred during backtesting. It essentially gives you a breakdown of how often your risk controls are being triggered.</p>
<p>You'll find a complete list of the risk rejection events, including all the details associated with each one. The model also provides a simple count of the total number of rejections.</p>
<p>To help you understand where the rejections are coming from, you can view them grouped by the trading symbol or by the strategy being used. This lets you easily pinpoint potential problem areas in your system.</p>
<a id="interface-riskrejectionnotification" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface RiskRejectionNotification<a href="#interface-riskrejectionnotification" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This notification lets you know when a trading signal was blocked by your risk management rules. It's a way to understand why a signal didn't make it through, whether you're running a backtest or live trading. Each notification has a unique ID and a timestamp to help you track events.</p>
<p>You’ll find important details like the strategy that generated the signal, the exchange involved, and a clear explanation of why the signal was rejected. The notification also includes information about your current open positions, the market price at the time, and the proposed trade details (entry price, take profit, stop loss). If a signal ID was provided, it’s included for traceability. It also shows the intended position direction (long or short) and the estimated time until the trade expires.</p>
<a id="interface-riskevent" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface RiskEvent<a href="#interface-riskevent" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This data structure, <code>RiskEvent</code>, holds all the details whenever a trading signal is blocked by risk management rules. Think of it as a record of why a trade didn't happen.</p>
<p>Each <code>RiskEvent</code> includes information like when the rejection occurred (timestamp), which trading pair was involved (symbol), and the specifics of the signal that was rejected (<code>currentSignal</code>).</p>
<p>You'll also find details about the strategy and exchange used, along with the current market price, the number of existing open positions at the time, and a unique ID for tracking this specific rejection. A reason for the rejection (<code>rejectionNote</code>) is also included. Finally, it tells you whether this event happened during a backtest or live trading.</p>
<a id="interface-riskcontract" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface RiskContract<a href="#interface-riskcontract" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface, RiskContract, describes what happens when a trading signal is blocked due to a risk check. Think of it as a notification that a strategy wanted to make a trade, but the system said &quot;no&quot; because of pre-defined risk limits.</p>
<p>It provides details about the rejected trade, including the trading pair involved (symbol), the specifics of the signal itself (currentSignal), the name of the strategy that attempted the trade (strategyName), and the timeframe it was intended for (frameName). You’ll also find information like the exchange involved (exchangeName), the market price at the time (currentPrice), and how many other positions were already open (activePositionCount).</p>
<p>To help with tracking and troubleshooting, each rejection gets a unique ID (rejectionId) and a human-readable explanation (rejectionNote). The timestamp tells you exactly when the rejection occurred, and a flag indicates whether the rejection happened during a backtest or in live trading. This is really useful for understanding why certain trades weren’t executed and for improving your risk management rules.</p>
<a id="interface-progresswalkercontract" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ProgressWalkerContract<a href="#interface-progresswalkercontract" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The <code>ProgressWalkerContract</code> helps you keep an eye on how a backtest is progressing. It's like a little report card that's sent out while a large backtesting process is running in the background.</p>
<p>You'll see details like the name of the backtest, the exchange it's using, and the specific trading symbol being analyzed.</p>
<p>The report also tells you how many total trading strategies are involved in the backtest, how many have already been processed, and a percentage showing how close the backtest is to finishing. This allows you to understand the current state and estimate the remaining time.</p>
<a id="interface-progressbacktestcontract" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ProgressBacktestContract<a href="#interface-progressbacktestcontract" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface helps you monitor the progress of a backtest as it runs. It provides details like the exchange and strategy being used, the trading symbol, and how many historical data points (frames) are being processed. You'll see the total number of frames the backtest needs to analyze, how many it has already completed, and a percentage indicating overall progress. This allows you to keep an eye on long-running backtests and get a sense of how much time is left.</p>
<p>Essentially, it's a way to peek into the backtest's internal workings while it's calculating results.</p>
<a id="interface-performancestatisticsmodel" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface PerformanceStatisticsModel<a href="#interface-performancestatisticsmodel" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This model holds all the performance data collected during a backtest, organized by the strategy that generated it. You'll find the strategy's name clearly labeled, along with the overall count of performance events and the total time it took to gather all the statistics.</p>
<p>A key part of this model is <code>metricStats</code>, which breaks down the data further, grouping performance figures by the type of metric being tracked. Finally, the raw performance events themselves are stored in the <code>events</code> array, giving you access to the detailed data points that make up the aggregated statistics.</p>
<a id="interface-performancecontract" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface PerformanceContract<a href="#interface-performancecontract" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The PerformanceContract helps you understand how quickly different parts of your trading system are running. It's like a detailed log of what’s taking time, allowing you to spot and fix slowdowns.</p>
<p>Each entry in this contract records when something happened (timestamp), how long it took (duration), and what specifically was being done (metricType). You'll also find details connecting the metric to a particular strategy, exchange, trading symbol, and whether it's happening during a backtest or in a live trading environment.  The previous timestamp lets you track how times change over time. This is valuable for optimizing your trading setup and making sure everything runs efficiently.</p>
<a id="interface-partialstatisticsmodel" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface PartialStatisticsModel<a href="#interface-partialstatisticsmodel" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This model holds statistical information about partial trades, giving you a snapshot of how partial profits and losses are performing. It’s essentially a record of each partial event that occurred during a backtest, along with key counts and totals. You’ll find a detailed list of each partial event in the <code>eventList</code> property. The <code>totalEvents</code> property simply tells you the overall number of partial events.  You can then check <code>totalProfit</code> and <code>totalLoss</code> to see how many partial trades resulted in a profit versus a loss.</p>
<a id="interface-partialprofitcontract" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface PartialProfitContract<a href="#interface-partialprofitcontract" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface describes events that happen when a trading strategy hits a partial profit milestone, like 10%, 20%, or 30% profit.  You’ll see these events when a strategy is making money, and they’re useful for keeping track of how well it’s performing. Each event tells you which trading pair it's related to, the name of the strategy that triggered it, and the exchange and frame being used.</p>
<p>It also includes the original signal details, like the initial stop-loss and take-profit prices, along with the current market price at the time the profit level was reached. You'll find the specific profit level (10%, 20%, etc.) included as well.</p>
<p>Finally, it indicates whether the event happened during a backtest (using historical data) or live trading, and provides a timestamp to show precisely when the level was achieved. The timestamp’s meaning depends on whether it’s live or backtest mode.</p>
<a id="interface-partialprofitcommitnotification" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface PartialProfitCommitNotification<a href="#interface-partialprofitcommitnotification" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This notification lets you know when a partial profit has been taken in your trading strategy. It’s triggered whenever a portion of your position is closed to secure profits.</p>
<p>The notification includes a unique ID and timestamp to track when it happened. You’ll also see details like the trading symbol, the strategy's name, the exchange used, and a unique identifier for the signal that triggered the action.</p>
<p>It specifies what percentage of the position was closed, along with the current market price at the time. You'll find details about the trade itself – whether it was a long or short position, the original entry price, and any take profit or stop-loss prices that were in effect, both before and after any trailing adjustments.</p>
<p>You also get information on how the position was built, including the total number of DCA entries and timestamps related to signal creation, pending status, and notification generation. This comprehensive data helps you understand precisely how and when profits were secured.</p>
<a id="interface-partialprofitcommit" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface PartialProfitCommit<a href="#interface-partialprofitcommit" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This describes an event that happens when a partial profit is taken during a backtest. It tells you exactly what happened – a portion of the position was closed – and provides all the important details around that action. You'll find information like the percentage of the position that was closed, the current market price at the time, and the trade's direction (whether it was a long or short position).</p>
<p>It also includes key pricing information, such as the original entry price, the take profit and stop loss prices (both their original values and how they've been adjusted), and timestamps indicating when the signal was created and the position was activated. This gives you a complete picture of the conditions that led to the partial profit being realized.</p>
<a id="interface-partialprofitavailablenotification" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface PartialProfitAvailableNotification<a href="#interface-partialprofitavailablenotification" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This notification lets you know when a trading strategy has reached a specific profit milestone, like 10%, 20%, or 30% gain. It's a way to track progress during backtesting or live trading.</p>
<p>Each notification includes a unique identifier and timestamp, along with details like the trading symbol, the strategy's name, and the exchange it was executed on. You’ll also find information about the trade itself, including the entry price, the trade direction (long or short), and the effective take profit and stop-loss prices, along with their original values before any adjustments were made.</p>
<p>The notification also contains details about how the trade was entered, such as the total number of DCA entries if averaging was used, and timestamps related to signal creation and the position going pending. This detailed information allows for comprehensive analysis and monitoring of strategy performance.</p>
<a id="interface-partiallosscontract" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface PartialLossContract<a href="#interface-partiallosscontract" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The <code>PartialLossContract</code> represents when a trading strategy hits a predefined loss level during either backtesting or live trading. Think of it as a notification that the strategy's performance has degraded to a specific point, such as a 10% or 20% loss from its initial entry price.</p>
<p>It provides key details about this loss event, including the trading pair involved (symbol), the name of the strategy generating the signal, the exchange and frame it’s running on, and the current market price at the time the loss level was triggered. Crucially, it also includes all the original signal data, like the initial stop-loss and take-profit prices.</p>
<p>Each level (like 10%, 20%, etc.) is only reported once per signal, even if multiple levels are reached quickly. You can use these events to monitor how your strategies are performing, track potential stop-loss executions, and generate reports on drawdown. The <code>backtest</code> flag tells you if the event came from a historical simulation or live trading. Finally, the timestamp indicates precisely when the loss level was detected – either the real-time moment in live trading or the timestamp of the candle in backtesting.</p>
<a id="interface-partiallosscommitnotification" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface PartialLossCommitNotification<a href="#interface-partiallosscommitnotification" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This notification lets you know when a partial loss of a position has been executed. It provides a detailed snapshot of the trade at the moment the partial loss occurred. You'll find information like a unique ID for the notification, the exact time it happened, and whether it's happening in a backtest or live trading environment.</p>
<p>The notification also includes specifics about the trade itself – the trading pair (like BTCUSDT), the strategy that triggered it, the exchange used, and the signal's unique identifier.  You’ll see details like the percentage of the position that was closed, the current market price, and the trade direction (long or short).</p>
<p>Beyond just the immediate action, the notification also includes the original entry price, take profit, stop loss levels, and details about any DCA averaging that might have been applied.  Timestamps for when the signal was created, pending, and ultimately executed help provide a complete timeline of the trade’s lifecycle.</p>
<a id="interface-partiallosscommit" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface PartialLossCommit<a href="#interface-partiallosscommit" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This describes an event representing a partial closing of a trading position due to a loss. It tells you exactly what happened: a portion of the position was closed, and provides all the relevant details surrounding that action. You’ll find information like the percentage of the position that was closed, the current market price at the time, and whether it was a long or short position.</p>
<p>Crucially, it also includes both the original and adjusted take profit and stop loss prices, letting you see how trailing might have influenced those levels. The <code>scheduledAt</code> and <code>pendingAt</code> timestamps allow you to track when the signal was created and when the position initially became active. Overall, it’s a complete snapshot of a partial loss event within your backtest.</p>
<a id="interface-partiallossavailablenotification" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface PartialLossAvailableNotification<a href="#interface-partiallossavailablenotification" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This notification tells you when a trading strategy has reached a pre-defined loss level, such as a 10% or 20% loss. It's a signal that something might be happening with your trade and could be useful for risk management or further analysis.</p>
<p>Each notification includes a unique ID and timestamp, along with details like the trading symbol, strategy name, and the exchange it originated from. You'll find important information about the trade itself, including the entry price, take profit and stop loss levels (both original and adjusted), trade direction (long or short), and how many DCA entries were involved. It also indicates whether the notification is coming from a backtest or live trading environment. The notification includes the original entry price, and timestamps tracking when the signal was initially created, when it went pending, and when the notification itself was generated.</p>
<a id="interface-partialevent" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface PartialEvent<a href="#interface-partialevent" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface, <code>PartialEvent</code>, acts as a central place to store information about profit and loss milestones during a trade. Think of it as a snapshot of key data points captured whenever a trade hits a profit or loss level, like 10%, 20%, or 30%.  It bundles details such as the exact time the event occurred, whether it was a profit or loss, the trading pair involved, and the strategy that generated the signal.</p>
<p>You'll find crucial information here, including the current market price, entry price, take profit target, stop loss levels, and even the original prices set when the trade was first initiated. If you’re using dollar-cost averaging (DCA), it keeps track of the number of entries and the original entry price before averaging.  There's also a field for a human-readable note explaining the reasoning behind the signal and timestamps for when the position became active and when the signal was scheduled. Finally, a flag indicates whether the trade is happening in backtest or live mode.</p>
<a id="interface-metricstats" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface MetricStats<a href="#interface-metricstats" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This data structure neatly organizes statistics calculated for a particular performance metric, such as order execution time or message processing duration. It tells you how many times a specific event was recorded, the total time it took across all instances, and key duration-related metrics. You'll find the average, minimum, and maximum durations, alongside measures of variability like standard deviation and percentiles (p95 and p99), providing a detailed view of performance spread.</p>
<p>Furthermore, it includes details about the time spent waiting between events, with the average, minimum, and maximum wait times also provided. Essentially, it gives you a comprehensive picture of how long things take and how consistent they are.</p>
<p>The <code>metricType</code> property identifies the specific metric these numbers represent.</p>
<a id="interface-message" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface Message<a href="#interface-message" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>Each message within the chat history represents a single turn in the conversation. It tells you who sent the message – whether it was a system instruction, something the user typed, or a response from the AI assistant. The <code>role</code> property clearly identifies the sender, and the <code>content</code> property holds the actual text of the message itself. Essentially, this structure provides a way to track and understand the flow of the entire conversation.</p>
<a id="interface-livestatisticsmodel" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface LiveStatisticsModel<a href="#interface-livestatisticsmodel" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This model holds a collection of statistical data derived from live trading activity, giving you a detailed view of your performance. It keeps track of every event – from idle periods to signal openings, activity, and closures – storing them in the eventList. You'll find key numbers like the total number of events processed, the total closed signals, and the counts of winning and losing trades.</p>
<p>It also calculates crucial metrics to assess profitability and risk. The win rate shows the percentage of successful trades, while the average PNL and total PNL reflect overall profitability. To gauge risk, you can examine the standard deviation, Sharpe Ratio, and annualized Sharpe Ratio. Finally, metrics like certainty ratio and expected yearly returns offer further insights into the reliability and potential of your trading strategy. Keep in mind that many of these numbers will be null if the calculations are unreliable.</p>
<a id="interface-infoerrornotification" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface InfoErrorNotification<a href="#interface-infoerrornotification" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This notification helps you keep track of issues that happen during background processes, like data loading or calculations. It signals that something went wrong, but it's usually something you can recover from – the system won’t completely stop.</p>
<p>Each notification has a unique identifier (<code>id</code>) so you can pinpoint exactly what happened. It also includes a human-readable explanation of the problem (<code>message</code>) and the technical details of the error itself (<code>error</code>), which might contain a stack trace and extra information for debugging.</p>
<p>Importantly, these notifications always indicate errors occurring outside of the main backtesting process (<code>backtest</code> is always false), meaning they're related to things happening in the background.</p>
<a id="interface-iwalkerstrategyresult" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IWalkerStrategyResult<a href="#interface-iwalkerstrategyresult" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface describes the outcome of running a trading strategy within a backtest comparison. Each strategy's result is packaged into this structure, providing a clear way to understand its performance. It includes the strategy's name, a detailed set of statistics summarizing its backtest results, and a specific metric value used for comparing it against other strategies.  Finally, a rank is assigned to each strategy, indicating its position relative to the others based on the chosen metric – with a rank of 1 representing the best performing strategy.</p>
<a id="interface-iwalkerschema" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IWalkerSchema<a href="#interface-iwalkerschema" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The IWalkerSchema lets you set up A/B tests to compare different trading strategies. Think of it as a recipe for running a controlled experiment on your trading algorithms.</p>
<p>You give it a unique name so you can identify it, and optionally a note for yourself to remember what it's for.</p>
<p>Crucially, you specify the exchange and timeframe you want to use for <em>all</em> the strategies in the test, ensuring a level playing field.</p>
<p>The schema lists the names of the strategies you want to compare – these strategies need to be registered separately beforehand.</p>
<p>You also select a metric, like Sharpe Ratio, that you'll use to determine which strategy performs best.  You can even provide callbacks to be notified at various points during the backtesting process.</p>
<a id="interface-iwalkerresults" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IWalkerResults<a href="#interface-iwalkerresults" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This object holds all the information gathered after running a complete backtest comparison – think of it as the final report card for your trading strategies. It tells you exactly which asset (symbol) was tested, what exchange was used for the backtest, which specific testing process (walker) was employed, and what timeframe (frame) was used for the analysis. Essentially, it provides context for understanding the results you'll find elsewhere in the backtest-kit system. You can use this to quickly identify the scope and parameters of a particular backtesting run.</p>
<a id="interface-iwalkercallbacks" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IWalkerCallbacks<a href="#interface-iwalkercallbacks" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface lets you tap into the backtesting process and react to what’s happening. You can use it to monitor the progress of your strategy comparisons and handle different outcomes.</p>
<p>Specifically, <code>onStrategyStart</code> is triggered when a new strategy's backtest begins, allowing you to log the start or prepare for data processing. <code>onStrategyComplete</code> is called once a strategy's backtest is finished, giving you access to key statistics and metrics for that run. If a strategy encounters a problem, <code>onStrategyError</code> will notify you with details about the error. Finally, <code>onComplete</code> signals the end of the entire backtesting session, providing the combined results from all strategies.</p>
<p>These callbacks give you fine-grained control and visibility into the backtesting workflow.</p>
<a id="interface-itrailingtakecommitrow" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ITrailingTakeCommitRow<a href="#interface-itrailingtakecommitrow" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface represents a single step in a sequence for managing trailing take profit and commitment orders. Think of it as a record of what needs to happen—whether it's adjusting a trailing stop or executing a commitment—and how much to change it based on price movement.  It stores the type of action being taken (&quot;trailing-take&quot;), the percentage shift needed (like moving the stop loss up or down by a certain percentage), and the price at which the trailing was initially established.  Essentially, it’s a snapshot of a specific trailing take profit/commitment adjustment.</p>
<a id="interface-itrailingstopcommitrow" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ITrailingStopCommitRow<a href="#interface-itrailingstopcommitrow" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface describes a record representing a trailing stop order that needs to be executed. It’s essentially a message telling the system to adjust a trade based on a trailing stop loss.</p>
<p>The <code>action</code> property always indicates that this is a trailing stop related action.</p>
<p><code>percentShift</code> defines the percentage amount to shift the stop loss, so it dictates how much the stop loss moves alongside the price.</p>
<p>Finally, <code>currentPrice</code> stores the price level when the trailing stop was initially set, providing context for the shift calculation.</p>
<a id="interface-istrategytickresultwaiting" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IStrategyTickResultWaiting<a href="#interface-istrategytickresultwaiting" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface, <code>IStrategyTickResultWaiting</code>, describes what happens when a trading strategy is actively waiting for a signal to activate. Think of it as a holding pattern – the strategy has a signal set to trigger, but the market price hasn't reached the entry point yet.</p>
<p>You’ll receive this type of result repeatedly while the strategy is monitoring for that trigger.</p>
<p>It provides key information about the situation: the strategy's name, the exchange being used, the timeframe, the symbol being traded, and the current price being watched. Importantly, it also includes details about the scheduled signal itself and the theoretical profit and loss if the position were to be active. The <code>percentTp</code> and <code>percentSl</code> will always be zero because the position hasn’t been opened yet. Finally, it tells you whether the event is from a backtest or live trading.</p>
<a id="interface-istrategytickresultscheduled" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IStrategyTickResultScheduled<a href="#interface-istrategytickresultscheduled" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface describes what happens within the backtest-kit framework when a trading strategy generates a signal that needs to wait for a specific price to be reached before executing. Think of it as a notification that a strategy wants to enter a trade but is patiently waiting for the market conditions to align. It provides key details about the signal, like the strategy and exchange involved, the trading pair, the current price at the time the signal was generated, and whether this is part of a backtest or a live trade. The <code>action</code> property clearly flags this as a &quot;scheduled&quot; signal, indicating this waiting period. You’ll find information useful for debugging and understanding the sequence of events leading up to a trade.</p>
<a id="interface-istrategytickresultopened" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IStrategyTickResultOpened<a href="#interface-istrategytickresultopened" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface describes what happens when a new trading signal is created within the backtest-kit framework. It’s essentially a notification that a signal has been successfully generated, validated, and saved.</p>
<p>The notification includes important details about the signal itself, like the signal’s data (<code>signal</code>) and a unique ID that was assigned to it. You'll also find information for tracking purposes, such as the name of the strategy that generated the signal, the exchange and timeframe used, and the symbol being traded.</p>
<p>Crucially, the <code>currentPrice</code> property provides the VWAP price at the moment the signal was opened, and <code>backtest</code> flags whether this event happened during a backtest simulation or in a live trading environment. Finally, <code>createdAt</code> tells you precisely when this event occurred, based on the candle timestamp during backtesting or the time of execution during live trading.</p>
<a id="interface-istrategytickresultidle" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IStrategyTickResultIdle<a href="#interface-istrategytickresultidle" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface describes what happens when a trading strategy is in an idle state, meaning it's not currently generating any trading signals. It provides details about the context of that idle period, like the strategy's name, the exchange being used, the timeframe being analyzed (like one-minute or five-minute intervals), and the trading pair involved. You'll also find the current price at that moment, whether the data is from a backtest or live trading, and a timestamp marking when the idle state was recorded. Think of it as a log entry that shows things were quiet for a little while, with all the relevant information attached.</p>
<a id="interface-istrategytickresultclosed" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IStrategyTickResultClosed<a href="#interface-istrategytickresultclosed" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface represents the result of a trading signal being closed, providing a complete picture of what happened and the outcome. It tells you when the signal ended, why it was closed – whether due to a time limit, take profit, stop loss, or a manual action – and the final price used for calculations.</p>
<p>You'll find key information like the original signal parameters, the calculated profit and loss, and details about the strategy, exchange, timeframe, and trading symbol involved.  The <code>closeId</code> property is specific to situations where the signal was manually closed by a user.  Finally, the timestamp indicates when the signal was closed and when the result was recorded. This information is invaluable for analyzing strategy performance and understanding closure events.</p>
<a id="interface-istrategytickresultcancelled" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IStrategyTickResultCancelled<a href="#interface-istrategytickresultcancelled" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface, <code>IStrategyTickResultCancelled</code>, describes what happens when a signal you’ve scheduled doesn’t actually trigger a trade – maybe it was cancelled or it hit a stop-loss before a position could be opened. It gives you details about the cancelled signal, like the signal itself, the price at the time it was cancelled, and the exact timestamp.</p>
<p>You’ll find information for tracking purposes as well, including the strategy and exchange names, the timeframe being used, and the trading symbol.  A flag indicates whether this cancellation occurred during a backtest or a live trading session.</p>
<p>The <code>reason</code> property tells you <em>why</em> the signal was cancelled, and there’s even an optional <code>cancelId</code> if the cancellation was initiated by a user request. Finally, it includes a timestamp indicating when the result itself was created.</p>
<a id="interface-istrategytickresultactive" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IStrategyTickResultActive<a href="#interface-istrategytickresultactive" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface describes what happens when a trading strategy is actively monitoring a signal, waiting for a take profit, stop loss, or time expiration. It’s essentially a snapshot of the position's status at a specific moment.</p>
<p>The <code>action</code> property clearly identifies this as an &quot;active&quot; state. You'll find the <code>signal</code> that triggered the position, along with the <code>currentPrice</code> being used for monitoring, the name of the <code>strategy</code>, the <code>exchange</code>, and the <code>frameName</code> it's all associated with.</p>
<p>To help understand where you are in relation to your profit and loss targets, there are <code>percentTp</code> and <code>percentSl</code> properties that show your progress towards take profit and stop loss, respectively.</p>
<p>The <code>pnl</code> property gives you the unrealized profit and loss, taking into account fees, slippage, and any partial position closures.  A <code>backtest</code> flag tells you whether the data is from a simulation or live trading. Lastly, <code>createdAt</code> marks the exact time this status was recorded.</p>
<a id="interface-istrategyschema" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IStrategySchema<a href="#interface-istrategyschema" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This schema describes how a trading strategy is defined and registered within the backtest-kit framework. Each strategy needs a unique name to identify it.</p>
<p>You can add a note to provide extra details for other developers using your strategy.</p>
<p>The <code>interval</code> property controls how often the strategy generates trading signals, preventing it from sending signals too frequently.</p>
<p>The core of the strategy is the <code>getSignal</code> function, which is responsible for calculating whether to buy or sell an asset at a given time. This function can generate signals immediately or schedule them to execute when the price reaches a specific point.</p>
<p>You can also include optional callback functions for events like when a trade is opened or closed, and assign risk profiles and actions to the strategy for better risk management and organization.</p>
<a id="interface-istrategyresult" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IStrategyResult<a href="#interface-istrategyresult" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The <code>IStrategyResult</code> helps you organize and compare the performance of different trading strategies. It bundles together everything you need to see how a strategy did – its name, a detailed set of statistics covering its performance, and a key metric value used to rank strategies against each other. Think of it as a scorecard for each strategy you run.  The <code>strategyName</code> simply identifies the strategy.  The <code>stats</code> property holds all the comprehensive data about the backtest, and <code>metricValue</code> represents the score used to determine which strategies performed best.</p>
<a id="interface-istrategypnl" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IStrategyPnL<a href="#interface-istrategypnl" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface, <code>IStrategyPnL</code>, represents the outcome of a trading strategy’s performance, specifically focusing on profit and loss. It tells you how much your strategy made or lost, expressed as a percentage. Crucially, the prices used in this calculation—both the entry price (<code>priceOpen</code>) and the exit price (<code>priceClose</code>)—have already been adjusted to account for common trading costs like fees and slippage, making it a more realistic picture of your strategy's true profitability. Think of it as the net result after all the little costs are factored in.</p>
<a id="interface-istrategycallbacks" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IStrategyCallbacks<a href="#interface-istrategycallbacks" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface defines a set of optional callbacks that your trading strategy can use to respond to different events during a backtest or live trade. Think of them as hooks that allow your strategy to react to what's happening – like a signal opening, becoming active, or being closed.</p>
<p>You can use <code>onTick</code> to get notified on every price update. <code>onOpen</code> triggers when a new signal is validated and initiated. <code>onActive</code> lets you know when a signal is actively being monitored, while <code>onIdle</code> signals when there are no active signals. When a signal finally closes, <code>onClose</code> is called.</p>
<p>For signals that are scheduled for future entry, <code>onSchedule</code> provides a notification when they're created, and <code>onCancel</code> tells you when a scheduled signal is cancelled. There's also <code>onWrite</code> for persisting signal data during testing, and <code>onPartialProfit</code> &amp; <code>onPartialLoss</code> to be informed about favorable or unfavorable price movements before reaching take profit or stop loss levels. <code>onBreakeven</code> is called when the signal reaches its initial entry price.</p>
<p>Finally, <code>onSchedulePing</code> and <code>onActivePing</code> offer opportunities for minute-by-minute checks on scheduled and active signals, respectively, which is helpful for custom monitoring or managing signals dynamically.  These callbacks give you fine-grained control and visibility into your strategy's behavior.</p>
<a id="interface-istrategy" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IStrategy<a href="#interface-istrategy" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface defines the core methods for a trading strategy within the backtest-kit framework. Think of it as the blueprint for how a strategy interacts with the system.</p>
<p>The <code>tick</code> method is the heart of the strategy, executed on each price update. It checks for trading signals and monitors take-profit and stop-loss levels.</p>
<p>You can use <code>getPendingSignal</code> and <code>getScheduledSignal</code> to see what signals are currently active for a specific asset – useful for understanding the strategy’s current state.</p>
<p><code>getBreakeven</code> determines if the price has moved enough to cover transaction costs, allowing a potential move to a breakeven stop-loss. <code>getStopped</code> simply tells you if the strategy is paused.</p>
<p>The <code>backtest</code> function lets you quickly run simulations using historical price data to evaluate a strategy’s performance.</p>
<p><code>stopStrategy</code> lets you halt the strategy's signal generation without closing existing trades—good for controlled shutdowns. <code>cancelScheduled</code> and <code>activateScheduled</code> provide ways to manage scheduled entries without fully stopping the strategy.</p>
<p><code>closePending</code> allows you to manually close an existing trade.  You can also manage partial position closures with <code>partialProfit</code> and <code>partialLoss</code>.</p>
<p><code>trailingStop</code> and <code>trailingTake</code> adjust your stop-loss and take-profit levels dynamically as the price moves, protecting profits and limiting losses. The <code>breakeven</code> method moves your stop-loss to the entry price once a profit target is reached.</p>
<p>Finally, <code>averageBuy</code> allows you to implement a dollar-cost averaging strategy by adding new entries to an open position.  <code>dispose</code> is used to clean up when a strategy is no longer needed.</p>
<a id="interface-istorageutils" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IStorageUtils<a href="#interface-istorageutils" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface, <code>IStorageUtils</code>, acts as a blueprint for how different storage systems – like databases or files – should interact with the backtest-kit framework. Think of it as a contract: any storage system wanting to be used with backtest-kit needs to provide methods that follow this structure.</p>
<p>It defines how the system should react to events like a signal being opened, closed, scheduled, or cancelled.  There are dedicated methods for these events, allowing storage to track and potentially manage these states.</p>
<p>The interface also includes essential functions for retrieving data.  <code>findById</code> lets you look up a specific signal using its unique ID, while <code>list</code> provides a way to see all the signals currently stored. Essentially, this interface ensures a consistent way to manage signals within the backtesting environment, no matter where the data is stored.</p>
<a id="interface-istoragesignalrowscheduled" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IStorageSignalRowScheduled<a href="#interface-istoragesignalrowscheduled" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface describes a signal row that's been scheduled for execution. It's a way to track signals that are planned but haven't yet been processed. The key piece of information here is the <code>status</code> property, which will always be set to &quot;scheduled&quot; to indicate the signal's state. Essentially, it represents a signal waiting in a queue to be acted upon.</p>
<a id="interface-istoragesignalrowopened" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IStorageSignalRowOpened<a href="#interface-istoragesignalrowopened" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface represents a signal row specifically when a trade is open. It’s a simple way to track that a position has been initiated. The <code>status</code> property is always set to &quot;opened,&quot; clearly indicating the trade’s current state – it's actively running. This provides a straightforward signal for tracking and managing open positions within your backtesting or trading system.</p>
<a id="interface-istoragesignalrowclosed" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IStorageSignalRowClosed<a href="#interface-istoragesignalrowclosed" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface represents a signal row when a trading signal has been closed. It's specifically used to store information about signals that have already completed, because only closed signals have associated profit and loss data. The <code>status</code> property will always be &quot;closed&quot;, confirming its final state. Crucially, it includes a <code>pnl</code> property, which contains details about the profit and loss achieved during that trade.</p>
<a id="interface-istoragesignalrowcancelled" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IStorageSignalRowCancelled<a href="#interface-istoragesignalrowcancelled" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface represents a signal row that has been cancelled. It's a simple way to track when a signal is no longer valid or needs to be disregarded. The key piece of information here is the <code>status</code> property, which will always be set to &quot;cancelled&quot; to clearly indicate the signal’s state. Think of it as a flag saying, &quot;This signal is not active anymore.&quot;</p>
<a id="interface-istoragesignalrowbase" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IStorageSignalRowBase<a href="#interface-istoragesignalrowbase" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface defines the fundamental structure for storing signals within the backtest-kit framework. It ensures that every signal, regardless of its status, has a record of when it was created and last updated. The <code>createdAt</code> and <code>updatedAt</code> properties use timestamps to provide accurate timing information. The <code>priority</code> field helps manage the order in which signals are processed, guaranteeing consistent handling across both live and backtesting environments.</p>
<a id="interface-isizingschemakelly" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ISizingSchemaKelly<a href="#interface-isizingschemakelly" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface defines a sizing strategy based on the Kelly Criterion, a formula used to determine optimal bet sizes. When you use this schema, it tells backtest-kit that you're employing the Kelly Criterion approach for position sizing.</p>
<p>The <code>method</code> property is fixed and simply confirms that this is indeed a Kelly Criterion sizing scheme.</p>
<p>The <code>kellyMultiplier</code> property is the most important part - it’s a number between 0 and 1 that controls how aggressively your positions are sized. A value of 0.25, the default, means you're using a &quot;quarter Kelly&quot; approach, which is a more conservative strategy. Higher values increase potential returns but also raise the risk of significant losses.</p>
<a id="interface-isizingschemafixedpercentage" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ISizingSchemaFixedPercentage<a href="#interface-isizingschemafixedpercentage" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This schema defines a trading strategy where the size of each trade is determined by a fixed percentage of your capital. It's a straightforward approach for managing risk, ensuring each trade exposes you to a consistent level of potential loss relative to your total holdings.</p>
<p>The <code>method</code> property simply identifies this sizing strategy as &quot;fixed-percentage&quot;. The <code>riskPercentage</code> property is the key setting here; it's a number between 0 and 100 that dictates what percentage of your capital will be used for each trade. For example, a <code>riskPercentage</code> of 1 would mean 1% of your capital is risked on every trade.</p>
<a id="interface-isizingschemabase" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ISizingSchemaBase<a href="#interface-isizingschemabase" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface, <code>ISizingSchemaBase</code>, acts as a foundation for defining how much of your account to allocate to each trade. Think of it as a blueprint for sizing strategies. It includes essential details like a unique name to identify the sizing configuration, a place for developers to add notes for clarity, and limits on the maximum and minimum position sizes—both as percentages of your total capital and in absolute terms.  You can also optionally add callbacks to react to different sizing events.</p>
<a id="interface-isizingschemaatr" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ISizingSchemaATR<a href="#interface-isizingschemaatr" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface describes how to determine the size of your trades using the Average True Range (ATR). It’s a way to manage risk by basing your position size on the volatility of the asset you're trading.</p>
<p>You'll specify a <code>riskPercentage</code>, which represents the maximum percentage of your capital you're willing to lose on a single trade. An <code>atrMultiplier</code> is also set; this value is used to calculate the stop-loss distance based on the ATR value – essentially, the higher the ATR, the wider your stop-loss will be, reflecting greater market volatility. It's a straightforward approach for adapting your trade sizes to changing market conditions.</p>
<a id="interface-isizingparamskelly" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ISizingParamsKelly<a href="#interface-isizingparamskelly" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface defines the settings you can use to control how much of your capital a trading strategy risks on each trade when using the Kelly Criterion method. It’s primarily used when setting up the sizing behavior within the backtest-kit framework. You'll find it useful when you want to add logging to track the sizing decisions being made. The <code>logger</code> property allows you to connect a logging service to monitor what’s happening during sizing calculations, which can be beneficial for debugging or understanding the strategy's risk profile.</p>
<a id="interface-isizingparamsfixedpercentage" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ISizingParamsFixedPercentage<a href="#interface-isizingparamsfixedpercentage" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface defines how to set up a trading strategy that uses a fixed percentage of your capital for each trade. Think of it as a way to consistently risk a certain portion of your funds with every decision.</p>
<p>It requires a <code>logger</code> to help you keep track of what's happening – you can use it for debugging and understanding the strategy's behavior. This ensures you have visibility into the sizing process.</p>
<a id="interface-isizingparamsatr" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ISizingParamsATR<a href="#interface-isizingparamsatr" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface defines the settings you can use when determining how much of an asset to trade based on the Average True Range (ATR). It’s all about controlling your position size relative to market volatility.</p>
<p>The <code>logger</code> property allows you to integrate a logging service, which is helpful for debugging and understanding how your sizing calculations are working. This lets you keep track of what's happening behind the scenes and troubleshoot any issues.</p>
<a id="interface-isizingcallbacks" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ISizingCallbacks<a href="#interface-isizingcallbacks" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The <code>ISizingCallbacks</code> interface lets you hook into important moments during the sizing process, which is how your trading strategy determines how much to buy or sell. Specifically, the <code>onCalculate</code> callback gets triggered immediately after the framework computes the size of your position. This provides a chance to log the calculated size, verify that it makes sense, or potentially make adjustments based on specific conditions. Essentially, it’s a convenient way to keep an eye on the sizing process and ensure things are working as expected.</p>
<a id="interface-isizingcalculateparamskelly" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ISizingCalculateParamsKelly<a href="#interface-isizingcalculateparamskelly" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface defines the information needed to calculate your trade size using the Kelly Criterion. It’s all about figuring out how much to risk based on your historical trading performance.</p>
<p>You'll need to provide the calculation method, which in this case is specifically &quot;kelly-criterion&quot;.  Then, tell the system your win rate - the proportion of trades that result in a profit. Finally, you’ll specify your average win-loss ratio, essentially the average amount you win compared to what you lose on a losing trade. This combination of information allows backtest-kit to determine an optimal position size to maximize long-term growth.</p>
<a id="interface-isizingcalculateparamsfixedpercentage" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ISizingCalculateParamsFixedPercentage<a href="#interface-isizingcalculateparamsfixedpercentage" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface defines the information needed when you want to size your trades using a fixed percentage approach. You'll specify that the sizing method is &quot;fixed-percentage&quot; and also provide a stop-loss price. The stop-loss price is crucial because the percentage of your capital to risk is based on this level. It helps to automate trade sizing based on a pre-defined risk level tied to your stop-loss.</p>
<a id="interface-isizingcalculateparamsbase" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ISizingCalculateParamsBase<a href="#interface-isizingcalculateparamsbase" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface defines the basic information needed when figuring out how much to trade. It includes the symbol of the asset you’re trading, like &quot;BTCUSDT,&quot; your current account balance, and the price at which you plan to initially buy or sell. Think of it as a foundation – all sizing calculations build upon these core details. Having these values available ensures that trade sizing decisions are grounded in the realities of your account and the market conditions.</p>
<a id="interface-isizingcalculateparamsatr" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ISizingCalculateParamsATR<a href="#interface-isizingcalculateparamsatr" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface defines the settings you'll use when calculating trade sizes based on the Average True Range (ATR). To use ATR for sizing, you'll specify that your method is &quot;atr-based&quot;.  You also need to provide the current ATR value, which represents the average price volatility over a specific period. This value is crucial for determining how much capital you'll risk on each trade.</p>
<a id="interface-isizing" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ISizing<a href="#interface-isizing" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The <code>ISizing</code> interface is the heart of how backtest-kit determines how much of an asset to trade. Think of it as the logic that figures out your position size based on your risk tolerance and other factors.</p>
<p>It's primarily used behind the scenes by the trading strategy execution engine.</p>
<p>The key to this interface is the <code>calculate</code> method. This method takes in a set of parameters (<code>ISizingCalculateParams</code>) and then returns a promise that resolves to the calculated position size, essentially telling the system how much to buy or sell.</p>
<a id="interface-isignalrow" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ISignalRow<a href="#interface-isignalrow" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface, <code>ISignalRow</code>, represents a complete trading signal within the backtest-kit framework. Think of it as a signal that's ready to be executed – it contains all the necessary information. Each signal gets a unique ID to track it throughout the system.</p>
<p>It holds key details like the entry price, which exchange to use, the strategy that generated it, and the timeframe it applies to. Crucially, it includes timestamps for when the signal was created and when it went pending.</p>
<p>The signal also incorporates information about partial position closures, letting you accurately calculate profit and loss, as well as trailing stop-loss and take-profit prices which dynamically adjust based on market movement.  A record of entry prices for dollar cost averaging is also stored, ensuring an accurate calculation of the overall entry price. Finally, it includes some internal flags used during runtime to manage signal lifecycle.</p>
<a id="interface-isignaldto" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ISignalDto<a href="#interface-isignaldto" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The ISignalDto defines the structure for signals used within the backtest-kit framework. Think of it as a standardized way to represent a trading idea—it encapsulates everything needed to execute a trade. Each signal includes details like whether you're going long (buying) or short (selling), the entry price, target take profit price, a stop-loss level for managing risk, and an estimated duration.  You can provide an ID for the signal, but if you don't, the system will automatically generate one.  A descriptive note helps explain the reasoning behind the signal.</p>
<a id="interface-ischeduledsignalrow" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IScheduledSignalRow<a href="#interface-ischeduledsignalrow" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface describes a signal that's waiting for the market to reach a specific price before it's executed. Think of it as a signal that’s on hold until a certain price level is hit. It builds upon the basic signal representation and includes information about the target price. Once the price reaches this target, the signal transforms into a regular pending signal, ready to be triggered. Initially, the time it's been waiting (pendingAt) will match the original scheduled time, and it will be updated to the actual wait time when the signal activates. The <code>priceOpen</code> property specifies that price level.</p>
<a id="interface-ischeduledsignalcancelrow" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IScheduledSignalCancelRow<a href="#interface-ischeduledsignalcancelrow" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface represents a scheduled signal that has been cancelled by the user. It builds upon the existing <code>IScheduledSignalRow</code> to add a way to identify the specific cancellation request. The <code>cancelId</code> property holds the unique identifier associated with that user-initiated cancellation. Think of it as a reference number you can use to track why a signal was stopped.</p>
<a id="interface-iriskvalidationpayload" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IRiskValidationPayload<a href="#interface-iriskvalidationpayload" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface, <code>IRiskValidationPayload</code>, holds all the information a risk validation function needs to make a decision. It combines the usual signal data with a snapshot of your current portfolio’s health.</p>
<p>You'll find details about the signal being evaluated, represented by <code>currentSignal</code>, which is already prepared for you with essential data like the opening price.</p>
<p>It also provides a count (<code>activePositionCount</code>) and a list (<code>activePositions</code>) of all your open positions, letting you factor in existing exposure when assessing new trades. Think of it as a complete picture of your trading activity for risk assessment.</p>
<a id="interface-iriskvalidationfn" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IRiskValidationFn<a href="#interface-iriskvalidationfn" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This defines the shape of a function used to check if a trading decision is safe to execute. Think of it as a gatekeeper for your trades. If the function approves the trade (by returning nothing or <code>null</code>), everything proceeds as normal. If it flags a problem (by returning a rejection result or throwing an error), the trade is blocked, and you'll get information about <em>why</em> it was rejected. This lets you build rules to prevent risky trading behavior.</p>
<a id="interface-iriskvalidation" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IRiskValidation<a href="#interface-iriskvalidation" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface, <code>IRiskValidation</code>, helps you set up checks to make sure your trading strategies are behaving responsibly. Think of it as defining rules to keep your backtesting safe and sound.</p>
<p>It has two key parts:</p>
<ul>
<li><code>validate</code>: This is where you put the actual code that performs the validation. It's a function that checks your risk parameters and decides whether they're acceptable.</li>
<li><code>note</code>: This is an optional description. It's a helpful way to explain <em>why</em> you've set up a particular validation rule, making it easier for others (or your future self!) to understand.</li>
</ul>
<a id="interface-irisksignalrow" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IRiskSignalRow<a href="#interface-irisksignalrow" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface, <code>IRiskSignalRow</code>, helps manage risk during trading by providing key details about a position. It builds upon the existing <code>ISignalDto</code> and adds important pricing information. Specifically, it includes the entry price (<code>priceOpen</code>), the initial stop-loss price (<code>originalPriceStopLoss</code>), and the original take-profit price (<code>originalPriceTakeProfit</code>) that were set when the trade signal was created. These values are used during risk validation processes to ensure trades are handled responsibly.</p>
<a id="interface-iriskschema" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IRiskSchema<a href="#interface-iriskschema" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface, <code>IRiskSchema</code>, lets you define and register custom risk controls for your trading portfolio. Think of it as a way to build your own rules to ensure your trades stay within defined boundaries.  Each risk schema has a unique identifier, <code>riskName</code>, and you can add a <code>note</code> to explain what the schema is for.  You can also attach optional <code>callbacks</code> to be notified when a trade is rejected or allowed based on your risk rules. The core of the schema lies in the <code>validations</code> array, which holds the actual rules that will be applied. These validations can be individual functions or pre-defined validation objects, letting you create a sophisticated system for managing risk.</p>
<a id="interface-iriskrejectionresult" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IRiskRejectionResult<a href="#interface-iriskrejectionresult" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface, <code>IRiskRejectionResult</code>, helps you understand why a trading strategy's risk validation failed. When a risk check doesn't pass, this object will be returned, giving you details about the specific problem.  It includes a unique <code>id</code> to track the rejection and a helpful <code>note</code> explaining the reason in plain language. Think of it as a clear message letting you know exactly what needs to be adjusted in your strategy to ensure it's within acceptable risk parameters.</p>
<a id="interface-iriskparams" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IRiskParams<a href="#interface-iriskparams" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The <code>IRiskParams</code> object is how you configure the risk management system when it's being set up. It essentially holds all the important settings needed for the risk calculations to work correctly.</p>
<p>You'll need to provide the name of the exchange you're working with, like &quot;binance&quot; or &quot;coinbase&quot;.  A logger is also required; this allows the system to output debugging information to help you understand what's happening.</p>
<p>It's critical to specify whether you're running in backtest (historical data) mode or live trading mode.  Finally, you have the option to define a callback function called <code>onRejected</code>. This function is triggered when a trading signal is blocked by the risk controls, giving you a chance to react to the rejection, potentially for logging or further analysis.</p>
<a id="interface-iriskcheckargs" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IRiskCheckArgs<a href="#interface-iriskcheckargs" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface, <code>IRiskCheckArgs</code>, holds all the information needed to decide if a new trade should be allowed. Think of it as a safety check performed <em>before</em> a trading signal is actually created. It passes along key details like the trading pair's symbol, the signal itself, the name of the strategy requesting the trade, and information about the exchange, risk profile, and timeframe involved. You'll also find the current price and timestamp, giving you a full picture of the trading environment at that moment. It's designed to ensure trades align with established risk parameters.</p>
<a id="interface-iriskcallbacks" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IRiskCallbacks<a href="#interface-iriskcallbacks" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface lets you plug in functions to be notified about risk checks happening during your trading backtests.</p>
<p>Think of it as a way to get alerts about when a trade is blocked by risk rules, or conversely, when a trade is approved to proceed.</p>
<p>Specifically, <code>onRejected</code> will be triggered when a trade signal fails a risk check, while <code>onAllowed</code> is called when a trade signal successfully passes the risk checks. You can use these callbacks to monitor your risk settings and how they're impacting your trades.</p>
<a id="interface-iriskactiveposition" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IRiskActivePosition<a href="#interface-iriskactiveposition" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface describes a single active trading position that's being monitored for risk analysis across different trading strategies. Think of it as a snapshot of a trade in progress.</p>
<p>It includes details like which strategy opened the position, the exchange used, the trading symbol (like BTCUSDT), and whether it's a long or short trade. You'll also find key pricing information – the entry price, stop-loss, and take-profit levels – as well as estimates of how long the position has been open and the time it was initially entered. This information allows for a deeper understanding of risk exposure when combining multiple strategies.</p>
<a id="interface-irisk" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IRisk<a href="#interface-irisk" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface defines how a trading system manages risk and tracks positions. It allows you to determine if a trading signal is safe to execute based on predefined risk limits.</p>
<p>You can use it to register new trades, essentially telling the system you’ve opened a position, providing details like entry price, stop-loss levels, and estimated time. When a trade closes, you need to inform the system to remove it from tracking.</p>
<p>Think of it as a way to keep the system aware of all open positions and ensure they stay within acceptable risk boundaries.</p>
<a id="interface-ireporttarget" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IReportTarget<a href="#interface-ireporttarget" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface lets you fine-tune what information gets recorded during your backtesting process. Think of it as a way to selectively turn on or off different types of logging. You can choose to log details about your trading strategy, risk management decisions, breakeven points, partial order fills, heatmap data, walker iterations, performance, scheduled signals, live trading events, or closed backtest signals – or any combination of these. By enabling only the logging you need, you can keep your data cleaner and more focused on the areas you’re investigating. Each property (like <code>strategy</code>, <code>risk</code>, <code>breakeven</code>, etc.) is a simple boolean: <code>true</code> to enable logging, <code>false</code> to disable it.</p>
<a id="interface-ireportdumpoptions" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IReportDumpOptions<a href="#interface-ireportdumpoptions" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface, <code>IReportDumpOptions</code>, helps you control how backtest data is recorded and organized. Think of it as a set of labels that go along with each piece of information saved during a backtest. It lets you specify things like the trading pair being used (e.g., BTCUSDT), the name of the trading strategy, which exchange is involved, and even the timeframe of the data.  You can also use it to track unique signal identifiers and the name of the optimization walker being used. This detailed information makes it much easier to filter, search, and analyze your backtest results later on.</p>
<a id="interface-ipublicsignalrow" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IPublicSignalRow<a href="#interface-ipublicsignalrow" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The <code>IPublicSignalRow</code> interface provides a way to share signal information with users while maintaining transparency around how those signals are managed. It builds upon the standard signal row data by adding the original stop-loss and take-profit prices – the values set when the signal was initially created.</p>
<p>Even if the stop-loss or take-profit levels are adjusted later through trailing stop mechanisms, these original prices remain visible, allowing users to see both the initial settings and the current, potentially modified, values. This feature is great for reports and user interfaces that need to display a complete picture of a trade's parameters.</p>
<p>You’ll also find information about how much of a position has been closed through partial executions, the number of times the position has been averaged (useful for understanding dollar-cost averaging strategies), and the original entry price, which stays constant even with averaging. These extra details contribute to a more complete and understandable signal record.</p>
<a id="interface-ipositionsizekellyparams" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IPositionSizeKellyParams<a href="#interface-ipositionsizekellyparams" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The <code>IPositionSizeKellyParams</code> interface helps you calculate position sizes based on the Kelly Criterion, a popular strategy for managing risk and maximizing growth. It's a set of parameters you provide to the backtest-kit framework.</p>
<p>You'll define two key values: <code>winRate</code>, representing the proportion of winning trades, and <code>winLossRatio</code>, which reflects the average gain compared to the average loss on each trade. These values allow the framework to automatically determine how much of your capital to allocate to each trade, aiming for optimal long-term performance while considering potential drawdowns.</p>
<a id="interface-ipositionsizefixedpercentageparams" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IPositionSizeFixedPercentageParams<a href="#interface-ipositionsizefixedpercentageparams" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface defines the parameters needed for a trading strategy that uses a fixed percentage of your capital to determine position size. It's designed to let you control how much of your available funds are used for each trade, based on a predetermined percentage.</p>
<p>The key parameter is <code>priceStopLoss</code>, which specifies the price at which you'll place a stop-loss order to limit potential losses on the trade. This value is crucial for risk management when using percentage-based sizing.</p>
<a id="interface-ipositionsizeatrparams" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IPositionSizeATRParams<a href="#interface-ipositionsizeatrparams" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface holds the parameters needed for calculating your position size using an Average True Range (ATR) approach. Specifically, it defines the <code>atr</code> property, which represents the current ATR value – essentially, a measure of market volatility. You'll use this value within your trading strategy to determine how much capital to allocate to a trade, adjusting position size based on the level of market volatility. Think of it as telling the system, &quot;Here's the ATR value I'm working with.&quot;</p>
<a id="interface-ipersistbase" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IPersistBase<a href="#interface-ipersistbase" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface provides a simple set of tools for any custom storage solutions you build to interact with backtest-kit. It focuses on the core actions of reading, writing, and checking for the existence of data.</p>
<p>The <code>waitForInit</code> method is used to set up your storage and make sure it's ready to go, and it only runs once.  <code>readValue</code> retrieves an entity from storage, while <code>hasValue</code> tells you whether a particular entity is even present. <code>writeValue</code> saves an entity to storage, ensuring the save happens reliably. Finally, <code>keys</code> lets you get a list of all the entity IDs stored, ordered alphabetically, which is useful for checking and processing everything.</p>
<a id="interface-ipartialprofitcommitrow" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IPartialProfitCommitRow<a href="#interface-ipartialprofitcommitrow" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface describes a single instruction to take a partial profit during a backtest. Think of it as a line item telling the system to sell a portion of your holdings.</p>
<p>It includes the action type, which will always be &quot;partial-profit&quot; to identify it as such. You also specify the percentage of your position you want to sell with <code>percentToClose</code>. Finally, the <code>currentPrice</code> records the price at which this partial profit was actually executed, providing valuable information for analysis.</p>
<a id="interface-ipartiallosscommitrow" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IPartialLossCommitRow<a href="#interface-ipartiallosscommitrow" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface describes a single instruction for closing a portion of a trading position, specifically for partial loss scenarios. Think of it as a row in a queue, detailing exactly how much of the position should be closed and at what price.  It clearly states the action being taken is a &quot;partial-loss,&quot; the percentage of the position to close (represented as a number), and the price at which that closure occurred. This information is crucial for accurately reflecting the trade's impact within a backtesting system.</p>
<a id="interface-ipartialdata" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IPartialData<a href="#interface-ipartialdata" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This data structure, <code>IPartialData</code>, is designed to save and load progress for a trading signal. It’s a simplified version of the full signal state, focusing on the crucial information needed to resume where you left off.  Specifically, it stores the profit and loss levels that have been hit, representing key milestones in the signal's execution. Because some data types aren't easily saved, this uses arrays instead of sets to make saving and loading easier. This partial data is used by the persistence layer to keep track of signals, making it possible to restart backtesting or live trading from a saved point.</p>
<a id="interface-ipartial" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IPartial<a href="#interface-ipartial" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface, <code>IPartial</code>, helps keep track of how well trading signals are performing. It’s used internally by the backtest-kit to monitor profit and loss milestones, like when a signal hits 10%, 20%, or 30% gains or losses.</p>
<p>The <code>profit</code> method handles situations where a signal is making money, checking for new profit levels and sending out notifications. Similarly, the <code>loss</code> method does the same for signals experiencing losses.  Both methods avoid sending duplicate notifications by remembering which levels have already been reported.</p>
<p>Finally, the <code>clear</code> method is used to clean up the record of a signal when it's finished trading, whether it's hit a target profit, a stop-loss, or simply expired. This ensures the system doesn’t hold onto unnecessary information.</p>
<a id="interface-iparseargsresult" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IParseArgsResult<a href="#interface-iparseargsresult" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface, <code>IParseArgsResult</code>, represents the outcome when you're setting up your trading environment. It’s essentially a collection of flags that tell the backtest-kit framework how you want to run your trading strategy.</p>
<p>You'll see properties like <code>backtest</code>, <code>paper</code>, and <code>live</code> – these indicate whether you want to test your strategy against historical data, simulate trading with live data, or actually trade with real money. These flags are automatically determined when you provide command-line arguments to the framework.</p>
<a id="interface-iparseargsparams" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IParseArgsParams<a href="#interface-iparseargsparams" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface describes the information needed to run a trading strategy from the command line. Think of it as a blueprint for setting up your backtest – it specifies things like which cryptocurrency pair you're trading (the <code>symbol</code>), what strategy you want to use (<code>strategyName</code>), which exchange you're connecting to (<code>exchangeName</code>), and the timeframe of the historical data you'll be using (<code>frameName</code>).  Essentially, it gathers all the essential details to kick off a backtest run. You'll use these properties to configure the backtest parameters.</p>
<a id="interface-iorderbookdata" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IOrderBookData<a href="#interface-iorderbookdata" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface describes the structure of order book data, which represents the current buy and sell offers for a trading pair. It contains the <code>symbol</code> representing the trading pair, like 'BTCUSDT'.  You'll also find arrays called <code>bids</code> and <code>asks</code>.  The <code>bids</code> array lists all the buy orders, and the <code>asks</code> array lists all the sell orders, providing a snapshot of the market's depth. Each element within these arrays follows the <code>IBidData</code> structure (not defined here, but assumed to contain price and quantity).</p>
<a id="interface-inotificationutils" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface INotificationUtils<a href="#interface-inotificationutils" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface, <code>INotificationUtils</code>, acts as a blueprint for how different systems can report backtest events. Think of it as a common language for notifications – it ensures that whatever is sending information about your backtest (like a database, a logging system, or a user interface) can communicate in a consistent way.</p>
<p>It defines methods for handling key moments during a backtest, such as when a trade opens, closes, or encounters partial profits or losses. You'll also find methods for dealing with errors, both regular and critical ones, and for retrieving or clearing a log of notifications. Essentially, it's the foundation for keeping track of and responding to what’s happening within your backtest.</p>
<p>Here's a breakdown of the key functionalities:</p>
<ul>
<li><code>handleSignal</code>: Reports events related to trade actions (opening, closing, scheduling).</li>
<li><code>handlePartialProfit</code>, <code>handlePartialLoss</code>, <code>handleBreakeven</code>: Alerts you when opportunities for partial profit-taking or loss mitigation arise.</li>
<li><code>handleStrategyCommit</code>:  Signals when aspects of your strategy are put into effect.</li>
<li><code>handleRisk</code>:  Notifies you when the backtest rejects a risk parameter.</li>
<li><code>handleError</code>, <code>handleCriticalError</code>, <code>handleValidationError</code>: Provides error handling capabilities.</li>
<li><code>getData</code>: Retrieves a history of all notifications.</li>
<li><code>clear</code>:  Empties the notification log.</li>
</ul>
<a id="interface-imethodcontext" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IMethodContext<a href="#interface-imethodcontext" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The <code>IMethodContext</code> interface is like a little roadmap for your backtesting code. It carries crucial information, specifically the names of your exchange, strategy, and frame setups. Think of it as a messenger, quietly passing along these names so your code knows exactly which components to use for a particular trading simulation. It's automatically managed behind the scenes, simplifying how you reference and work with your trading strategies and infrastructure. When running live, the frame name will be empty, signaling that you're not in backtest mode.</p>
<a id="interface-imarkdowntarget" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IMarkdownTarget<a href="#interface-imarkdowntarget" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface lets you choose exactly which reports you want generated when running backtests. Think of it as a way to control the level of detail in your reporting.</p>
<p>You can enable reports for specific events like entry and exit signals from your strategy, or those rejected by risk limits.</p>
<p>There are also options to track things like when stop losses adjust to your entry price, partial profit taking, portfolio heatmaps, strategy comparisons, performance bottlenecks, signals waiting to be triggered, and even all live trading activity.</p>
<p>Finally, you can get a comprehensive backtest report summarizing your results and showing the complete trade history. By toggling these properties, you fine-tune the information you receive about your trading system's behavior.</p>
<a id="interface-imarkdowndumpoptions" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IMarkdownDumpOptions<a href="#interface-imarkdowndumpoptions" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface helps control how data is exported to Markdown files. Think of it as a set of instructions for organizing and labeling your backtest results. It specifies where the files should be saved, what to name them, and what information—like the trading pair, strategy, exchange, timeframe, and signal ID—should be included in their names. This allows you to easily find and sort through your backtesting reports.</p>
<a id="interface-ilogger" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ILogger<a href="#interface-ilogger" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The <code>ILogger</code> interface defines how different parts of the backtest-kit framework record information. It provides a consistent way to track what's happening, from initial setups to errors and everything in between. Think of it as a system-wide journal for debugging and monitoring.</p>
<p>The <code>log</code> method is for general messages about important events. <code>debug</code> is for very detailed information, usually helpful when you’re trying to figure something out. <code>info</code> messages give you a higher-level summary of what's going on, while <code>warn</code> messages highlight things that might be a problem later.</p>
<a id="interface-iheatmaprow" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IHeatmapRow<a href="#interface-iheatmaprow" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface represents a row of data within a portfolio heatmap, summarizing performance for a specific trading pair like BTCUSDT. It provides a comprehensive overview of how a trading strategy performed on that particular symbol, aggregating results across all strategies used.</p>
<p>You'll find key metrics like total profit or loss percentage, risk-adjusted return (Sharpe Ratio), and maximum drawdown to understand the overall profitability and risk profile. It also includes trade-specific data, such as the total number of trades, win/loss counts, win rate, and average profit/loss per trade.</p>
<p>Further insights are available through indicators like standard deviation, profit factor, and average win/loss amounts, along with information about the longest winning and losing streaks. Finally, expectancy gives you an idea of the expected return per trade, incorporating both win rate and average win/loss amounts.</p>
<a id="interface-iframeschema" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IFrameSchema<a href="#interface-iframeschema" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This schema defines a reusable building block for your backtesting scenarios, essentially specifying a time period and frequency for data. Think of it as a blueprint for how you want your backtest data organized.</p>
<p>Each schema has a unique name to identify it, and you can add a note to help you remember what it's for.  You’ll define the interval, like daily or hourly, and the start and end dates of your backtest.</p>
<p>You can also attach optional lifecycle callbacks to this frame schema to execute custom code at different points during the backtest process, if you need to. This allows for greater flexibility in how your backtest operates.</p>
<a id="interface-iframeparams" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IFrameParams<a href="#interface-iframeparams" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The <code>IFrameParams</code> interface defines the information needed to set up a trading frame within the backtest-kit framework. Think of it as the initial configuration for your simulated trading environment.</p>
<p>It builds upon the <code>IFrameSchema</code>, incorporating additional details.</p>
<p>Most importantly, it includes a <code>logger</code> property, which allows you to monitor and debug what’s happening during the backtest – essentially, it’s your window into the frame’s internal workings. This logger helps you understand the decisions the trading strategy is making and identify potential issues.</p>
<a id="interface-iframecallbacks" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IFrameCallbacks<a href="#interface-iframecallbacks" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface defines functions that your custom backtest environment can use to respond to specific events happening within the backtest framework.</p>
<p>Specifically, <code>onTimeframe</code> is called whenever the backtest generates a set of timeframes (like daily or weekly data). Think of it as a notification – you can use it to log information about the timeframe data being created, or to double-check that the timeframe generation is working as expected. It gives you a chance to inspect the generated dates and the interval used, allowing you to ensure data integrity or track performance metrics.</p>
<a id="interface-iframe" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IFrame<a href="#interface-iframe" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The <code>IFrames</code> interface is a core component that handles how your backtesting data is organized by time. Think of it as the engine that creates the timeline your trading strategies will run against.</p>
<p>Specifically, <code>getTimeframe</code> is the most important function – it takes a stock symbol and a timeframe name (like &quot;daily&quot; or &quot;hourly&quot;) and then figures out all the dates and times needed for your backtest.  This method provides an array of timestamps that are evenly spaced according to the timeframe you've selected.  It’s a behind-the-scenes tool used by the backtest kit to manage the flow of data and ensure consistency.</p>
<a id="interface-iexecutioncontext" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IExecutionContext<a href="#interface-iexecutioncontext" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The <code>IExecutionContext</code> object provides essential information about the current trading environment. Think of it as a package of details passed around to your trading strategies and exchanges during execution. It includes the trading symbol, like &quot;BTCUSDT&quot;, the precise timestamp of the current operation, and a flag indicating whether the code is running in a backtesting simulation or live trading. This context helps your code adapt its behavior depending on whether it's analyzing historical data or actively executing trades.</p>
<a id="interface-iexchangeschema" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IExchangeSchema<a href="#interface-iexchangeschema" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface describes how backtest-kit connects to and understands data from different cryptocurrency exchanges. Think of it as a blueprint for integrating a new exchange.</p>
<p>It requires you to define a unique name for the exchange and provides an optional space for notes.</p>
<p>The most important part is <code>getCandles</code>, which tells backtest-kit how to retrieve historical price data (candles) for a specific trading pair and time period.  You’ll also likely need to provide <code>formatQuantity</code> and <code>formatPrice</code> to correctly handle the specific decimal places used by the exchange, although sensible defaults are available.</p>
<p><code>getOrderBook</code> lets you fetch the current order book, and although it's optional, omitting it will prevent its usage.</p>
<p>Finally, <code>callbacks</code> allows you to hook into certain events related to data processing, letting you customize the system's behavior if needed.</p>
<a id="interface-iexchangeparams" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IExchangeParams<a href="#interface-iexchangeparams" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface defines the necessary components to connect to an exchange within the backtest-kit framework. Think of it as a blueprint for how the framework interacts with a specific trading platform.</p>
<p>It requires you to provide a way to log debug information, a context for the backtest (like knowing the symbol and time period), and most importantly, functions to retrieve historical data and format trade details. Specifically, you'll need to implement fetching candles (OHLCV data), formatting quantities and prices to match the exchange's rules, and obtaining order book data. The framework handles setting up some defaults, but you must provide the core functionality for interacting with your chosen exchange.</p>
<a id="interface-iexchangecallbacks" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IExchangeCallbacks<a href="#interface-iexchangecallbacks" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface defines functions that your application can use to react to data coming from an exchange. Specifically, <code>onCandleData</code> lets you handle newly received candlestick data – you'll be notified whenever a set of candles for a particular trading symbol and time interval are available. The data includes details like the symbol, the interval (e.g., 1 minute, 1 hour), the starting date and time of the data, the number of candles received, and the actual candlestick data itself. You can use this callback to update your charts, trigger alerts, or perform other actions based on the latest market data.</p>
<a id="interface-iexchange" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IExchange<a href="#interface-iexchange" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface defines how backtest-kit interacts with different cryptocurrency exchanges. It gives you tools to retrieve historical and future price data (candles) for a specific trading pair and time frame. You can also request the order book to see current buy and sell orders, and format quantities and prices to match the exchange's requirements.</p>
<p>To help with strategy analysis, it calculates the Volume Weighted Average Price (VWAP) based on recent trading activity. The system is designed to avoid looking into the future, ensuring a fair and accurate backtesting environment.</p>
<p>When retrieving candle data, you have a lot of flexibility, specifying start and end dates, or just a number of candles to fetch, all while respecting the backtesting context.</p>
<a id="interface-ientity" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IEntity<a href="#interface-ientity" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface, IEntity, serves as a foundation for all data objects that are stored and managed within the backtest-kit framework. Think of it as a common starting point, ensuring that every piece of data you persist has a consistent structure. It establishes a basic contract for how these data objects should behave and interact within the system, promoting cleaner and more organized code.</p>
<a id="interface-icommitrowbase" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ICommitRowBase<a href="#interface-icommitrowbase" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface, <code>ICommitRowBase</code>, acts as a foundation for events that involve committing data, particularly when those commits need to be handled at the right time within your trading system. Think of it as a way to queue up actions that need to be recorded – like a trade execution – and ensure they're processed correctly even if they happen during a brief interruption. It holds the basic information needed for these queued events: the trading symbol involved and a flag indicating whether the system is in backtesting mode.</p>
<a id="interface-icheckcandlesparams" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ICheckCandlesParams<a href="#interface-icheckcandlesparams" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface defines the information needed to check if your cached candle data is valid. You'll provide details like the trading pair (symbol), the exchange you're using, the timeframe of the candles (interval), and the date range you want to verify. It also lets you specify where your candle data is stored on your computer, defaulting to a common location if you don't provide it. Think of it as a way to make sure your historical price data is in the right place and covers the dates you expect.</p>
<a id="interface-icandledata" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ICandleData<a href="#interface-icandledata" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface defines the structure of a single candlestick, representing a snapshot of price action and volume over a specific time interval. Think of it as a standardized way to represent one bar of data on a price chart. Each candlestick holds information about when it began (<code>timestamp</code>), the price when it opened (<code>open</code>), the highest and lowest prices reached (<code>high</code>, <code>low</code>), the price when it closed (<code>close</code>), and the total trading volume during that period (<code>volume</code>). This data is essential for backtesting trading strategies and performing calculations like VWAP.</p>
<a id="interface-icachecandlesparams" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ICacheCandlesParams<a href="#interface-icachecandlesparams" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface defines the information needed to pre-load historical candlestick data for your backtests. Think of it as a blueprint for telling the system <em>what</em> data to download and store.</p>
<p>You'll specify the trading pair (like &quot;BTCUSDT&quot;), the exchange you're using, the timeframe of the candles (e.g., 1-minute or 4-hour), and the date range you want to cover. By providing these details, backtest-kit can efficiently fetch and save the candles you need, so your backtesting runs smoothly without constantly downloading data.</p>
<a id="interface-ibreakevendata" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IBreakevenData<a href="#interface-ibreakevendata" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface, <code>IBreakevenData</code>, is designed to store information about whether a breakeven point has been hit for a specific trading signal. It's a simplified version of the more complex <code>IBreakevenState</code>, made specifically for saving and loading data, like when persisting your backtest results. Think of it as a snapshot – it tells you if the breakeven condition was met, and that’s all. The <code>reached</code> property is a simple <code>true</code> or <code>false</code> value indicating whether breakeven was achieved. It’s used to efficiently store and retrieve this crucial state information.</p>
<a id="interface-ibreakevencommitrow" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IBreakevenCommitRow<a href="#interface-ibreakevencommitrow" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface represents a single row of data related to a breakeven commit, which is a process used in trading strategies. Each row describes an action taken – specifically, a &quot;breakeven&quot; action – along with the price at the time that action was triggered. The <code>currentPrice</code> tells you the market price when the breakeven point was established. Essentially, it tracks when and at what price a trader adjusted their strategy to reach a breakeven position.</p>
<a id="interface-ibreakeven" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IBreakeven<a href="#interface-ibreakeven" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface helps track when a trade's stop-loss can be moved to the entry price, essentially hitting a breakeven point. It's used by components that manage trading signals.</p>
<p>The <code>check</code> method is responsible for determining if breakeven has been reached, considering factors like transaction costs and whether the stop-loss can safely move. If breakeven is triggered, it records this and notifies listeners, also saving the state.</p>
<p>The <code>clear</code> method resets the breakeven status when a trade is finished, cleaning up any related data and ensuring that records are updated.</p>
<a id="interface-ibiddata" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IBidData<a href="#interface-ibiddata" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface represents a single bid or ask found within an order book. It contains two key pieces of information: the price at which the order is placed, and the quantity of the asset available at that price. Both the price and quantity are stored as strings, allowing for flexibility in representing different data formats. Think of it as a snapshot of a specific price point and its associated volume in the market.</p>
<a id="interface-iaveragebuycommitrow" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IAverageBuyCommitRow<a href="#interface-iaveragebuycommitrow" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface represents a single step in a queued average-buy, also known as a Dollar-Cost Averaging (DCA) strategy. Think of it as a record of one buy order within a larger averaging plan. It tells you that an average-buy action took place, and importantly, it stores the price at which that buy happened.  You'll also find the total number of buy entries accumulated so far after adding this new one. This data is helpful for tracking the progress and costs of your DCA strategy.</p>
<a id="interface-iactivatescheduledcommitrow" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IActivateScheduledCommitRow<a href="#interface-iactivatescheduledcommitrow" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface represents a queued action for activating a scheduled commit within the backtest-kit framework. Think of it as a message saying, &quot;Hey, we need to trigger a specific scheduled commit.&quot;</p>
<p>It includes the type of action, which is always &quot;activate-scheduled&quot;, and crucially, a <code>signalId</code> which identifies the particular signal that's being activated. There's also an optional <code>activateId</code> which can be used when an activation is manually triggered by the user. This allows for more controlled activation processes.</p>
<a id="interface-iactionschema" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IActionSchema<a href="#interface-iactionschema" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The <code>IActionSchema</code> lets you extend a trading strategy with custom logic that responds to events happening during backtesting. Think of it as a way to plug in your own functions to do things like track performance, send notifications, or integrate with external systems.</p>
<p>You define these custom actions by giving them a unique name, optionally adding a note to explain what they do, and providing either a constructor function or pre-defined methods that will be executed when certain events occur.</p>
<p>These actions are created fresh for each strategy and timeframe combination, so they have access to all the data generated during the backtest. You can add multiple actions to a single strategy, letting you build a really customized and comprehensive system. Finally, you can specify callbacks to control exactly when your action's code runs, allowing for precise timing and interaction.</p>
<a id="interface-iactionparams" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IActionParams<a href="#interface-iactionparams" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface defines the information given to actions when they're run within the backtest-kit framework. Think of it as a package of details that helps the action understand its surroundings and behave correctly. It includes a logger to track what's happening, information about the strategy and timeframe it’s part of, and flags indicating whether the action is running a simulation (backtest) or live trading. You'll find things like the strategy’s name, the exchange being used, and a way to record messages for debugging purposes inside this bundle of data.</p>
<a id="interface-iactioncallbacks" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IActionCallbacks<a href="#interface-iactioncallbacks" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface, <code>IActionCallbacks</code>, provides a way to hook into different stages of an action handler's lifecycle within the backtest-kit framework. Think of it as a set of customizable events that let you perform specific tasks at crucial moments. You can use these callbacks to manage resources, track events, or even persist state.</p>
<p>Here’s a breakdown of what each callback offers:</p>
<ul>
<li><strong><code>onInit</code>:</strong> This function runs when the action handler starts up. It's the perfect place to set up connections to databases or external services, load any saved data, or prepare for processing.</li>
<li><strong><code>onDispose</code>:</strong> When the action handler shuts down, <code>onDispose</code> is called. Use this to clean up any resources you created during initialization, like closing connections or saving data.</li>
<li><strong><code>onSignal</code>:</strong> This callback receives information about every signal generated – whether you're backtesting or trading live.</li>
<li><strong><code>onSignalLive</code>:</strong>  Similar to <code>onSignal</code>, but specifically for live trading scenarios.</li>
<li><strong><code>onSignalBacktest</code>:</strong>  Specifically for backtesting, this callback provides signal data during historical analysis.</li>
<li><strong><code>onBreakevenAvailable</code>:</strong>  Alerted when the breakeven point is reached.</li>
<li><strong><code>onPartialProfitAvailable</code>:</strong>  Notified when a partial profit level is hit.</li>
<li><strong><code>onPartialLossAvailable</code>:</strong>  Notified when a partial loss level is reached.</li>
<li><strong><code>onPingScheduled</code>:</strong>  Called regularly while a signal is waiting to be activated.</li>
<li><strong><code>onPingActive</code>:</strong>  Called regularly while a signal is actively trading.</li>
<li><strong><code>onRiskRejection</code>:</strong>  Called when a signal is blocked by the risk management system.</li>
</ul>
<p>All of these callbacks are optional.  You can choose to implement only the ones that are relevant to your specific needs. They can either return a normal value or a promise, enabling both synchronous and asynchronous operations.</p>
<a id="interface-iaction" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface IAction<a href="#interface-iaction" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The <code>IAction</code> interface is your central hub for reacting to events happening within the backtest-kit framework. Think of it as a way to plug in your own custom logic to respond to what’s going on.</p>
<p>You can use this interface to build things like:</p>
<ul>
<li>Dispatching actions to a state management library like Redux or Zustand.</li>
<li>Logging events for debugging or auditing.</li>
<li>Sending data to real-time dashboards.</li>
<li>Collecting analytics and metrics about your trading strategies.</li>
</ul>
<p>It provides several methods for different event types. <code>signal</code> handles events from both live and backtest modes, while <code>signalLive</code> and <code>signalBacktest</code> are specifically for live and backtest environments respectively.</p>
<p>There are also methods for handling breakeven events, partial profit/loss events, scheduled and active ping events, and risk rejections.</p>
<p>Finally, <code>dispose</code> is an important method to clean up any resources or subscriptions when you’re finished with your action handler, ensuring a clean shutdown.</p>
<a id="interface-heatmapstatisticsmodel" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface HeatmapStatisticsModel<a href="#interface-heatmapstatisticsmodel" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This model organizes the data you see in a portfolio heatmap, giving you a quick view of how your investments are performing overall. It breaks down the information into key areas, starting with an array of individual symbol statistics, each representing a different asset in your portfolio. Alongside this, you'll find the total number of symbols being tracked, the overall profit and loss (PNL) for the entire portfolio, a Sharpe Ratio indicating risk-adjusted performance, and the total number of trades executed across all symbols. Essentially, this structure provides a consolidated snapshot of your portfolio's health.</p>
<a id="interface-donecontract" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface DoneContract<a href="#interface-donecontract" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This <code>DoneContract</code> acts like a notification when a background task finishes, whether it's a backtest or a live trading execution. It provides details about what just completed, including the exchange used, the name of the trading strategy, and whether it was a backtest or a live run. You'll also find the trading symbol involved, like &quot;BTCUSDT&quot;, and the name of the frame used if applicable. Essentially, it gives you a concise summary of the finished operation.</p>
<a id="interface-criticalerrornotification" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface CriticalErrorNotification<a href="#interface-criticalerrornotification" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This notification signals a critical error within the backtest-kit framework, indicating a problem so severe that the process needs to be stopped. Each notification has a unique identifier and a human-readable message to help understand what went wrong. It also includes detailed information about the error itself, like a stack trace and any related data. Importantly, these notifications always come from the live context, meaning they aren't generated during the backtesting simulation itself.</p>
<a id="interface-columnmodel" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ColumnModel<a href="#interface-columnmodel" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This describes how to set up columns for displaying data in tables, particularly when generating markdown tables. Each column has a unique identifier, a user-friendly label that appears as the header, and a function to format the data within that column into a readable string. You can also specify a function to control whether a particular column should be displayed at all, offering flexibility in what information is shown. Essentially, it's all about defining how your data is presented in a tabular format.</p>
<a id="interface-closependingcommit" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ClosePendingCommit<a href="#interface-closependingcommit" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This signal lets your backtest know that a pending order should be closed. It's used when you want to manually intervene and shut down a pending order, perhaps because of a change in strategy or unexpected market conditions. The <code>action</code> property is always set to &quot;close-pending&quot; to identify the signal type. You can also include a <code>closeId</code> to give a specific reason for closing the order, which can be useful for tracking and analysis.</p>
<a id="interface-cancelscheduledcommit" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface CancelScheduledCommit<a href="#interface-cancelscheduledcommit" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface lets you cancel a previously scheduled signal event. Think of it as a way to reverse a future action that's already been planned within the backtest-kit system. You’ll need to specify the action as &quot;cancel-scheduled&quot; to indicate what you’re doing. Optionally, you can provide a <code>cancelId</code> – a string that helps you identify the reason for the cancellation, useful for tracking or debugging.</p>
<a id="interface-breakevenstatisticsmodel" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface BreakevenStatisticsModel<a href="#interface-breakevenstatisticsmodel" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This model holds information about breakeven points reached during a trading backtest. It keeps track of every single breakeven event, giving you a detailed list of when those milestones were hit. You can also easily see the total number of breakeven events that occurred throughout the backtest. Essentially, it's your go-to place to understand how frequently and when your strategy reached breakeven.</p>
<a id="interface-breakevenevent" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface BreakevenEvent<a href="#interface-breakevenevent" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This data structure holds all the details about when a trade reached its breakeven point. Think of it as a snapshot of a trade's progress.</p>
<p>It includes information like the exact time, the trading pair involved, the strategy used, and a unique identifier for the signal that triggered the trade.</p>
<p>You’ll find key price points here too, such as the entry price (breakeven level), take profit target, and stop-loss levels, along with their original values set when the trade was initially created.</p>
<p>If the trade involved averaging your buys (DCA), you'll see the total number of entries and the original entry price before averaging took place. There’s also information about partial closes, along with a human-readable note describing why the signal was generated, when the position became active, and when the signal was initially created. Finally, it indicates whether the trade occurred during a backtest or a live trading session.</p>
<a id="interface-breakevencontract" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface BreakevenContract<a href="#interface-breakevencontract" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface represents a breakeven event, which happens when a trading signal's stop-loss is adjusted back to the entry price. It's a way to track when a strategy has reduced its risk, effectively covering transaction costs and potentially locking in some profit. These events are only triggered once for each signal and are designed to be reliable.</p>
<p>The information included in a breakeven event tells you what trading pair, strategy, and exchange it relates to, along with details about the original signal and the current market price at the time of the event. You’ll also find information about whether this event is from a backtest or live trading, and the precise timestamp of when it occurred. Services like reporting tools and user callbacks use this data to understand strategy performance and risk management.</p>
<a id="interface-breakevencommitnotification" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface BreakevenCommitNotification<a href="#interface-breakevencommitnotification" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This notification tells you when a breakeven action has been taken within your trading strategy. It’s like getting a confirmation that your strategy has adjusted its take profit or stop loss to reach a breakeven point.</p>
<p>Each notification has a unique ID and timestamp, so you can track these events precisely. You’ll also see details about the trade itself, including the symbol being traded, the strategy that triggered the action, the exchange used, and the direction of the trade (long or short).</p>
<p>The notification provides the entry price, original and adjusted take profit and stop loss prices, along with information about any DCA (dollar-cost averaging) that might have been involved. It also includes timestamps related to the signal's creation and when the position became active, giving you a full timeline of the trade's lifecycle. It also indicates whether the event occurred during a backtest or live trading.</p>
<a id="interface-breakevencommit" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface BreakevenCommit<a href="#interface-breakevencommit" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The <code>BreakevenCommit</code> represents a breakeven event triggered within the backtest system. It signifies a moment when the system automatically adjusts a trade's stop-loss price to be equal to its entry price, aiming to protect profits and limit potential losses.</p>
<p>This event includes key details about the trade, such as its direction (long or short), the entry price, the original and adjusted take profit and stop-loss prices, and the current market price when the breakeven adjustment occurred. You’ll also find timestamps indicating when the breakeven signal was generated and when the position was initially activated. Essentially, it’s a record of a crucial risk management action taken during a trade.</p>
<a id="interface-breakevenavailablenotification" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface BreakevenAvailableNotification<a href="#interface-breakevenavailablenotification" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This notification lets you know when a signal’s stop-loss order has reached the breakeven point – meaning it can now be moved to your original entry price. It's triggered when the market moves favorably enough to allow this.</p>
<p>The notification includes a lot of useful information, like a unique ID for the notification and the signal, the trading symbol (e.g., BTCUSDT), and the name of the strategy that generated the signal. You’ll also find details about the current market price, your original entry price, and the current take profit and stop-loss levels.</p>
<p>It also tells you whether this event happened during a backtest or in a live trading environment, and includes timestamps for when the signal was created, went pending, and when this particular breakeven notification was generated. If you're using dollar-cost averaging (DCA), the notification also provides information about the total number of entries.</p>
<a id="interface-backteststatisticsmodel" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface BacktestStatisticsModel<a href="#interface-backteststatisticsmodel" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This model collects a wide range of statistics after you run a backtest, giving you a clear picture of how your trading strategy performed. It stores every closed trade's details in a list, along with the total number of trades, how many were winners and losers, and the win rate.</p>
<p>You’ll also find key performance indicators like average profit per trade, overall cumulative profit, and measures of risk like standard deviation and the Sharpe Ratio – which helps assess risk-adjusted returns.  There are even more specialized metrics like the certainty ratio and expected yearly returns. If any of these calculations encounter potentially unreliable data, the value will be marked as null to avoid misleading interpretations.</p>
<a id="interface-averagebuycommitnotification" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface AverageBuyCommitNotification<a href="#interface-averagebuycommitnotification" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This notification is sent whenever a new averaging buy (DCA) is added to an existing position. It provides a detailed snapshot of the trade at the moment the averaging buy executes.</p>
<p>You’ll find key information here like a unique identifier, the timestamp of the action, and whether it happened during a backtest or a live trade. It tells you which symbol was traded, the name of the strategy that triggered it, and the exchange used.</p>
<p>The notification also gives you specifics about the trade itself, including the current price, the new effective average entry price, the total number of averaging entries now in the position, and the direction of the trade (long or short).</p>
<p>Importantly, it retains the original entry price and provides both the current, potentially trailing-adjusted, take profit and stop loss prices, along with their original values before any trailing adjustments were applied. Finally, timestamps related to signal creation and pending status are also included for comprehensive tracking.</p>
<a id="interface-averagebuycommit" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface AverageBuyCommit<a href="#interface-averagebuycommit" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface represents an average-buy event within the backtest-kit framework. It’s triggered whenever a new buy (or sell for short positions) is added to a position that's already using a dollar-cost averaging strategy.</p>
<p>The event provides details about the trade, including the price at which the averaging buy was executed (<code>currentPrice</code>), the new, averaged entry price (<code>effectivePriceOpen</code>), and the original entry price when the position was initially opened (<code>priceOpen</code>).  You'll also find information about the take profit and stop loss prices – both the original values and the effective values after any trailing adjustments have been applied.</p>
<p>The <code>scheduledAt</code> property tells you when the signal that triggered the entire process was originally created, and <code>pendingAt</code> indicates when the position actually became active. This data helps you analyze the performance of your averaging strategy and understand how price movements are affecting your position.</p>
<a id="interface-activepingcontract" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ActivePingContract<a href="#interface-activepingcontract" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The ActivePingContract helps you keep track of what's happening when a trading signal is active and being monitored. Think of it as a heartbeat signal, sent every minute while a signal is still open.</p>
<p>This signal contains important details like the trading pair (symbol), the strategy that’s using it, and the exchange involved. You'll also receive the full details of the signal itself, including all the pricing information.</p>
<p>It tells you whether the event originates from a backtest (historical data) or live trading. Finally, it includes a timestamp to show exactly when the ping occurred, either the real-time moment for live trading or the candle timestamp during backtesting.</p>
<p>You can use this data to build custom logic to manage active signals, reacting to these &quot;ping&quot; events as they happen.</p>
<a id="interface-activatescheduledcommitnotification" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ActivateScheduledCommitNotification<a href="#interface-activatescheduledcommitnotification" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This notification signals that a scheduled trade has been activated by a user, meaning it's been triggered without waiting for the price to reach the initially planned entry point. It provides a wealth of details about the trade, including a unique identifier, when it was activated, and whether it occurred during a backtest or live trading. You'll find information about the specific trading pair, the strategy that generated the signal, the exchange used, and the trade direction (long or short).</p>
<p>The notification also contains key pricing information like the entry price, take profit, and stop loss levels, both as they currently stand and as they were originally set before any adjustments.  Details on any dollar-cost averaging (DCA) used are included, showing the total number of entries. Crucially, the notification includes timestamps for when the signal was initially created, when it went pending, and when the notification itself was generated, giving you a complete timeline. Finally, it includes the current market price at the time of activation.</p>
<a id="interface-activatescheduledcommit" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Interface ActivateScheduledCommit<a href="#interface-activatescheduledcommit" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>This interface defines the data needed to activate a trading signal that was previously scheduled. It's used when a pre-planned trade is triggered, letting the system know to execute it now.</p>
<p>The <code>action</code> property clearly identifies this as an &quot;activate-scheduled&quot; event. You can optionally provide an <code>activateId</code> to track why the activation happened, useful for user-specific reasons.</p>
<p>The interface also carries essential details about the trade itself, including the <code>position</code> (long or short), <code>priceOpen</code> (entry price), <code>priceTakeProfit</code> (take profit price), and <code>priceStopLoss</code> (stop loss price). It also includes the original values of the take profit and stop loss prices, before any automatic adjustments were applied.</p>
<p>Finally, the <code>scheduledAt</code> property records when the signal was initially created, and <code>pendingAt</code> records the exact moment the activation occurs, crucial for timing and reconciliation.</p>
</div></div><div class="col-sidebar"><div class="page-menu"><div class="tsd-navigation settings"><details class="tsd-accordion"><summary class="tsd-accordion-summary"><h3><svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-chevronDown"></use></svg>Settings</h3></summary><div class="tsd-accordion-details"><div class="tsd-filter-visibility"><span class="settings-label">Member Visibility</span><ul id="tsd-filter-options"><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-protected" name="protected"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Protected</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-inherited" name="inherited" checked/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Inherited</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-external" name="external"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>External</span></label></li></ul></div><div class="tsd-theme-toggle"><label class="settings-label" for="tsd-theme">Theme</label><select id="tsd-theme"><option value="os">OS</option><option value="light">Light</option><option value="dark">Dark</option></select></div></div></details></div><details open class="tsd-accordion tsd-page-navigation"><summary class="tsd-accordion-summary"><h3><svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-chevronDown"></use></svg>On This Page</h3></summary><div class="tsd-accordion-details"><a href="#backtest-kit-api-reference"><span>backtest-<wbr/>kit api reference</span></a><a href="#backtest-kit-interfaces"><span>backtest-<wbr/>kit interfaces</span></a><ul><li><a href="#interface-walkerstopcontract"><span>Interface <wbr/>Walker<wbr/>Stop<wbr/>Contract</span></a></li><li><a href="#interface-walkerstatisticsmodel"><span>Interface <wbr/>Walker<wbr/>Statistics<wbr/>Model</span></a></li><li><a href="#interface-walkercontract"><span>Interface <wbr/>Walker<wbr/>Contract</span></a></li><li><a href="#interface-walkercompletecontract"><span>Interface <wbr/>Walker<wbr/>Complete<wbr/>Contract</span></a></li><li><a href="#interface-validationerrornotification"><span>Interface <wbr/>Validation<wbr/>Error<wbr/>Notification</span></a></li><li><a href="#interface-validateargs"><span>Interface <wbr/>Validate<wbr/>Args</span></a></li><li><a href="#interface-trailingtakecommitnotification"><span>Interface <wbr/>Trailing<wbr/>Take<wbr/>Commit<wbr/>Notification</span></a></li><li><a href="#interface-trailingtakecommit"><span>Interface <wbr/>Trailing<wbr/>Take<wbr/>Commit</span></a></li><li><a href="#interface-trailingstopcommitnotification"><span>Interface <wbr/>Trailing<wbr/>Stop<wbr/>Commit<wbr/>Notification</span></a></li><li><a href="#interface-trailingstopcommit"><span>Interface <wbr/>Trailing<wbr/>Stop<wbr/>Commit</span></a></li><li><a href="#interface-tickevent"><span>Interface <wbr/>Tick<wbr/>Event</span></a></li><li><a href="#interface-strategystatisticsmodel"><span>Interface <wbr/>Strategy<wbr/>Statistics<wbr/>Model</span></a></li><li><a href="#interface-strategyevent"><span>Interface <wbr/>Strategy<wbr/>Event</span></a></li><li><a href="#interface-signalschedulednotification"><span>Interface <wbr/>Signal<wbr/>Scheduled<wbr/>Notification</span></a></li><li><a href="#interface-signalopenednotification"><span>Interface <wbr/>Signal<wbr/>Opened<wbr/>Notification</span></a></li><li><a href="#interface-signaldata1"><span>Interface <wbr/>Signal<wbr/>Data$1</span></a></li><li><a href="#interface-signalcommitbase"><span>Interface <wbr/>Signal<wbr/>Commit<wbr/>Base</span></a></li><li><a href="#interface-signalclosednotification"><span>Interface <wbr/>Signal<wbr/>Closed<wbr/>Notification</span></a></li><li><a href="#interface-signalcancellednotification"><span>Interface <wbr/>Signal<wbr/>Cancelled<wbr/>Notification</span></a></li><li><a href="#interface-scheduledevent"><span>Interface <wbr/>Scheduled<wbr/>Event</span></a></li><li><a href="#interface-schedulestatisticsmodel"><span>Interface <wbr/>Schedule<wbr/>Statistics<wbr/>Model</span></a></li><li><a href="#interface-schedulepingcontract"><span>Interface <wbr/>Schedule<wbr/>Ping<wbr/>Contract</span></a></li><li><a href="#interface-riskstatisticsmodel"><span>Interface <wbr/>Risk<wbr/>Statistics<wbr/>Model</span></a></li><li><a href="#interface-riskrejectionnotification"><span>Interface <wbr/>Risk<wbr/>Rejection<wbr/>Notification</span></a></li><li><a href="#interface-riskevent"><span>Interface <wbr/>Risk<wbr/>Event</span></a></li><li><a href="#interface-riskcontract"><span>Interface <wbr/>Risk<wbr/>Contract</span></a></li><li><a href="#interface-progresswalkercontract"><span>Interface <wbr/>Progress<wbr/>Walker<wbr/>Contract</span></a></li><li><a href="#interface-progressbacktestcontract"><span>Interface <wbr/>Progress<wbr/>Backtest<wbr/>Contract</span></a></li><li><a href="#interface-performancestatisticsmodel"><span>Interface <wbr/>Performance<wbr/>Statistics<wbr/>Model</span></a></li><li><a href="#interface-performancecontract"><span>Interface <wbr/>Performance<wbr/>Contract</span></a></li><li><a href="#interface-partialstatisticsmodel"><span>Interface <wbr/>Partial<wbr/>Statistics<wbr/>Model</span></a></li><li><a href="#interface-partialprofitcontract"><span>Interface <wbr/>Partial<wbr/>Profit<wbr/>Contract</span></a></li><li><a href="#interface-partialprofitcommitnotification"><span>Interface <wbr/>Partial<wbr/>Profit<wbr/>Commit<wbr/>Notification</span></a></li><li><a href="#interface-partialprofitcommit"><span>Interface <wbr/>Partial<wbr/>Profit<wbr/>Commit</span></a></li><li><a href="#interface-partialprofitavailablenotification"><span>Interface <wbr/>Partial<wbr/>Profit<wbr/>Available<wbr/>Notification</span></a></li><li><a href="#interface-partiallosscontract"><span>Interface <wbr/>Partial<wbr/>Loss<wbr/>Contract</span></a></li><li><a href="#interface-partiallosscommitnotification"><span>Interface <wbr/>Partial<wbr/>Loss<wbr/>Commit<wbr/>Notification</span></a></li><li><a href="#interface-partiallosscommit"><span>Interface <wbr/>Partial<wbr/>Loss<wbr/>Commit</span></a></li><li><a href="#interface-partiallossavailablenotification"><span>Interface <wbr/>Partial<wbr/>Loss<wbr/>Available<wbr/>Notification</span></a></li><li><a href="#interface-partialevent"><span>Interface <wbr/>Partial<wbr/>Event</span></a></li><li><a href="#interface-metricstats"><span>Interface <wbr/>Metric<wbr/>Stats</span></a></li><li><a href="#interface-message"><span>Interface <wbr/>Message</span></a></li><li><a href="#interface-livestatisticsmodel"><span>Interface <wbr/>Live<wbr/>Statistics<wbr/>Model</span></a></li><li><a href="#interface-infoerrornotification"><span>Interface <wbr/>Info<wbr/>Error<wbr/>Notification</span></a></li><li><a href="#interface-iwalkerstrategyresult"><span>Interface IWalker<wbr/>Strategy<wbr/>Result</span></a></li><li><a href="#interface-iwalkerschema"><span>Interface IWalker<wbr/>Schema</span></a></li><li><a href="#interface-iwalkerresults"><span>Interface IWalker<wbr/>Results</span></a></li><li><a href="#interface-iwalkercallbacks"><span>Interface IWalker<wbr/>Callbacks</span></a></li><li><a href="#interface-itrailingtakecommitrow"><span>Interface ITrailing<wbr/>Take<wbr/>Commit<wbr/>Row</span></a></li><li><a href="#interface-itrailingstopcommitrow"><span>Interface ITrailing<wbr/>Stop<wbr/>Commit<wbr/>Row</span></a></li><li><a href="#interface-istrategytickresultwaiting"><span>Interface IStrategy<wbr/>Tick<wbr/>Result<wbr/>Waiting</span></a></li><li><a href="#interface-istrategytickresultscheduled"><span>Interface IStrategy<wbr/>Tick<wbr/>Result<wbr/>Scheduled</span></a></li><li><a href="#interface-istrategytickresultopened"><span>Interface IStrategy<wbr/>Tick<wbr/>Result<wbr/>Opened</span></a></li><li><a href="#interface-istrategytickresultidle"><span>Interface IStrategy<wbr/>Tick<wbr/>Result<wbr/>Idle</span></a></li><li><a href="#interface-istrategytickresultclosed"><span>Interface IStrategy<wbr/>Tick<wbr/>Result<wbr/>Closed</span></a></li><li><a href="#interface-istrategytickresultcancelled"><span>Interface IStrategy<wbr/>Tick<wbr/>Result<wbr/>Cancelled</span></a></li><li><a href="#interface-istrategytickresultactive"><span>Interface IStrategy<wbr/>Tick<wbr/>Result<wbr/>Active</span></a></li><li><a href="#interface-istrategyschema"><span>Interface IStrategy<wbr/>Schema</span></a></li><li><a href="#interface-istrategyresult"><span>Interface IStrategy<wbr/>Result</span></a></li><li><a href="#interface-istrategypnl"><span>Interface IStrategy<wbr/>PnL</span></a></li><li><a href="#interface-istrategycallbacks"><span>Interface IStrategy<wbr/>Callbacks</span></a></li><li><a href="#interface-istrategy"><span>Interface IStrategy</span></a></li><li><a href="#interface-istorageutils"><span>Interface IStorage<wbr/>Utils</span></a></li><li><a href="#interface-istoragesignalrowscheduled"><span>Interface IStorage<wbr/>Signal<wbr/>Row<wbr/>Scheduled</span></a></li><li><a href="#interface-istoragesignalrowopened"><span>Interface IStorage<wbr/>Signal<wbr/>Row<wbr/>Opened</span></a></li><li><a href="#interface-istoragesignalrowclosed"><span>Interface IStorage<wbr/>Signal<wbr/>Row<wbr/>Closed</span></a></li><li><a href="#interface-istoragesignalrowcancelled"><span>Interface IStorage<wbr/>Signal<wbr/>Row<wbr/>Cancelled</span></a></li><li><a href="#interface-istoragesignalrowbase"><span>Interface IStorage<wbr/>Signal<wbr/>Row<wbr/>Base</span></a></li><li><a href="#interface-isizingschemakelly"><span>Interface ISizing<wbr/>Schema<wbr/>Kelly</span></a></li><li><a href="#interface-isizingschemafixedpercentage"><span>Interface ISizing<wbr/>Schema<wbr/>Fixed<wbr/>Percentage</span></a></li><li><a href="#interface-isizingschemabase"><span>Interface ISizing<wbr/>Schema<wbr/>Base</span></a></li><li><a href="#interface-isizingschemaatr"><span>Interface ISizing<wbr/>SchemaATR</span></a></li><li><a href="#interface-isizingparamskelly"><span>Interface ISizing<wbr/>Params<wbr/>Kelly</span></a></li><li><a href="#interface-isizingparamsfixedpercentage"><span>Interface ISizing<wbr/>Params<wbr/>Fixed<wbr/>Percentage</span></a></li><li><a href="#interface-isizingparamsatr"><span>Interface ISizing<wbr/>ParamsATR</span></a></li><li><a href="#interface-isizingcallbacks"><span>Interface ISizing<wbr/>Callbacks</span></a></li><li><a href="#interface-isizingcalculateparamskelly"><span>Interface ISizing<wbr/>Calculate<wbr/>Params<wbr/>Kelly</span></a></li><li><a href="#interface-isizingcalculateparamsfixedpercentage"><span>Interface ISizing<wbr/>Calculate<wbr/>Params<wbr/>Fixed<wbr/>Percentage</span></a></li><li><a href="#interface-isizingcalculateparamsbase"><span>Interface ISizing<wbr/>Calculate<wbr/>Params<wbr/>Base</span></a></li><li><a href="#interface-isizingcalculateparamsatr"><span>Interface ISizing<wbr/>Calculate<wbr/>ParamsATR</span></a></li><li><a href="#interface-isizing"><span>Interface ISizing</span></a></li><li><a href="#interface-isignalrow"><span>Interface ISignal<wbr/>Row</span></a></li><li><a href="#interface-isignaldto"><span>Interface ISignal<wbr/>Dto</span></a></li><li><a href="#interface-ischeduledsignalrow"><span>Interface IScheduled<wbr/>Signal<wbr/>Row</span></a></li><li><a href="#interface-ischeduledsignalcancelrow"><span>Interface IScheduled<wbr/>Signal<wbr/>Cancel<wbr/>Row</span></a></li><li><a href="#interface-iriskvalidationpayload"><span>Interface IRisk<wbr/>Validation<wbr/>Payload</span></a></li><li><a href="#interface-iriskvalidationfn"><span>Interface IRisk<wbr/>Validation<wbr/>Fn</span></a></li><li><a href="#interface-iriskvalidation"><span>Interface IRisk<wbr/>Validation</span></a></li><li><a href="#interface-irisksignalrow"><span>Interface IRisk<wbr/>Signal<wbr/>Row</span></a></li><li><a href="#interface-iriskschema"><span>Interface IRisk<wbr/>Schema</span></a></li><li><a href="#interface-iriskrejectionresult"><span>Interface IRisk<wbr/>Rejection<wbr/>Result</span></a></li><li><a href="#interface-iriskparams"><span>Interface IRisk<wbr/>Params</span></a></li><li><a href="#interface-iriskcheckargs"><span>Interface IRisk<wbr/>Check<wbr/>Args</span></a></li><li><a href="#interface-iriskcallbacks"><span>Interface IRisk<wbr/>Callbacks</span></a></li><li><a href="#interface-iriskactiveposition"><span>Interface IRisk<wbr/>Active<wbr/>Position</span></a></li><li><a href="#interface-irisk"><span>Interface IRisk</span></a></li><li><a href="#interface-ireporttarget"><span>Interface IReport<wbr/>Target</span></a></li><li><a href="#interface-ireportdumpoptions"><span>Interface IReport<wbr/>Dump<wbr/>Options</span></a></li><li><a href="#interface-ipublicsignalrow"><span>Interface IPublic<wbr/>Signal<wbr/>Row</span></a></li><li><a href="#interface-ipositionsizekellyparams"><span>Interface IPosition<wbr/>Size<wbr/>Kelly<wbr/>Params</span></a></li><li><a href="#interface-ipositionsizefixedpercentageparams"><span>Interface IPosition<wbr/>Size<wbr/>Fixed<wbr/>Percentage<wbr/>Params</span></a></li><li><a href="#interface-ipositionsizeatrparams"><span>Interface IPosition<wbr/>SizeATRParams</span></a></li><li><a href="#interface-ipersistbase"><span>Interface IPersist<wbr/>Base</span></a></li><li><a href="#interface-ipartialprofitcommitrow"><span>Interface IPartial<wbr/>Profit<wbr/>Commit<wbr/>Row</span></a></li><li><a href="#interface-ipartiallosscommitrow"><span>Interface IPartial<wbr/>Loss<wbr/>Commit<wbr/>Row</span></a></li><li><a href="#interface-ipartialdata"><span>Interface IPartial<wbr/>Data</span></a></li><li><a href="#interface-ipartial"><span>Interface IPartial</span></a></li><li><a href="#interface-iparseargsresult"><span>Interface IParse<wbr/>Args<wbr/>Result</span></a></li><li><a href="#interface-iparseargsparams"><span>Interface IParse<wbr/>Args<wbr/>Params</span></a></li><li><a href="#interface-iorderbookdata"><span>Interface IOrder<wbr/>Book<wbr/>Data</span></a></li><li><a href="#interface-inotificationutils"><span>Interface INotification<wbr/>Utils</span></a></li><li><a href="#interface-imethodcontext"><span>Interface IMethod<wbr/>Context</span></a></li><li><a href="#interface-imarkdowntarget"><span>Interface IMarkdown<wbr/>Target</span></a></li><li><a href="#interface-imarkdowndumpoptions"><span>Interface IMarkdown<wbr/>Dump<wbr/>Options</span></a></li><li><a href="#interface-ilogger"><span>Interface ILogger</span></a></li><li><a href="#interface-iheatmaprow"><span>Interface IHeatmap<wbr/>Row</span></a></li><li><a href="#interface-iframeschema"><span>Interface IFrame<wbr/>Schema</span></a></li><li><a href="#interface-iframeparams"><span>Interface IFrame<wbr/>Params</span></a></li><li><a href="#interface-iframecallbacks"><span>Interface IFrame<wbr/>Callbacks</span></a></li><li><a href="#interface-iframe"><span>Interface IFrame</span></a></li><li><a href="#interface-iexecutioncontext"><span>Interface IExecution<wbr/>Context</span></a></li><li><a href="#interface-iexchangeschema"><span>Interface IExchange<wbr/>Schema</span></a></li><li><a href="#interface-iexchangeparams"><span>Interface IExchange<wbr/>Params</span></a></li><li><a href="#interface-iexchangecallbacks"><span>Interface IExchange<wbr/>Callbacks</span></a></li><li><a href="#interface-iexchange"><span>Interface IExchange</span></a></li><li><a href="#interface-ientity"><span>Interface IEntity</span></a></li><li><a href="#interface-icommitrowbase"><span>Interface ICommit<wbr/>Row<wbr/>Base</span></a></li><li><a href="#interface-icheckcandlesparams"><span>Interface ICheck<wbr/>Candles<wbr/>Params</span></a></li><li><a href="#interface-icandledata"><span>Interface ICandle<wbr/>Data</span></a></li><li><a href="#interface-icachecandlesparams"><span>Interface ICache<wbr/>Candles<wbr/>Params</span></a></li><li><a href="#interface-ibreakevendata"><span>Interface IBreakeven<wbr/>Data</span></a></li><li><a href="#interface-ibreakevencommitrow"><span>Interface IBreakeven<wbr/>Commit<wbr/>Row</span></a></li><li><a href="#interface-ibreakeven"><span>Interface IBreakeven</span></a></li><li><a href="#interface-ibiddata"><span>Interface IBid<wbr/>Data</span></a></li><li><a href="#interface-iaveragebuycommitrow"><span>Interface IAverage<wbr/>Buy<wbr/>Commit<wbr/>Row</span></a></li><li><a href="#interface-iactivatescheduledcommitrow"><span>Interface IActivate<wbr/>Scheduled<wbr/>Commit<wbr/>Row</span></a></li><li><a href="#interface-iactionschema"><span>Interface IAction<wbr/>Schema</span></a></li><li><a href="#interface-iactionparams"><span>Interface IAction<wbr/>Params</span></a></li><li><a href="#interface-iactioncallbacks"><span>Interface IAction<wbr/>Callbacks</span></a></li><li><a href="#interface-iaction"><span>Interface IAction</span></a></li><li><a href="#interface-heatmapstatisticsmodel"><span>Interface <wbr/>Heatmap<wbr/>Statistics<wbr/>Model</span></a></li><li><a href="#interface-donecontract"><span>Interface <wbr/>Done<wbr/>Contract</span></a></li><li><a href="#interface-criticalerrornotification"><span>Interface <wbr/>Critical<wbr/>Error<wbr/>Notification</span></a></li><li><a href="#interface-columnmodel"><span>Interface <wbr/>Column<wbr/>Model</span></a></li><li><a href="#interface-closependingcommit"><span>Interface <wbr/>Close<wbr/>Pending<wbr/>Commit</span></a></li><li><a href="#interface-cancelscheduledcommit"><span>Interface <wbr/>Cancel<wbr/>Scheduled<wbr/>Commit</span></a></li><li><a href="#interface-breakevenstatisticsmodel"><span>Interface <wbr/>Breakeven<wbr/>Statistics<wbr/>Model</span></a></li><li><a href="#interface-breakevenevent"><span>Interface <wbr/>Breakeven<wbr/>Event</span></a></li><li><a href="#interface-breakevencontract"><span>Interface <wbr/>Breakeven<wbr/>Contract</span></a></li><li><a href="#interface-breakevencommitnotification"><span>Interface <wbr/>Breakeven<wbr/>Commit<wbr/>Notification</span></a></li><li><a href="#interface-breakevencommit"><span>Interface <wbr/>Breakeven<wbr/>Commit</span></a></li><li><a href="#interface-breakevenavailablenotification"><span>Interface <wbr/>Breakeven<wbr/>Available<wbr/>Notification</span></a></li><li><a href="#interface-backteststatisticsmodel"><span>Interface <wbr/>Backtest<wbr/>Statistics<wbr/>Model</span></a></li><li><a href="#interface-averagebuycommitnotification"><span>Interface <wbr/>Average<wbr/>Buy<wbr/>Commit<wbr/>Notification</span></a></li><li><a href="#interface-averagebuycommit"><span>Interface <wbr/>Average<wbr/>Buy<wbr/>Commit</span></a></li><li><a href="#interface-activepingcontract"><span>Interface <wbr/>Active<wbr/>Ping<wbr/>Contract</span></a></li><li><a href="#interface-activatescheduledcommitnotification"><span>Interface <wbr/>Activate<wbr/>Scheduled<wbr/>Commit<wbr/>Notification</span></a></li><li><a href="#interface-activatescheduledcommit"><span>Interface <wbr/>Activate<wbr/>Scheduled<wbr/>Commit</span></a></li></ul></div></details></div><div class="site-menu"><nav class="tsd-navigation"><a href="../modules.html">backtest-kit</a><ul class="tsd-small-nested-navigation" id="tsd-nav-container"><li>Loading...</li></ul></nav></div></div></div><footer><p class="tsd-generator">Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p></footer><div class="overlay"></div></body></html>

<!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function(m,e,t,r,i,k,a){
        m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();
        for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
        k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)
    })(window, document,'script','https://mc.yandex.ru/metrika/tag.js?id=105455585', 'ym');

    ym(105455585, 'init', {ssr:true, webvisor:true, clickmap:true, ecommerce:"dataLayer", accurateTrackBounce:true, trackLinks:true});
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/105455585" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3MQZEBBDDR"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-3MQZEBBDDR');
</script>
