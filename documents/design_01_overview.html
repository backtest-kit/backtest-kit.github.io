<!DOCTYPE html><html class="default" lang="en" data-base=".."><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="IE=edge"/><title>design/01_overview | backtest-kit</title><meta name="description" content="Documentation for backtest-kit"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="../assets/style.css"/><link rel="stylesheet" href="../assets/highlight.css"/><script defer src="../assets/main.js"></script><script async src="../assets/icons.js" id="tsd-icons-script"></script><script async src="../assets/search.js" id="tsd-search-script"></script><script async src="../assets/navigation.js" id="tsd-nav-script"></script><script async src="../assets/hierarchy.js" id="tsd-hierarchy-script"></script></head><body><script>document.documentElement.dataset.theme = localStorage.getItem("tsd-theme") || "os";document.body.style.display="none";setTimeout(() => app?app.showPage():document.body.style.removeProperty("display"),500)</script><header class="tsd-page-toolbar"><div class="tsd-toolbar-contents container"><div class="table-cell" id="tsd-search"><div class="field"><label for="tsd-search-field" class="tsd-widget tsd-toolbar-icon search no-caption"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-search"></use></svg></label><input type="text" id="tsd-search-field" aria-label="Search"/></div><div class="field"><div id="tsd-toolbar-links"></div></div><ul class="results"><li class="state loading">Preparing search index...</li><li class="state failure">The search index is not available</li></ul><a href="../index.html" class="title">backtest-kit</a></div><div class="table-cell" id="tsd-widgets"><a href="#" class="tsd-widget tsd-toolbar-icon menu no-caption" data-toggle="menu" aria-label="Menu"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-menu"></use></svg></a></div></div></header><div class="container container-main"><div class="col-content"><div class="tsd-page-title"><ul class="tsd-breadcrumb"><li><a href="../modules.html">backtest-kit</a></li><li><a href="design_01_overview.html">design/01_overview</a></li></ul></div><div class="tsd-panel tsd-typography"><a id="overview" class="tsd-anchor"></a><h1 class="tsd-anchor-link">Overview<a href="#overview" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h1><p><strong>backtest-kit</strong> is a production-ready TypeScript framework for developing, backtesting, and deploying algorithmic trading strategies with enterprise-grade reliability. The framework provides three execution modes (historical simulation, live trading, crash-safe state recovery), comprehensive signal validation, and event-driven observability. This document introduces the framework's purpose, architecture, and core concepts at a high level.</p>
<p>For detailed information about specific subsystems, see:</p>
<ul>
<li>Execution modes: <a href="design_52_backtesting.html">Backtest Mode</a>, <a href="design_56_live_trading.html">Live Trading</a>, <a href="design_61_walker_mode.html">Walker Comparison</a></li>
<li>Strategy development: <a href="design_24_strategy_schemas.html">Strategy Schemas</a>, <a href="design_46_signal_lifecycle.html">Signal Lifecycle</a></li>
<li>System architecture: <a href="design_09_architecture.html">Architecture</a>, <a href="design_38_service_layer.html">Service Layer</a></li>
<li>Advanced features: <a href="design_65_risk_management.html">Risk Management</a>, <a href="design_87_ai-powered_strategy_optimization.html">AI Optimization</a></li>
</ul>
<a id="purpose-and-design-goals" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Purpose and Design Goals<a href="#purpose-and-design-goals" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The framework solves a critical problem in algorithmic trading: <strong>bridging the gap between backtesting and production deployment</strong>. Traditional backtesting tools often fail when strategies move to live trading due to state management issues, unrealistic execution assumptions, or missing crash recovery. backtest-kit addresses these challenges through:</p>
<ol>
<li><strong>Unified Strategy Code</strong>: Identical strategy logic runs in backtest and live modes without modifications</li>
<li><strong>Crash-Safe Persistence</strong>: Atomic file writes ensure state recovery after process crashes with no duplicate signals</li>
<li><strong>Realistic Execution Simulation</strong>: VWAP pricing, fee/slippage modeling, and time-aware context propagation</li>
<li><strong>Portfolio-Level Risk Controls</strong>: Cross-strategy validation and position tracking</li>
<li><strong>Memory-Efficient Streaming</strong>: AsyncGenerator-based execution processes years of historical data without loading everything into memory</li>
</ol>
<p>The framework is structured as a <strong>dependency injection container</strong> that orchestrates ~60 services across 8 major subsystems, with a public API layer that hides internal complexity behind intuitive registration functions.</p>
<a id="core-architecture-layers" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Core Architecture Layers<a href="#core-architecture-layers" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The system implements a <strong>layered architecture</strong> with clear separation of concerns across five tiers, from user-facing API to persistence layer.</p>
<p><img src="../media/01_Overview_0.svg" alt="Mermaid Diagram"></p>
<p><strong>Layer Responsibilities</strong>:</p>
<table>
<thead>
<tr>
<th>Layer</th>
<th>Purpose</th>
<th>Key Components</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Public API</strong></td>
<td>User-facing functions for registration and execution</td>
<td><code>addStrategy()</code>, <code>Backtest</code>, <code>Live</code>, <code>Walker</code>, event listeners</td>
</tr>
<tr>
<td><strong>Command</strong></td>
<td>Validation and orchestration entry points</td>
<td><code>BacktestCommandService</code>, <code>LiveCommandService</code>, <code>WalkerCommandService</code></td>
</tr>
<tr>
<td><strong>Logic</strong></td>
<td>Execution orchestration and AsyncGenerator streaming</td>
<td><code>BacktestLogicPrivateService</code>, <code>LiveLogicPrivateService</code>, <code>WalkerLogicPrivateService</code></td>
</tr>
<tr>
<td><strong>Business Logic</strong></td>
<td>Core trading logic and state management</td>
<td><code>ClientStrategy</code>, <code>ClientExchange</code>, <code>ClientRisk</code>, <code>ClientFrame</code></td>
</tr>
<tr>
<td><strong>Persistence</strong></td>
<td>Crash-safe state storage with atomic writes</td>
<td><code>PersistSignalAdapter</code>, <code>PersistScheduleAdapter</code>, <code>PersistRiskAdapter</code></td>
</tr>
</tbody>
</table>
<p>Each layer depends only on layers below it, creating a <strong>unidirectional dependency graph</strong> that simplifies testing and maintenance. The Command layer validates inputs and delegates to Logic services, which orchestrate Business Logic components through dependency injection.</p>
<a id="component-registration-pattern" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Component Registration Pattern<a href="#component-registration-pattern" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The framework uses a <strong>registry-based dependency injection pattern</strong> where components are registered by name before execution. Registration functions (<code>addStrategy</code>, <code>addExchange</code>, <code>addFrame</code>, etc.) store schemas in registry services, which are later instantiated by Connection services during execution.</p>
<p><img src="../media/01_Overview_1.svg" alt="Mermaid Diagram"></p>
<p>This pattern enables <strong>dependency inversion</strong>: strategies reference exchanges by name (<code>exchangeName: &quot;binance&quot;</code>), not by direct import. Components can be registered in separate modules and assembled at runtime through string identifiers. The memoization layer in Connection services ensures each symbol-strategy-exchange combination gets exactly one instance, preventing duplicate state.</p>
<p><strong>Registration Flow</strong>:</p>
<ol>
<li>User calls <code>addStrategy({ strategyName: &quot;my-strategy&quot;, ... })</code></li>
<li>Function stores schema in <code>StrategySchemaService.schemas</code> Map</li>
<li>During execution, <code>StrategyConnectionService.getStrategy(&quot;my-strategy&quot;)</code> retrieves schema</li>
<li>Schema is instantiated into <code>ClientStrategy</code> instance with dependencies injected</li>
<li>Instance is memoized by <code>(symbol, strategyName)</code> key for reuse</li>
</ol>
<a id="execution-modes" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Execution Modes<a href="#execution-modes" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The framework provides three execution modes with distinct temporal semantics and completion behavior, but all share the same strategy logic and signal lifecycle.</p>
<p><img src="../media/01_Overview_2.svg" alt="Mermaid Diagram"></p>
<p><strong>Mode Characteristics</strong>:</p>
<table>
<thead>
<tr>
<th>Mode</th>
<th>Temporal Progression</th>
<th>Completion</th>
<th>State Persistence</th>
<th>Use Case</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Backtest</strong></td>
<td>Historical, sequential through timeframes</td>
<td>Finite, when all frames processed</td>
<td>Optional, for testing only</td>
<td>Historical strategy validation</td>
</tr>
<tr>
<td><strong>Live</strong></td>
<td>Real-time, <code>new Date()</code></td>
<td>Infinite, manual stop required</td>
<td>Required, crash-safe</td>
<td>Production trading</td>
</tr>
<tr>
<td><strong>Walker</strong></td>
<td>Historical, parallel strategy iteration</td>
<td>Finite, when all strategies tested</td>
<td>Optional</td>
<td>Strategy comparison and optimization</td>
</tr>
</tbody>
</table>
<p>All three modes use the same <code>ClientStrategy.tick()</code> method for signal generation and monitoring, ensuring consistent behavior across environments. The key difference is <strong>temporal context</strong>: Backtest iterates through fixed dates, Live uses current time, and Walker orchestrates multiple Backtest runs.</p>
<a id="signal-lifecycle" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Signal Lifecycle<a href="#signal-lifecycle" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>Signals (trading positions) progress through a <strong>state machine</strong> with six possible states and multiple terminal outcomes. The lifecycle is identical in backtest and live modes, with different timing mechanisms.</p>
<p><img src="../media/01_Overview_3.svg" alt="Mermaid Diagram"></p>
<p><strong>State Descriptions</strong>:</p>
<table>
<thead>
<tr>
<th>State</th>
<th>Description</th>
<th>Persistence</th>
<th>Validation</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>idle</strong></td>
<td>No active signal, waiting for entry conditions</td>
<td>None</td>
<td>N/A</td>
</tr>
<tr>
<td><strong>scheduled</strong></td>
<td>Limit order waiting for price to reach <code>priceOpen</code></td>
<td><code>PersistScheduleAdapter</code> (live mode)</td>
<td>Risk check on activation</td>
</tr>
<tr>
<td><strong>opened</strong></td>
<td>Signal just created, position about to activate</td>
<td><code>PersistSignalAdapter</code> (live mode)</td>
<td>Already validated</td>
</tr>
<tr>
<td><strong>active</strong></td>
<td>Position monitoring TP/SL/time expiration</td>
<td><code>PersistSignalAdapter</code> (live mode)</td>
<td>N/A</td>
</tr>
<tr>
<td><strong>closed</strong></td>
<td>Position closed via TP/SL/timeout</td>
<td>Removed from persistence</td>
<td>N/A</td>
</tr>
<tr>
<td><strong>cancelled</strong></td>
<td>Scheduled signal cancelled before activation</td>
<td>Removed from persistence</td>
<td>N/A</td>
</tr>
</tbody>
</table>
<p>The <strong>scheduled state</strong> is unique: it represents a limit order waiting for <code>priceOpen</code> to be reached. If the price moves against the position and hits the stop loss before activation, the signal is cancelled without ever opening a position. This prevents entering positions after conditions have deteriorated.</p>
<p><strong>Validation Pipeline</strong> (during <code>getSignal()</code>):</p>
<ol>
<li><strong>Interval throttling</strong>: Enforce minimum time between signal generation (e.g., &quot;5m&quot; = max one signal per 5 minutes)</li>
<li><strong>Risk gates</strong>: <code>ClientRisk.checkSignal()</code> validates portfolio-level constraints</li>
<li><strong>Signal validation</strong>: 30+ rules check TP/SL logic, price sanity, time limits, etc.</li>
</ol>
<a id="event-system" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Event System<a href="#event-system" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The framework implements a <strong>pub-sub event architecture</strong> with 16 emitters organized into 5 functional categories. All event callbacks use queued processing to ensure sequential execution even with async handlers.</p>
<p><img src="../media/01_Overview_4.svg" alt="Mermaid Diagram"></p>
<p><strong>Event Categories</strong>:</p>
<ol>
<li><strong>Signal Events</strong>: <code>signalEmitter</code>, <code>signalLiveEmitter</code>, <code>signalBacktestEmitter</code> - Emit <code>IStrategyTickResult</code> with action discriminator</li>
<li><strong>Progress Events</strong>: <code>progressBacktestEmitter</code>, <code>progressWalkerEmitter</code>, <code>progressOptimizerEmitter</code> - Emit completion percentages</li>
<li><strong>Completion Events</strong>: <code>doneLiveSubject</code>, <code>doneBacktestSubject</code>, <code>doneWalkerSubject</code> - Emit <code>DoneContract</code> with metadata</li>
<li><strong>Error Events</strong>: <code>errorEmitter</code>, <code>exitEmitter</code> - Emit <code>Error</code> objects (recoverable vs fatal)</li>
<li><strong>Analysis Events</strong>: <code>partialProfitSubject</code>, <code>partialLossSubject</code> - Emit profit/loss milestone data</li>
</ol>
<p>All listeners use the <code>queued()</code> wrapper from <code>functools-kit</code> to serialize async callback execution. This prevents race conditions when multiple events arrive rapidly and callbacks perform stateful operations.</p>
<a id="context-propagation" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Context Propagation<a href="#context-propagation" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The framework uses <strong>async context propagation</strong> via <code>di-scoped</code> to implicitly pass runtime parameters through the call stack without explicit function arguments. This enables the same strategy code to work in both backtest (historical time) and live (real-time) modes.</p>
<p>Two context services provide implicit parameters:</p>
<p><strong>1. ExecutionContextService</strong> - Runtime execution parameters:</p>
<pre><code class="typescript"><span class="hl-7">interface</span><span class="hl-1"> </span><span class="hl-13">IExecutionContext</span><span class="hl-1"> {</span><br/><span class="hl-1">  </span><span class="hl-4">symbol</span><span class="hl-1">: </span><span class="hl-13">string</span><span class="hl-1">;      </span><span class="hl-5">// Trading pair (e.g., &quot;BTCUSDT&quot;)</span><br/><span class="hl-1">  </span><span class="hl-4">when</span><span class="hl-1">: </span><span class="hl-13">Date</span><span class="hl-1">;          </span><span class="hl-5">// Current timestamp (historical or real-time)</span><br/><span class="hl-1">  </span><span class="hl-4">backtest</span><span class="hl-1">: </span><span class="hl-13">boolean</span><span class="hl-1">;   </span><span class="hl-5">// Execution mode flag</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<p><strong>2. MethodContextService</strong> - Component routing parameters:</p>
<pre><code class="typescript"><span class="hl-7">interface</span><span class="hl-1"> </span><span class="hl-13">IMethodContext</span><span class="hl-1"> {</span><br/><span class="hl-1">  </span><span class="hl-4">strategyName</span><span class="hl-1">: </span><span class="hl-13">string</span><span class="hl-1">;   </span><span class="hl-5">// Which strategy to use</span><br/><span class="hl-1">  </span><span class="hl-4">exchangeName</span><span class="hl-1">: </span><span class="hl-13">string</span><span class="hl-1">;   </span><span class="hl-5">// Which exchange to use</span><br/><span class="hl-1">  </span><span class="hl-4">frameName</span><span class="hl-1">: </span><span class="hl-13">string</span><span class="hl-1">;      </span><span class="hl-5">// Which frame to use (empty in live mode)</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<p>These contexts are injected at the execution entry point and automatically propagated through all service calls:</p>
<pre><code><span class="hl-4">Backtest</span><span class="hl-1">.</span><span class="hl-0">run</span><span class="hl-1">(</span><span class="hl-4">symbol</span><span class="hl-1">, { </span><span class="hl-4">strategyName</span><span class="hl-1">, </span><span class="hl-4">exchangeName</span><span class="hl-1">, </span><span class="hl-4">frameName</span><span class="hl-1"> })</span><br/><span class="hl-1">  → </span><span class="hl-4">BacktestLogicPrivateService</span><span class="hl-1">.</span><span class="hl-0">execute</span><span class="hl-1">() [</span><span class="hl-4">sets</span><span class="hl-1"> </span><span class="hl-4">contexts</span><span class="hl-1">]</span><br/><span class="hl-1">    → </span><span class="hl-4">StrategyGlobalService</span><span class="hl-1">.</span><span class="hl-0">tick</span><span class="hl-1">() [</span><span class="hl-4">reads</span><span class="hl-1"> </span><span class="hl-4">contexts</span><span class="hl-1">]</span><br/><span class="hl-1">      → </span><span class="hl-4">ClientStrategy</span><span class="hl-1">.</span><span class="hl-0">tick</span><span class="hl-1">() [</span><span class="hl-4">uses</span><span class="hl-1"> </span><span class="hl-4">execution</span><span class="hl-1">.</span><span class="hl-4">context</span><span class="hl-1">.</span><span class="hl-4">when</span><span class="hl-1">]</span><br/><span class="hl-1">        → </span><span class="hl-4">ClientExchange</span><span class="hl-1">.</span><span class="hl-0">getCandles</span><span class="hl-1">() [</span><span class="hl-4">uses</span><span class="hl-1"> </span><span class="hl-4">execution</span><span class="hl-1">.</span><span class="hl-4">context</span><span class="hl-1">.</span><span class="hl-4">when</span><span class="hl-1">, </span><span class="hl-4">execution</span><span class="hl-1">.</span><span class="hl-4">context</span><span class="hl-1">.</span><span class="hl-4">symbol</span><span class="hl-1">]</span>
</code><button>Copy</button></pre>

<p>This architecture eliminates the need to pass <code>symbol</code>, <code>when</code>, <code>strategyName</code>, etc. as function parameters through every layer of the call stack. Strategy code can call <code>getAveragePrice(symbol)</code> and it automatically uses the correct timestamp from context.</p>
<a id="dependency-injection" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Dependency Injection<a href="#dependency-injection" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The framework uses a <strong>symbol-based dependency injection container</strong> with ~60 services registered at startup. Services are organized into a matrix pattern by component type (Strategy, Exchange, Frame, etc.) and function category (Connection, Schema, Global, Validation, etc.).</p>
<p><img src="../media/01_Overview_5.svg" alt="Mermaid Diagram"></p>
<p><strong>Service Organization Pattern</strong>:</p>
<p>Each component type (Strategy, Exchange, Frame, Risk, Sizing) has four service types:</p>
<ol>
<li><strong>Schema Service</strong>: Registry of user-registered schemas (<code>Map&lt;name, schema&gt;</code>)</li>
<li><strong>Connection Service</strong>: Instantiation and memoization of client instances</li>
<li><strong>Global Service</strong>: Context injection wrapper around connection service</li>
<li><strong>Validation Service</strong>: Schema validation logic</li>
</ol>
<p>Example for Strategy component:</p>
<ul>
<li><code>StrategySchemaService</code> - Stores <code>IStrategySchema</code> objects in Map</li>
<li><code>StrategyConnectionService</code> - Creates and memoizes <code>ClientStrategy</code> instances</li>
<li><code>StrategyGlobalService</code> - Wraps connection service with <code>ExecutionContextService.runInContext()</code></li>
<li><code>StrategyValidationService</code> - Validates strategy schemas on registration</li>
</ul>
<p>The <code>backtest</code> aggregation object (exported as <code>lib</code>) provides a flat namespace for accessing all services, used internally by public API functions.</p>
<a id="crash-recovery-and-persistence" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Crash Recovery and Persistence<a href="#crash-recovery-and-persistence" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>In live mode, the framework uses <strong>atomic file-based persistence</strong> to enable crash recovery with exactly-once execution guarantees. Four persistence adapters manage different state types:</p>
<table>
<thead>
<tr>
<th>Adapter</th>
<th>State Type</th>
<th>File Location</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>PersistSignalAdapter</code></td>
<td>Active signals</td>
<td><code>.backtest-kit/signals/{symbol}/{strategyName}.json</code></td>
<td>Resume monitoring after crash</td>
</tr>
<tr>
<td><code>PersistScheduleAdapter</code></td>
<td>Scheduled signals</td>
<td><code>.backtest-kit/schedule/{symbol}/{strategyName}.json</code></td>
<td>Resume waiting for activation</td>
</tr>
<tr>
<td><code>PersistRiskAdapter</code></td>
<td>Active positions</td>
<td><code>.backtest-kit/risk/{symbol}.json</code></td>
<td>Track portfolio-level risk</td>
</tr>
<tr>
<td><code>PersistPartialAdapter</code></td>
<td>Partial P&amp;L</td>
<td><code>.backtest-kit/partial/{symbol}/{strategyName}.json</code></td>
<td>Track milestone progress</td>
</tr>
</tbody>
</table>
<p><strong>Persistence Flow</strong>:</p>
<ol>
<li>Signal state changes (opened → active → closed)</li>
<li><code>ClientStrategy.setPendingSignal()</code> calls <code>PersistSignalAdapter.writeValue()</code></li>
<li>Adapter writes JSON to temporary file: <code>{path}.tmp</code></li>
<li>Atomic rename: <code>{path}.tmp</code> → <code>{path}</code></li>
<li>On crash and restart, <code>waitForInit()</code> reads persisted state</li>
<li>Strategy resumes from last persisted state</li>
</ol>
<p><strong>Custom Persistence Backends</strong>: Users can replace the default file-based adapters with custom implementations (Redis, MongoDB, PostgreSQL) by implementing <code>PersistBase</code> interface and registering via <code>use*Adapter()</code> methods:</p>
<pre><code class="typescript"><span class="hl-4">PersistSignalAdapter</span><span class="hl-1">.</span><span class="hl-0">usePersistSignalAdapter</span><span class="hl-1">(</span><span class="hl-4">RedisAdapter</span><span class="hl-1">);</span><br/><span class="hl-4">PersistRiskAdapter</span><span class="hl-1">.</span><span class="hl-0">usePersistRiskAdapter</span><span class="hl-1">(</span><span class="hl-4">MongoAdapter</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>The atomic write pattern (write to <code>.tmp</code>, then rename) ensures that crashes during write operations leave either the old valid state or the new valid state, never corrupted partial data.</p>
<a id="reporting-and-analytics" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Reporting and Analytics<a href="#reporting-and-analytics" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><use href="../assets/icons.svg#icon-anchor"></use></svg></a></h2><p>The framework generates <strong>markdown reports</strong> with statistical analysis for each execution mode. Reports are accumulated via event subscription and calculated on-demand or saved to disk.</p>
<p><img src="../media/01_Overview_6.svg" alt="Mermaid Diagram"></p>
<p><strong>Report Types</strong>:</p>
<table>
<thead>
<tr>
<th>Report</th>
<th>Service</th>
<th>Tracked Data</th>
<th>Key Metrics</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Backtest</strong></td>
<td><code>BacktestMarkdownService</code></td>
<td>Closed signals only</td>
<td>Sharpe Ratio, Win Rate, Total PNL, Expected Yearly Returns</td>
</tr>
<tr>
<td><strong>Live</strong></td>
<td><code>LiveMarkdownService</code></td>
<td>All events (idle, opened, active, closed)</td>
<td>Same as Backtest, plus event counts</td>
</tr>
<tr>
<td><strong>Schedule</strong></td>
<td><code>ScheduleMarkdownService</code></td>
<td>Scheduled/cancelled signals</td>
<td>Cancellation rate, Average wait time</td>
</tr>
<tr>
<td><strong>Walker</strong></td>
<td><code>WalkerMarkdownService</code></td>
<td>Strategy comparison results</td>
<td>Best strategy, Best metric value</td>
</tr>
<tr>
<td><strong>Partial</strong></td>
<td><code>PartialMarkdownService</code></td>
<td>Profit/loss milestones</td>
<td>Milestone distribution (10%, 20%, 30%...)</td>
</tr>
<tr>
<td><strong>Performance</strong></td>
<td><code>PerformanceMarkdownService</code></td>
<td>Execution timing metrics</td>
<td>P95/P99 latencies, Bottleneck detection</td>
</tr>
</tbody>
</table>
<p><strong>Statistics Calculation</strong> (Safe Math):</p>
<p>All numeric calculations use <code>isUnsafe()</code> checks to detect NaN/Infinity:</p>
<pre><code class="typescript"><span class="hl-7">function</span><span class="hl-1"> </span><span class="hl-0">isUnsafe</span><span class="hl-1">(</span><span class="hl-4">value</span><span class="hl-1">: </span><span class="hl-13">number</span><span class="hl-1"> | </span><span class="hl-13">null</span><span class="hl-1">): </span><span class="hl-13">boolean</span><span class="hl-1"> {</span><br/><span class="hl-1">  </span><span class="hl-3">return</span><span class="hl-1"> </span><span class="hl-7">typeof</span><span class="hl-1"> </span><span class="hl-4">value</span><span class="hl-1"> !== </span><span class="hl-2">&quot;number&quot;</span><span class="hl-1"> || </span><span class="hl-0">isNaN</span><span class="hl-1">(</span><span class="hl-4">value</span><span class="hl-1">) || !</span><span class="hl-0">isFinite</span><span class="hl-1">(</span><span class="hl-4">value</span><span class="hl-1">);</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<p>Metrics return <code>null</code> instead of invalid numbers, preventing downstream errors from propagating. Report generation uses null-safe formatting to display &quot;N/A&quot; for invalid values.</p>
<p><strong>Key Metrics</strong>:</p>
<ul>
<li><strong>Sharpe Ratio</strong>: <code>avgPnl / stdDev</code> (risk-adjusted return)</li>
<li><strong>Annualized Sharpe</strong>: <code>sharpeRatio × √365</code></li>
<li><strong>Certainty Ratio</strong>: <code>avgWin / |avgLoss|</code> (win quality metric)</li>
<li><strong>Expected Yearly Returns</strong>: <code>avgPnl × (365 / avgDurationDays)</code> (annualized return)</li>
</ul>
</div></div><div class="col-sidebar"><div class="page-menu"><div class="tsd-navigation settings"><details class="tsd-accordion"><summary class="tsd-accordion-summary"><h3><svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-chevronDown"></use></svg>Settings</h3></summary><div class="tsd-accordion-details"><div class="tsd-filter-visibility"><span class="settings-label">Member Visibility</span><ul id="tsd-filter-options"><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-protected" name="protected"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Protected</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-inherited" name="inherited" checked/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Inherited</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-external" name="external"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>External</span></label></li></ul></div><div class="tsd-theme-toggle"><label class="settings-label" for="tsd-theme">Theme</label><select id="tsd-theme"><option value="os">OS</option><option value="light">Light</option><option value="dark">Dark</option></select></div></div></details></div><details open class="tsd-accordion tsd-page-navigation"><summary class="tsd-accordion-summary"><h3><svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><use href="../assets/icons.svg#icon-chevronDown"></use></svg>On This Page</h3></summary><div class="tsd-accordion-details"><a href="#overview"><span>Overview</span></a><ul><li><a href="#purpose-and-design-goals"><span>Purpose and <wbr/>Design <wbr/>Goals</span></a></li><li><a href="#core-architecture-layers"><span>Core <wbr/>Architecture <wbr/>Layers</span></a></li><li><a href="#component-registration-pattern"><span>Component <wbr/>Registration <wbr/>Pattern</span></a></li><li><a href="#execution-modes"><span>Execution <wbr/>Modes</span></a></li><li><a href="#signal-lifecycle"><span>Signal <wbr/>Lifecycle</span></a></li><li><a href="#event-system"><span>Event <wbr/>System</span></a></li><li><a href="#context-propagation"><span>Context <wbr/>Propagation</span></a></li><li><a href="#dependency-injection"><span>Dependency <wbr/>Injection</span></a></li><li><a href="#crash-recovery-and-persistence"><span>Crash <wbr/>Recovery and <wbr/>Persistence</span></a></li><li><a href="#reporting-and-analytics"><span>Reporting and <wbr/>Analytics</span></a></li></ul></div></details></div><div class="site-menu"><nav class="tsd-navigation"><a href="../modules.html">backtest-kit</a><ul class="tsd-small-nested-navigation" id="tsd-nav-container"><li>Loading...</li></ul></nav></div></div></div><footer><p class="tsd-generator">Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p></footer><div class="overlay"></div></body></html>

<!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function(m,e,t,r,i,k,a){
        m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();
        for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
        k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)
    })(window, document,'script','https://mc.yandex.ru/metrika/tag.js?id=105455585', 'ym');

    ym(105455585, 'init', {ssr:true, webvisor:true, clickmap:true, ecommerce:"dataLayer", accurateTrackBounce:true, trackLinks:true});
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/105455585" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3MQZEBBDDR"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-3MQZEBBDDR');
</script>
